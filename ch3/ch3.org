#+BEGIN_SRC scheme
  (use sicp test)
#+END_SRC

* Chapter 3: Modularity, Objects, and State

** 3.1: Assignment and Local State

*** 3.1.1: Local State Variables

**** Exercise 3.1.

An /accumulator/ is a procedure that is called repeatedly with a single numeric
argument and accumulates its arguments into a sum. Each time it is called, it
returns the currently accumulated sum. Write a procedure ~make-accumulator~ that
generates accumulators, each maintaining an independent sum. The input to
~make-accumulator~ should specify the initial value of the sum; for example

#+BEGIN_SRC scheme
  (define A (make-accumulator 5))
  (A 10)
  15
  (A 10)
  25
#+END_SRC

***** Solution

#+BEGIN_SRC scheme
  (define (make-accumulator initial)
    (lambda (increment)
      (set! initial (+ initial increment))
      initial))
#+END_SRC

#+NAME: test-3-1
#+BEGIN_SRC scheme
  (define A (make-accumulator 5))
  (test 15
        (A 10))
  (test 25
        (A 10))
#+END_SRC

**** Exercise 3.2.

In software-testing applications, it is useful to be able to count the number
of times a given procedure is called during the course of a computation. Write
a procedure ~make-monitored~ that takes as input a procedure, ~f~, that itself
takes one input. The result returned by ~make-monitored~ is a third procedure,
say ~mf~, that keeps track of the number of times it has been called by
maintaining an internal counter. If the input to ~mf~ is the special symbol
~how-many-calls?~, then ~mf~ returns the value of the counter. If the input is
the special symbol ~reset-count~, then ~mf~ resets the counter to zero. For any
other input, ~mf~ returns the result of calling ~f~ on that input and
increments the counter. For instance, we could make a monitored version of the
~sqrt~ procedure:

#+BEGIN_SRC scheme
(define s (make-monitored sqrt))

(s 100)
10

(s 'how-many-calls?)
1
#+END_SRC

***** Solution

#+BEGIN_SRC scheme
  (define (make-monitored f)
    (define counter 0)
    (lambda (x)
      (cond ((equal? x 'how-many-calls?)
             counter)
            ((equal? x 'reset-count)
             (set! counter 0))
            (else
             (f x)
             (set! counter (+ counter 1))))))
#+END_SRC

#+NAME: test-3-2
#+BEGIN_SRC scheme
  (define s (make-monitored sqrt))
  (test 10
        (s 100))
  (test 1
        (s 'how-many-calls?))
#+END_SRC

*** Exercise 3.3.

Modify the ~make-account~ procedure so that it creates password-protected
accounts. That is, ~make-account~ should take a symbol as an additional
argument, as in

#+BEGIN_SRC scheme
  (define acc (make-account 100 'secret-password))
#+END_SRC

The resulting account object should process a request only if it is accompanied
by the password with which the account was created, and should otherwise return
a complaint:

#+BEGIN_SRC scheme
  ((acc 'secret-password 'withdraw) 40)
  60

  ((acc 'some-other-password 'deposit) 50)
  "Incorrect password"
#+END_SRC

***** Solution

#+BEGIN_SRC scheme
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x) "Incorrect password")
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request -- MAKE-ACCOUNT"
                             m)))))
    dispatch)
#+END_SRC

#+NAME: test-3-3
#+BEGIN_SRC scheme
  (define acc (make-account 100 'secret-password))
  (test 60
        ((acc 'secret-password 'withdraw) 40))
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
#+END_SRC

**** Exercise 3.4.

Modify the ~make-account~ procedure of exercise 3.3 by adding another local
state variable so that, if an account is accessed more than seven consecutive
times with an incorrect password, it invokes the procedure ~call-the-cops~.

***** Solution

As the prompt states, there's little more work involved than to add
a ~incorrect-password-attempts~, which we use to ~call-the-cops~ when too many
incorrect attempts in a row have been made. Ideally, a different response
would not be returned to the user when the cops have been called, but I've
decided to do so for ease of testing.

#+BEGIN_SRC scheme
  (define (make-account balance password)
    (define incorrect-password-attempts 0)
    (define (call-the-cops)
      "Please wait -- calling the cops...")
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x)
            (set! incorrect-password-attempts
                  (+ incorrect-password-attempts 1))
            (if (> incorrect-password-attempts 7)
                (call-the-cops)
                "Incorrect password"))
          (begin
            (set! incorrect-password-attempts 0)
            (cond ((eq? m 'withdraw) withdraw)
                  ((eq? m 'deposit) deposit)
                  (else (error "Unknown request -- MAKE-ACCOUNT"
                               m))))))
    dispatch)
#+END_SRC

#+NAME: test-3-4
#+BEGIN_SRC scheme
  (define acc (make-account 100 'secret-password))
  (for-each (lambda (i)
              (test "Incorrect password"
                    ((acc 'some-other-password 'withdraw) 100)))
            (iota 7))
  (test "Please wait -- calling the cops..."
        ((acc 'some-other-password 'withdraw) 100))
#+END_SRC

*** 3.1.2: The Benefits of Introducing Assignment

**** Exercise 3.5.

/Monte Carlo integration/ is a method of estimating definite integrals by means
of Monte Carlo simulation. Consider computing the area of a region of space
described by a predicate \(P(x, y)\) that is true for points \((x, y)\) in the
region and false for points not in the region. For example, the region
contained within a circle of radius \(3\) centered at \((5, 7)\) is described
by the predicate that tests whether \((x - 5)^2 + (y - 7)^2 < 32\). To estimate
the area of the region described by such a predicate, begin by choosing a
rectangle that contains the region. For example, a rectangle with diagonally
opposite corners at \((2, 4)\) and \((8, 10)\) contains the circle above. The
desired integral is the area of that portion of the rectangle that lies in the
region. We can estimate the integral by picking, at random, points \((x,y)\)
that lie in the rectangle, and testing \(P(x, y)\) for each point to determine
whether the point lies in the region. If we try this with many points, then the
fraction of points that fall in the region should give an estimate of the
proportion of the rectangle that lies in the region. Hence, multiplying this
fraction by the area of the entire rectangle should produce an estimate of the
integral.

Implement Monte Carlo integration as a procedure ~estimate-integral~ that takes
as arguments a predicate ~P~, upper and lower bounds ~x1~, ~x2~, ~y1~, and ~y2~
for the rectangle, and the number of trials to perform in order to produce the
estimate. Your procedure should use the same ~monte-carlo~ procedure that was
used above to estimate \(\pi\). Use your ~estimate-integral~ to produce an
estimate of by measuring the area of a unit circle.

You will find it useful to have a procedure that returns a number chosen at
random from a given range. The following ~random-in-range~ procedure implements
this in terms of the ~random~ procedure used in section 1.2.6, which returns a
nonnegative number less than its input.

#+BEGIN_SRC scheme
  (use random-bsd)
  (define (random-in-range low high)
    (let ((range (- high low)))
      (+ low (* range (random-real)))))
#+END_SRC

***** Solution

#+BEGIN_SRC scheme
  (define (estimate-integral P x1 x2 y1 y2 ntrial)
    ;; Number of trials for which the trial point was inside the region to be
    ;; integrated (i.e., where (= (P x y) #t)).
    (define ninside 0)
    (define (random-x)
      (random-in-range x1 x2))
    (define (random-y)
      (random-in-range y1 y2))
    (define (try x y)
      (if (P x y)
          (set! ninside (+ ninside 1))))
    (for-each (lambda (i)
                (try (random-x) (random-y)))
              (iota ntrial))
    (* (- x2 x1)
       (- y2 y1)
       (/ ninside ntrial)))
#+END_SRC

#+NAME: test-3-5
#+BEGIN_SRC scheme
  (define (p-circle)
    (lambda (x y)
      (> (* 1.0 1.0)
         (+ (* x x)
            (* y y)))))
  (current-test-epsilon 0.10)
  (define pi (* 4 (atan 1 1)))
  (test pi
        (estimate-integral (p-circle) -2.0 2.0 -2.0 2.0 100000))
#+END_SRC

**** Exercise 3.6.

It is useful to be able to reset a random-number generator to produce a
sequence starting from a given value. Design a new ~rand~ procedure that is
called with an argument that is either the symbol ~generate~ or the symbol
~reset~ and behaves as follows: ~(rand 'generate)~ produces a new random
number; ~((rand 'reset) <new-value>)~ resets the internal state variable to the
designated ~<new-value>~. Thus, by resetting the state, one can generate
repeatable sequences. These are very handy to have when testing and debugging
programs that use random numbers.

***** Solution

This is a fairly simple modification of the ~rand~ command defined in the
book. The main change is to dispatch on a ~command~ argument to ~rand~. Also,
since the ~reset~ argument sets the seed of the random number generator, I
don't define a ~random-init~ variable here. Thus, it is necessary to make at
least one call to ~(rand 'reset)~ before using ~(rand 'generate)~ to make sure
the seed is initialized.

#+BEGIN_SRC scheme
  (define (rand command)
    (define x nil)                        ; Don't produce random numbers until initialized
    (cond ((equal? command 'generate)
           (set! x (rand-update x))
           x)
          ((equal? command 'reset)
           (lambda (x-init)
             (set! x x-init)))
          (else
           (error "RAND -- bad command")
           command)))
#+END_SRC

*** 3.1.3: The Costs of Introducing Assignment

**** Exercise 3.7.

Consider the bank account objects created by ~make-account~, with the password
modification described in exercise 3.3. Suppose that our banking system
requires the ability to make joint accounts. Define a procedure ~make-joint~
that accomplishes this. ~make-joint~ should take three arguments. The first is
a password-protected account. The second argument must match the password with
which the account was defined in order for the ~make-joint~ operation to
proceed. The third argument is a new password. ~make-joint~ is to create an
additional access to the original account using the new password. For example,
if ~peter-acc~ is a bank account with password ~open-sesame~, then

#+BEGIN_SRC scheme
  (define paul-acc
    (make-joint peter-acc 'open-sesame 'rosebud))
#+END_SRC

will allow one to make transactions on ~peter-acc~ using the name ~paul-acc~
and the password ~rosebud~. You may wish to modify your solution to exercise
3.3 to accommodate this new feature.

***** Solution

#+BEGIN_SRC scheme

#+END_SRC
