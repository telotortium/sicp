#+TITLE: Structure and Interpretation of Computer Programs (SICP)
#+AUTHOR: Robert Irelan
#+EMAIL: rirelan@gmail.com
#+OPTIONS: author:t email:t f:t
#+PROPERTY: header-args :comments link :noweb no-export
#+PROPERTY: header-args:scheme :shebang #!/usr/bin/env chicken-scheme

* Chapter 3: Modularity, Objects, and State

** 3.1: Assignment and Local State

*** 3.1.1: Local State Variables

**** Exercise 3.1.

An /accumulator/ is a procedure that is called repeatedly with a single numeric
argument and accumulates its arguments into a sum. Each time it is called, it
returns the currently accumulated sum. Write a procedure ~make-accumulator~ that
generates accumulators, each maintaining an independent sum. The input to
~make-accumulator~ should specify the initial value of the sum; for example

#+BEGIN_SRC scheme
  (define A (make-accumulator 5))
  (A 10)
  15
  (A 10)
  25
#+END_SRC

***** Solution

#+BEGIN_SRC scheme
  (define (make-accumulator initial)
    (lambda (increment)
      (set! initial (+ initial increment))
      initial))
#+END_SRC

#+NAME: test-3-1
#+BEGIN_SRC scheme
  (define A (make-accumulator 5))
  (test 15
        (A 10))
  (test 25
        (A 10))
#+END_SRC

**** Exercise 3.2.

In software-testing applications, it is useful to be able to count the number
of times a given procedure is called during the course of a computation. Write
a procedure ~make-monitored~ that takes as input a procedure, ~f~, that itself
takes one input. The result returned by ~make-monitored~ is a third procedure,
say ~mf~, that keeps track of the number of times it has been called by
maintaining an internal counter. If the input to ~mf~ is the special symbol
~how-many-calls?~, then ~mf~ returns the value of the counter. If the input is
the special symbol ~reset-count~, then ~mf~ resets the counter to zero. For any
other input, ~mf~ returns the result of calling ~f~ on that input and
increments the counter. For instance, we could make a monitored version of the
~sqrt~ procedure:

#+BEGIN_SRC scheme
(define s (make-monitored sqrt))

(s 100)
10

(s 'how-many-calls?)
1
#+END_SRC

***** Solution

#+BEGIN_SRC scheme
  (define (make-monitored f)
    (define counter 0)
    (lambda (x)
      (cond ((equal? x 'how-many-calls?)
             counter)
            ((equal? x 'reset-count)
             (set! counter 0))
            (else
             (f x)
             (set! counter (+ counter 1))))))
#+END_SRC

#+NAME: test-3-2
#+BEGIN_SRC scheme
  (define s (make-monitored sqrt))
  (test 10
        (s 100))
  (test 1
        (s 'how-many-calls?))
#+END_SRC

*** Exercise 3.3.

Modify the ~make-account~ procedure so that it creates password-protected
accounts. That is, ~make-account~ should take a symbol as an additional
argument, as in

#+BEGIN_SRC scheme
  (define acc (make-account 100 'secret-password))
#+END_SRC

The resulting account object should process a request only if it is accompanied
by the password with which the account was created, and should otherwise return
a complaint:

#+BEGIN_SRC scheme
  ((acc 'secret-password 'withdraw) 40)
  60

  ((acc 'some-other-password 'deposit) 50)
  "Incorrect password"
#+END_SRC

***** Solution

#+BEGIN_SRC scheme
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x) "Incorrect password")
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request -- MAKE-ACCOUNT"
                             m)))))
    dispatch)
#+END_SRC

#+NAME: test-3-3
#+BEGIN_SRC scheme
  (define acc (make-account 100 'secret-password))
  (test 60
        ((acc 'secret-password 'withdraw) 40))
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
#+END_SRC

**** Exercise 3.4.

Modify the ~make-account~ procedure of exercise 3.3 by adding another local
state variable so that, if an account is accessed more than seven consecutive
times with an incorrect password, it invokes the procedure ~call-the-cops~.

***** Solution

As the prompt states, there's little more work involved than to add
a ~incorrect-password-attempts~, which we use to ~call-the-cops~ when too many
incorrect attempts in a row have been made. Ideally, a different response
would not be returned to the user when the cops have been called, but I've
decided to do so for ease of testing.

#+BEGIN_SRC scheme
  (define (make-account balance password)
    (define incorrect-password-attempts 0)
    (define (call-the-cops)
      "Please wait -- calling the cops...")
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x)
            (set! incorrect-password-attempts
                  (+ incorrect-password-attempts 1))
            (if (> incorrect-password-attempts 7)
                (call-the-cops)
                "Incorrect password"))
          (begin
            (set! incorrect-password-attempts 0)
            (cond ((eq? m 'withdraw) withdraw)
                  ((eq? m 'deposit) deposit)
                  (else (error "Unknown request -- MAKE-ACCOUNT"
                               m))))))
    dispatch)
#+END_SRC

#+NAME: test-3-4
#+BEGIN_SRC scheme
  (define acc (make-account 100 'secret-password))
  (for-each (lambda (i)
              (test "Incorrect password"
                    ((acc 'some-other-password 'withdraw) 100)))
            (iota 7))
  (test "Please wait -- calling the cops..."
        ((acc 'some-other-password 'withdraw) 100))
#+END_SRC

*** 3.1.2: The Benefits of Introducing Assignment

**** Exercise 3.5.

/Monte Carlo integration/ is a method of estimating definite integrals by means
of Monte Carlo simulation. Consider computing the area of a region of space
described by a predicate \(P(x, y)\) that is true for points \((x, y)\) in the
region and false for points not in the region. For example, the region
contained within a circle of radius \(3\) centered at \((5, 7)\) is described
by the predicate that tests whether \((x - 5)^2 + (y - 7)^2 < 32\). To estimate
the area of the region described by such a predicate, begin by choosing a
rectangle that contains the region. For example, a rectangle with diagonally
opposite corners at \((2, 4)\) and \((8, 10)\) contains the circle above. The
desired integral is the area of that portion of the rectangle that lies in the
region. We can estimate the integral by picking, at random, points \((x,y)\)
that lie in the rectangle, and testing \(P(x, y)\) for each point to determine
whether the point lies in the region. If we try this with many points, then the
fraction of points that fall in the region should give an estimate of the
proportion of the rectangle that lies in the region. Hence, multiplying this
fraction by the area of the entire rectangle should produce an estimate of the
integral.

Implement Monte Carlo integration as a procedure ~estimate-integral~ that takes
as arguments a predicate ~P~, upper and lower bounds ~x1~, ~x2~, ~y1~, and ~y2~
for the rectangle, and the number of trials to perform in order to produce the
estimate. Your procedure should use the same ~monte-carlo~ procedure that was
used above to estimate \(\pi\). Use your ~estimate-integral~ to produce an
estimate of by measuring the area of a unit circle.

You will find it useful to have a procedure that returns a number chosen at
random from a given range. The following ~random-in-range~ procedure implements
this in terms of the ~random~ procedure used in section 1.2.6, which returns a
nonnegative number less than its input.

#+BEGIN_SRC scheme
  (use random-bsd)
  (define (random-in-range low high)
    (let ((range (- high low)))
      (+ low (* range (random-real)))))
#+END_SRC

***** Solution

#+BEGIN_SRC scheme
  (define (estimate-integral P x1 x2 y1 y2 ntrial)
    ;; Number of trials for which the trial point was inside the region to be
    ;; integrated (i.e., where (= (P x y) #t)).
    (define ninside 0)
    (define (random-x)
      (random-in-range x1 x2))
    (define (random-y)
      (random-in-range y1 y2))
    (define (try x y)
      (if (P x y)
          (set! ninside (+ ninside 1))))
    (for-each (lambda (i)
                (try (random-x) (random-y)))
              (iota ntrial))
    (* (- x2 x1)
       (- y2 y1)
       (/ ninside ntrial)))
#+END_SRC

#+NAME: test-3-5
#+BEGIN_SRC scheme
  (define (p-circle)
    (lambda (x y)
      (> (* 1.0 1.0)
         (+ (* x x)
            (* y y)))))
  (current-test-epsilon 0.10)
  (define pi (* 4 (atan 1 1)))
  (test pi
        (estimate-integral (p-circle) -2.0 2.0 -2.0 2.0 100000))
#+END_SRC

**** Exercise 3.6.

It is useful to be able to reset a random-number generator to produce a
sequence starting from a given value. Design a new ~rand~ procedure that is
called with an argument that is either the symbol ~generate~ or the symbol
~reset~ and behaves as follows: ~(rand 'generate)~ produces a new random
number; ~((rand 'reset) <new-value>)~ resets the internal state variable to the
designated ~<new-value>~. Thus, by resetting the state, one can generate
repeatable sequences. These are very handy to have when testing and debugging
programs that use random numbers.

***** Solution

This is a fairly simple modification of the ~rand~ command defined in the
book. The main change is to dispatch on a ~command~ argument to ~rand~. Also,
since the ~reset~ argument sets the seed of the random number generator, I
don't define a ~random-init~ variable here. Thus, it is necessary to make at
least one call to ~(rand 'reset)~ before using ~(rand 'generate)~ to make sure
the seed is initialized.

#+BEGIN_SRC scheme
  (define (rand command)
    (define x nil)                        ; Don't produce random numbers until initialized
    (cond ((equal? command 'generate)
           (set! x (rand-update x))
           x)
          ((equal? command 'reset)
           (lambda (x-init)
             (set! x x-init)))
          (else
           (error "RAND -- bad command")
           command)))
#+END_SRC

*** 3.1.3: The Costs of Introducing Assignment

**** Exercise 3.7.

Consider the bank account objects created by ~make-account~, with the password
modification described in exercise 3.3. Suppose that our banking system
requires the ability to make joint accounts. Define a procedure ~make-joint~
that accomplishes this. ~make-joint~ should take three arguments. The first is
a password-protected account. The second argument must match the password with
which the account was defined in order for the ~make-joint~ operation to
proceed. The third argument is a new password. ~make-joint~ is to create an
additional access to the original account using the new password. For example,
if ~peter-acc~ is a bank account with password ~open-sesame~, then

#+BEGIN_SRC scheme
  (define paul-acc
    (make-joint peter-acc 'open-sesame 'rosebud))
#+END_SRC

will allow one to make transactions on ~peter-acc~ using the name ~paul-acc~
and the password ~rosebud~. You may wish to modify your solution to exercise
3.3 to accommodate this new feature.

***** Solution

#+BEGIN_SRC scheme

#+END_SRC


** 3.2: The Environment Model of Evaluation

*** 3.2.1: The Rules for Evaluation

No exercises

*** 3.2.2: Applying Simple Procedures
**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.9][Exercise 3.9.]]

I don't want to draw, so I'll use Scheme S-expressions instead.

In general, each invocation of a procedure creates an environment containing a
reference to its enclosing environment and a list of references to its
parameters. The global environment is much the same except that has a nil
pointer for the enclosing environment since there is no enclosing
environment. In the below, I've represented each parameter as a list of the
symbol name and value, but the symbol name is only preserved here for ease of
following the examples -- it doesn't necessarily have to be kept in an actual
interpreter.

The recursive definition of ~factorial~,

#+BEGIN_SRC scheme
  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))
#+END_SRC

spawns a separate environment for each call of ~factorial~, each of which has a
reference to the global environment and the value of its one argument:

#+BEGIN_SRC scheme
  (define global-env `(() (factorial ,factorial-proc)
                          (fact-iter ,fact-iter-proc)
                          ,@intrinsic-defs))
  (define all-envs `((,global-env (n ,6))))
  (set! ,all-envs `((,global-env (n ,5)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,4)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,3)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,2)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,1)) ,all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (assert (null? all-envs))

#+END_SRC

In contrast, the iterative version,

#+BEGIN_SRC scheme
  (define (factorial n)
    (fact-iter 1 1 n))
  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
#+END_SRC

because it is tail recursive, replaces the environment of the function from
which a tail recursive call is made with the environment for the target
function of the tail recursive call. Since all function calls in both
~factorial~ and ~fact-iter~ are tail recursive, the list of environments
changes basically as described in the pseudocode below:

#+BEGIN_SRC scheme
  (define global-env `(() (factorial ,factorial-proc)
                       (fact-iter ,fact-iter-proc)
                       ,@intrinsic-defs))
  (define all-envs `((global-env (n ,6))))
  (set-car! all-envs `(global-env (product ,1)
                                  (counter ,1)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,1)
                                  (counter ,2)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,2)
                                  (counter ,3)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,6)
                                  (counter ,4)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,24)
                                  (counter ,5)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,120)
                                  (counter ,6)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,720)
                                  (counter ,7)
                                  (max-count ,6)))
  (set! all-envs (cdr all-envs))
  (assert (null? all-envs))
#+END_SRC

Notice above that we've really simulated a stack, with ~set-car!~ performing a
mutation-in-place of the top entry of the stack.

*** 3.2.3: Frames as the Repository of Local State
**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.10][Exercise 3.10.]]

The procedure to be analyzed,

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    (let ((balance initial-amount))
      (lambda (amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))))
#+END_SRC

expands to the following when ~let~ is expanded to its underlying syntax:

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    ((lambda (balance)
       (lambda (amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds")))
     initial-amount))
#+END_SRC

Without TCE, the function returned by ~make-withdraw~ (i.e.,
~(lambda (amount) ⋯)~), has a pointer the environment of
~(lambda (balance) ⋯)~, which has a pointer to the global environment. However,
the call to ~(lambda (balance) ⋯)~ is in tail position, so it replaces the
environment formed by the call of ~make-withdraw~. When the returned
~(lambda (amount) ⋯)~ is called, it therefore has a pointer to the environment
of ~(lambda (balance) ⋯)~, which points to the global environment.

*** 3.2.4: Internal Definitions
**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.11][Exercise 3.11.]]

The environment for ~make-account~ points to the global environment. In this
environment exist references to the argument ~balance~ as well as the local
procedures ~withdraw~, ~deposit~, and ~dispatch~. Each local procedure points to
the environment of ~make-account~ (and retains references to its own arguments
as well). It's necessary to keep references to the local procedures in the
environment of ~make-account~ so that ~dispatch~ can resolve the references to
~withdraw~ and ~deposit~ in its body. (On the other hand, it should not
strictly be necessary to retain a reference to ~dispatch~ since a reference to
that procedure is returned.)


** 3.3: Modeling with Mutable Data

*** 3.3.1: Applying Simple Procedures
**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.12][Exercise 3.12.]]

#+BEGIN_SRC scheme :tangle ex-3-12-test.scm
  (use test)

  ;;; Nondestructive
  (define x (list 'a 'b))
  (define y (list 'c 'd))
  (define z (append x y))

  (test z
        '(a b c d))
  (test (cdr x)
        '(b))

  ;;; Destructive
  (define w (append! x y))

  (test w
        '(a b c d))
  (test (cdr w)
        '(b c d))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.13][Exercise 3.13.]]

When a circular list is constructed from a linear list, the last cons cell in
the original list has its cdr set to the head of the original list. Thus,
~(null? (cdr x))~ never returns true for any element ~x~ in the list and the
~last-pair~ procedure loops around the list forever.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.14][Exercise 3.14.]]

~mystery~ reverses a list destructively:

#+NAME: ex-3-14
#+BEGIN_SRC scheme
  (define (mystery x)
    (define (loop x y)
      (if (null? x)
          y
          (let ((temp (cdr x)))
            (set-cdr! x y)
            (loop temp x))))
    (loop x '()))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-14-test.scm
  (use test)
  <<ex-3-14>>
  (define v '(a b c d))
  (define w (mystery v))
  (test w
        '(d c b a))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.15][Exercise 3.15.]]

In Figure 3.16, modify the diagram so that the arrow pointing to the ~'a~ cell
now points to a ~'wow~ cell.

In Figure 3.17, only the arrow pointing to ~'a~ from below now points to ~'wow~
-- the arrow from above continues to point to ~'a~.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.16][Exercise 3.16.]]

Ben Bitdiddle's flawed procedure:

#+NAME: ex-3-16-count-pairs
#+BEGIN_SRC scheme
  (define (count-pairs x)
    (if (not (pair? x))
        0
        (+ (count-pairs (car x))
           (count-pairs (cdr x))
           1)))
#+END_SRC

We define some test data here, containing a simple list, some more complex
linked structures, and a list containing a cycle, for this and the rest of the
exercises in this section.

#+BEGIN_SRC scheme :tangle sharing-identity-test-data.scm
  (define pairs-3 '(a b c))
  (define pairs-4
    (begin
      (define x '(a b c))
      (set-car! x (cddr x))
      x))
  (define pairs-7
    (begin
      (define x '(a b c))
      (set-car! x (cdr x))
      (set-car! (cdr x) (cddr x))
      x))
  (define pairs-cycle
    (begin
      (define x '(a b c))
      (set-cdr! (cddr x) x)
      x))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-16-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (test 0
        (count-pairs '()))
  (test 0
        (count-pairs 'a))
  (test 3
        (count-pairs pairs-3))
  (test 4
        (count-pairs pairs-4))
  (test 7
        (count-pairs pairs-7))
  ;;; No test for pairs-cycle, because a cycle causes this version of count-pairs
  ;;; to run forever.
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.17][Exercise 3.17.]]

#+BEGIN_SRC scheme :tangle ex-3-17-count-pairs.scm
  (define (count-pairs x)
    (let ((seens '()))
      (let inner ((x x))
        (if (or (not (pair? x))
                (memq x seens))
            0
            (begin
              (set! seens (cons x seens))
              (+ (inner (car x))
                 (inner (cdr x))
                 1))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-17-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-17-count-pairs")
  (test 0
        (count-pairs '()))
  (test 0
        (count-pairs 'a))
  (test 3
        (count-pairs pairs-3))
  (test 4
        (count-pairs pairs-4))
  (test 7
        (count-pairs pairs-7))
  (test 3
        (count-pairs pairs-cycle))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.18][Exercise 3.18.]]

#+BEGIN_SRC scheme :tangle ex-3-18.scm
  (define (cycle? x)
    (let ((seens '()))
      (let inner ((x x))
        (cond ((not (pair? x)) #f)
              ((memq x seens) #t)
              (else (set! seens (cons x seens))
                    (inner (cdr x)))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-18-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-18")
  (test #f
        (cycle? '()))
  (test #f
        (cycle? 'a))
  (test #f
        (cycle? pairs-3))
  (test #f
        (cycle? pairs-4))
  (test #f
        (cycle? pairs-7))
  (test #t
        (cycle? pairs-cycle))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.19][Exercise 3.19.]]

Use [[http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare][Floyd's cycle-finding algorithm]], also known as the "tortoise-and-hare"
algorithm. Two pointers to the list elements are kept. The "tortoise" is
advanced by 1 position for every call, while the "hare" is advanced by 2
positions. If a cycle exists, the tortoise and hare will eventually run into
other (i.e., compare equal via ~eq?~ after the initial call).

#+BEGIN_SRC scheme :tangle ex-3-19.scm
  (define (cycle? x)
    (define (cdr-safe x)
      (if (not (pair? x))
          x
          (cdr x)))
    (define (cddr-safe x)
      (if (not (pair? x))
          x
          (cdr-safe (cdr x))))
    (define (inner tortoise hare first-run)
      (cond ((any (lambda (p) (not (pair? p)))
                  (list tortoise hare))
             #f)
            ((and (not first-run)
                  (eq? tortoise hare))
             #t)
            (else (inner (cdr-safe tortoise)
                         (cddr-safe hare)
                         #f))))
    (inner x x #t))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-19-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-19")
  (test #f
        (cycle? '()))
  (test #f
        (cycle? 'a))
  (test #f
        (cycle? pairs-3))
  (test #f
        (cycle? pairs-4))
  (test #f
        (cycle? pairs-7))
  (test #t
        (cycle? pairs-cycle))
#+END_SRC
