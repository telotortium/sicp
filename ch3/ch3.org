#+TITLE: Structure and Interpretation of Computer Programs (SICP)
#+AUTHOR: Robert Irelan
#+EMAIL: rirelan@gmail.com
#+OPTIONS: author:t email:t f:t
#+PROPERTY: header-args :comments link :noweb no-export
#+PROPERTY: header-args:scheme :shebang #!/usr/bin/env chicken-scheme

* Chapter 3: Modularity, Objects, and State

** 3.1: Assignment and Local State

*** 3.1.1: Local State Variables

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.1][Exercise 3.1.]]

#+BEGIN_SRC scheme :tangle ex-3-1.scm
  (define (make-accumulator initial)
    (lambda (increment)
      (set! initial (+ initial increment))
      initial))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-1-test.scm
  (use test)
  (include "ex-3-1")
  (define A (make-accumulator 5))
  (test 15
        (A 10))
  (test 25
        (A 10))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.2][Exercise 3.2.]]

#+BEGIN_SRC scheme :tangle ex-3-2.scm
  (define (make-monitored f)
    (define counter 0)
    (lambda (x)
      (cond ((equal? x 'how-many-calls?)
             counter)
            ((equal? x 'reset-count)
             (set! counter 0))
            (else
             (f x)
             (set! counter (+ counter 1))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-2-test.scm
  (use test)
  (include "ex-3-2")
  (define s (make-monitored sqrt))
  (test 10
        (s 100))
  (test 1
        (s 'how-many-calls?))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.3][Exercise 3.3.]]

#+BEGIN_SRC scheme :tangle ex-3-3.scm
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x) "Incorrect password")
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request -- MAKE-ACCOUNT"
                             m)))))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-3-test.scm
  (use test)
  (include "ex-3-3")
  (define acc (make-account 100 'secret-password))
  (test 60
        ((acc 'secret-password 'withdraw) 40))
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.4][Exercise 3.4.]]

As the prompt states, there's little more work involved than to add
a ~incorrect-password-attempts~, which we use to ~call-the-cops~ when too many
incorrect attempts in a row have been made. Ideally, a different response
would not be returned to the user when the cops have been called, but I've
decided to do so for ease of testing.

#+BEGIN_SRC scheme :tangle ex-3-4.scm
  (define (make-account balance password)
    (define incorrect-password-attempts 0)
    (define (call-the-cops)
      "Please wait -- calling the cops...")
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x)
            (set! incorrect-password-attempts
                  (+ incorrect-password-attempts 1))
            (if (> incorrect-password-attempts 7)
                (call-the-cops)
                "Incorrect password"))
          (begin
            (set! incorrect-password-attempts 0)
            (cond ((eq? m 'withdraw) withdraw)
                  ((eq? m 'deposit) deposit)
                  (else (error "Unknown request -- MAKE-ACCOUNT"
                               m))))))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-4-test.scm
  (use test)
  (include "ex-3-4")
  (define acc (make-account 100 'secret-password))
  (for-each (lambda (i)
              (test "Incorrect password"
                    ((acc 'some-other-password 'withdraw) 100)))
            (iota 7))
  (test "Please wait -- calling the cops..."
        ((acc 'some-other-password 'withdraw) 100))
#+END_SRC

*** 3.1.2: The Benefits of Introducing Assignment

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.5][Exercise 3.5.]]

#+BEGIN_SRC scheme :tangle ex-3-5.scm
  (define (estimate-integral P x1 x2 y1 y2 ntrial)
    ;; Number of trials for which the trial point was inside the region to be
    ;; integrated (i.e., where (= (P x y) #t)).
    (define ninside 0)
    (define (random-x)
      (random-in-range x1 x2))
    (define (random-y)
      (random-in-range y1 y2))
    (define (try x y)
      (if (P x y)
          (set! ninside (+ ninside 1))))
    (for-each (lambda (i)
                (try (random-x) (random-y)))
              (iota ntrial))
    (* (- x2 x1)
       (- y2 y1)
       (/ ninside ntrial)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-5-test.scm
  (use test)
  (include "ex-3-5")
  (define (p-circle)
    (lambda (x y)
      (> (* 1.0 1.0)
         (+ (* x x)
            (* y y)))))
  (current-test-epsilon 0.10)
  (define pi (* 4 (atan 1 1)))
  (parameterize ((current-test-epsilon 0.10))
                (test pi
                      (estimate-integral (p-circle) -2.0 2.0 -2.0 2.0 100000)))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.6][Exercise 3.6.]]

This is a fairly simple modification of the ~rand~ command defined in the
book. The main change is to dispatch on a ~command~ argument to ~rand~. Also,
since the ~reset~ argument sets the seed of the random number generator, I
don't define a ~random-init~ variable here. Thus, it is necessary to make at
least one call to ~(rand 'reset)~ before using ~(rand 'generate)~ to make sure
the seed is initialized.

#+BEGIN_SRC scheme :tangle ex-3-6.scm
  (define (rand command)
    (define x nil)                        ; Don't produce random numbers until initialized
    (cond ((equal? command 'generate)
           (set! x (rand-update x))
           x)
          ((equal? command 'reset)
           (lambda (x-init)
             (set! x x-init)))
          (else
           (error "RAND -- bad command")
           command)))
#+END_SRC

*** 3.1.3: The Costs of Introducing Assignment

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.7][Exercise 3.7.]]

#+BEGIN_SRC scheme :tangle ex-3-7.scm
  (include "ex-3-3")
  (define (make-joint account original-password new-password)
    (define (dispatch p m)
      ;; The underlying account accepts only original-password, so accept
      ;; new-password by passing original-password. Otherwise, let the underlying
      ;; account deal with error handling for a wrong password.
      (display p) (newline)
      (if (equal? p new-password)
          (account original-password m)
          (account p m)))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-7-test.scm
  (use test)
  (include "ex-3-7")
  (define acc (make-account 140 'secret-password))
  (define joint-acc
    (make-joint acc 'secret-password 'proxy-password))
  ;;; Both `acc` and `joint-acc` accept the original password, and actions on
  ;;; either affect the other since `joint-acc` delegates all messages to `acc`.
  (test 100
        ((joint-acc 'secret-password 'withdraw) 40))
  (test 60
        ((joint-acc 'secret-password 'withdraw) 40))
  ;;; Neither account works with an unknown password.
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
  (test "Incorrect password"
        ((joint-acc 'some-other-password 'deposit) 50))
  ;;; Original account `acc` doesn't work with the proxy password, but the joint
  ;;; account `joint-acc` does.
  (test "Incorrect password"
        ((acc 'proxy-password 'withdraw) 20))
  (test 40
        ((joint-acc 'proxy-password 'withdraw) 20))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.8][Exercise 3.8.]]

** 3.2: The Environment Model of Evaluation

*** 3.2.1: The Rules for Evaluation

No exercises

*** 3.2.2: Applying Simple Procedures
**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.9][Exercise 3.9.]]

I don't want to draw, so I'll use Scheme S-expressions instead.

In general, each invocation of a procedure creates an environment containing a
reference to its enclosing environment and a list of references to its
parameters. The global environment is much the same except that has a nil
pointer for the enclosing environment since there is no enclosing
environment. In the below, I've represented each parameter as a list of the
symbol name and value, but the symbol name is only preserved here for ease of
following the examples -- it doesn't necessarily have to be kept in an actual
interpreter.

The recursive definition of ~factorial~,

#+BEGIN_SRC scheme
  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))
#+END_SRC

spawns a separate environment for each call of ~factorial~, each of which has a
reference to the global environment and the value of its one argument:

#+BEGIN_SRC scheme
  (define global-env `(() (factorial ,factorial-proc)
                          (fact-iter ,fact-iter-proc)
                          ,@intrinsic-defs))
  (define all-envs `((,global-env (n ,6))))
  (set! ,all-envs `((,global-env (n ,5)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,4)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,3)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,2)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,1)) ,all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (assert (null? all-envs))

#+END_SRC

In contrast, the iterative version,

#+BEGIN_SRC scheme
  (define (factorial n)
    (fact-iter 1 1 n))
  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
#+END_SRC

because it is tail recursive, replaces the environment of the function from
which a tail recursive call is made with the environment for the target
function of the tail recursive call. Since all function calls in both
~factorial~ and ~fact-iter~ are tail recursive, the list of environments
changes basically as described in the pseudocode below:

#+BEGIN_SRC scheme
  (define global-env `(() (factorial ,factorial-proc)
                       (fact-iter ,fact-iter-proc)
                       ,@intrinsic-defs))
  (define all-envs `((global-env (n ,6))))
  (set-car! all-envs `(global-env (product ,1)
                                  (counter ,1)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,1)
                                  (counter ,2)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,2)
                                  (counter ,3)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,6)
                                  (counter ,4)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,24)
                                  (counter ,5)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,120)
                                  (counter ,6)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,720)
                                  (counter ,7)
                                  (max-count ,6)))
  (set! all-envs (cdr all-envs))
  (assert (null? all-envs))
#+END_SRC

Notice above that we've really simulated a stack, with ~set-car!~ performing a
mutation-in-place of the top entry of the stack.

*** 3.2.3: Frames as the Repository of Local State
**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.10][Exercise 3.10.]]

The procedure to be analyzed,

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    (let ((balance initial-amount))
      (lambda (amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))))
#+END_SRC

expands to the following when ~let~ is expanded to its underlying syntax:

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    ((lambda (balance)
       (lambda (amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds")))
     initial-amount))
#+END_SRC

Without TCE, the function returned by ~make-withdraw~ (i.e.,
~(lambda (amount) ⋯)~), has a pointer the environment of
~(lambda (balance) ⋯)~, which has a pointer to the global environment. However,
the call to ~(lambda (balance) ⋯)~ is in tail position, so it replaces the
environment formed by the call of ~make-withdraw~. When the returned
~(lambda (amount) ⋯)~ is called, it therefore has a pointer to the environment
of ~(lambda (balance) ⋯)~, which points to the global environment.

*** 3.2.4: Internal Definitions
**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.11][Exercise 3.11.]]

The environment for ~make-account~ points to the global environment. In this
environment exist references to the argument ~balance~ as well as the local
procedures ~withdraw~, ~deposit~, and ~dispatch~. Each local procedure points to
the environment of ~make-account~ (and retains references to its own arguments
as well). It's necessary to keep references to the local procedures in the
environment of ~make-account~ so that ~dispatch~ can resolve the references to
~withdraw~ and ~deposit~ in its body. (On the other hand, it should not
strictly be necessary to retain a reference to ~dispatch~ since a reference to
that procedure is returned.)


** 3.3: Modeling with Mutable Data

*** 3.3.1: Applying Simple Procedures
**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.12][Exercise 3.12.]]

#+BEGIN_SRC scheme :tangle ex-3-12-test.scm
  (use test)

  ;;; Nondestructive
  (define x (list 'a 'b))
  (define y (list 'c 'd))
  (define z (append x y))

  (test z
        '(a b c d))
  (test (cdr x)
        '(b))

  ;;; Destructive
  (define w (append! x y))

  (test w
        '(a b c d))
  (test (cdr w)
        '(b c d))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.13][Exercise 3.13.]]

When a circular list is constructed from a linear list, the last cons cell in
the original list has its cdr set to the head of the original list. Thus,
~(null? (cdr x))~ never returns true for any element ~x~ in the list and the
~last-pair~ procedure loops around the list forever.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.14][Exercise 3.14.]]

~mystery~ reverses a list destructively:

#+NAME: ex-3-14
#+BEGIN_SRC scheme
  (define (mystery x)
    (define (loop x y)
      (if (null? x)
          y
          (let ((temp (cdr x)))
            (set-cdr! x y)
            (loop temp x))))
    (loop x '()))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-14-test.scm
  (use test)
  <<ex-3-14>>
  (define v '(a b c d))
  (define w (mystery v))
  (test w
        '(d c b a))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.15][Exercise 3.15.]]

In Figure 3.16, modify the diagram so that the arrow pointing to the ~'a~ cell
now points to a ~'wow~ cell.

In Figure 3.17, only the arrow pointing to ~'a~ from below now points to ~'wow~
-- the arrow from above continues to point to ~'a~.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.16][Exercise 3.16.]]

Ben Bitdiddle's flawed procedure:

#+NAME: ex-3-16-count-pairs
#+BEGIN_SRC scheme
  (define (count-pairs x)
    (if (not (pair? x))
        0
        (+ (count-pairs (car x))
           (count-pairs (cdr x))
           1)))
#+END_SRC

We define some test data here, containing a simple list, some more complex
linked structures, and a list containing a cycle, for this and the rest of the
exercises in this section.

#+BEGIN_SRC scheme :tangle sharing-identity-test-data.scm
  (define pairs-3 '(a b c))
  (define pairs-4
    (begin
      (define x '(a b c))
      (set-car! x (cddr x))
      x))
  (define pairs-7
    (begin
      (define x '(a b c))
      (set-car! x (cdr x))
      (set-car! (cdr x) (cddr x))
      x))
  (define pairs-cycle
    (begin
      (define x '(a b c))
      (set-cdr! (cddr x) x)
      x))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-16-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (test 0
        (count-pairs '()))
  (test 0
        (count-pairs 'a))
  (test 3
        (count-pairs pairs-3))
  (test 4
        (count-pairs pairs-4))
  (test 7
        (count-pairs pairs-7))
  ;;; No test for pairs-cycle, because a cycle causes this version of count-pairs
  ;;; to run forever.
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.17][Exercise 3.17.]]

#+BEGIN_SRC scheme :tangle ex-3-17-count-pairs.scm
  (define (count-pairs x)
    (let ((seens '()))
      (let inner ((x x))
        (if (or (not (pair? x))
                (memq x seens))
            0
            (begin
              (set! seens (cons x seens))
              (+ (inner (car x))
                 (inner (cdr x))
                 1))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-17-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-17-count-pairs")
  (test 0
        (count-pairs '()))
  (test 0
        (count-pairs 'a))
  (test 3
        (count-pairs pairs-3))
  (test 4
        (count-pairs pairs-4))
  (test 7
        (count-pairs pairs-7))
  (test 3
        (count-pairs pairs-cycle))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.18][Exercise 3.18.]]

#+BEGIN_SRC scheme :tangle ex-3-18.scm
  (define (cycle? x)
    (let ((seens '()))
      (let inner ((x x))
        (cond ((not (pair? x)) #f)
              ((memq x seens) #t)
              (else (set! seens (cons x seens))
                    (inner (cdr x)))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-18-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-18")
  (test #f
        (cycle? '()))
  (test #f
        (cycle? 'a))
  (test #f
        (cycle? pairs-3))
  (test #f
        (cycle? pairs-4))
  (test #f
        (cycle? pairs-7))
  (test #t
        (cycle? pairs-cycle))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.19][Exercise 3.19.]]

Use [[http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare][Floyd's cycle-finding algorithm]], also known as the "tortoise-and-hare"
algorithm. Two pointers to the list elements are kept. The "tortoise" is
advanced by 1 position for every call, while the "hare" is advanced by 2
positions. If a cycle exists, the tortoise and hare will eventually run into
other (i.e., compare equal via ~eq?~ after the initial call).

#+BEGIN_SRC scheme :tangle ex-3-19.scm
  (define (cycle? x)
    (define (cdr-safe x)
      (if (not (pair? x))
          x
          (cdr x)))
    (define (cddr-safe x)
      (if (not (pair? x))
          x
          (cdr-safe (cdr x))))
    (define (inner tortoise hare first-run)
      (cond ((any (lambda (p) (not (pair? p)))
                  (list tortoise hare))
             #f)
            ((and (not first-run)
                  (eq? tortoise hare))
             #t)
            (else (inner (cdr-safe tortoise)
                         (cddr-safe hare)
                         #f))))
    (inner x x #t))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-19-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-19")
  (test #f
        (cycle? '()))
  (test #f
        (cycle? 'a))
  (test #f
        (cycle? pairs-3))
  (test #f
        (cycle? pairs-4))
  (test #f
        (cycle? pairs-7))
  (test #t
        (cycle? pairs-cycle))
#+END_SRC
