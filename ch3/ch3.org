#+TITLE: Structure and Interpretation of Computer Programs (SICP)
#+AUTHOR: Robert Irelan
#+EMAIL: rirelan@gmail.com
#+OPTIONS: author:t email:t f:t
#+PROPERTY: header-args :comments link :noweb no-export
#+PROPERTY: header-args:scheme :shebang #!/usr/bin/env chicken-scheme

* TODO Chapter 3: Modularity, Objects, and State

** DONE 3.1: Assignment and Local State

*** DONE 3.1.1: Local State Variables

**** DONE [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.1][Exercise 3.1.]]

#+BEGIN_SRC scheme :tangle ex-3-1.scm
  (define (make-accumulator initial)
    (lambda (increment)
      (set! initial (+ initial increment))
      initial))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-1-test.scm
  (use test)
  (include "ex-3-1")
  (define A (make-accumulator 5))
  (test 15
        (A 10))
  (test 25
        (A 10))
#+END_SRC

**** DONE [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.2][Exercise 3.2.]]

#+BEGIN_SRC scheme :tangle ex-3-2.scm
  (define (make-monitored f)
    (define counter 0)
    (lambda (x)
      (cond ((equal? x 'how-many-calls?)
             counter)
            ((equal? x 'reset-count)
             (set! counter 0))
            (else
             (f x)
             (set! counter (+ counter 1))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-2-test.scm
  (use test)
  (include "ex-3-2")
  (define s (make-monitored sqrt))
  (test 10
        (s 100))
  (test 1
        (s 'how-many-calls?))
#+END_SRC

**** DONE [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.3][Exercise 3.3.]]

#+BEGIN_SRC scheme :tangle ex-3-3.scm
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x) "Incorrect password")
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request -- MAKE-ACCOUNT"
                             m)))))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-3-test.scm
  (use test)
  (include "ex-3-3")
  (define acc (make-account 100 'secret-password))
  (test 60
        ((acc 'secret-password 'withdraw) 40))
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
#+END_SRC

**** DONE [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.4][Exercise 3.4.]]

As the prompt states, there's little more work involved than to add
a ~incorrect-password-attempts~, which we use to ~call-the-cops~ when too many
incorrect attempts in a row have been made. Ideally, a different response
would not be returned to the user when the cops have been called, but I've
decided to do so for ease of testing.

#+BEGIN_SRC scheme :tangle ex-3-4.scm
  (define (make-account balance password)
    (define incorrect-password-attempts 0)
    (define (call-the-cops)
      "Please wait -- calling the cops...")
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x)
            (set! incorrect-password-attempts
                  (+ incorrect-password-attempts 1))
            (if (> incorrect-password-attempts 7)
                (call-the-cops)
                "Incorrect password"))
          (begin
            (set! incorrect-password-attempts 0)
            (cond ((eq? m 'withdraw) withdraw)
                  ((eq? m 'deposit) deposit)
                  (else (error "Unknown request -- MAKE-ACCOUNT"
                               m))))))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-4-test.scm
  (use test)
  (include "ex-3-4")
  (define acc (make-account 100 'secret-password))
  (for-each (lambda (i)
              (test "Incorrect password"
                    ((acc 'some-other-password 'withdraw) 100)))
            (iota 7))
  (test "Please wait -- calling the cops..."
        ((acc 'some-other-password 'withdraw) 100))
#+END_SRC

*** DONE 3.1.2: The Benefits of Introducing Assignment

**** DONE [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.5][Exercise 3.5.]]

#+BEGIN_SRC scheme :tangle ex-3-5.scm
  (define (estimate-integral P x1 x2 y1 y2 ntrial)
    ;; Number of trials for which the trial point was inside the region to be
    ;; integrated (i.e., where (= (P x y) #t)).
    (define ninside 0)
    (define (random-x)
      (random-in-range x1 x2))
    (define (random-y)
      (random-in-range y1 y2))
    (define (try x y)
      (if (P x y)
          (set! ninside (+ ninside 1))))
    (for-each (lambda (i)
                (try (random-x) (random-y)))
              (iota ntrial))
    (* (- x2 x1)
       (- y2 y1)
       (/ ninside ntrial)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-5-test.scm
  (use test)
  (include "ex-3-5")
  (define (p-circle)
    (lambda (x y)
      (> (* 1.0 1.0)
         (+ (* x x)
            (* y y)))))
  (current-test-epsilon 0.10)
  (define pi (* 4 (atan 1 1)))
  (parameterize ((current-test-epsilon 0.10))
                (test pi
                      (estimate-integral (p-circle) -2.0 2.0 -2.0 2.0 100000)))
#+END_SRC

**** DONE [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.6][Exercise 3.6.]]

This is a fairly simple modification of the ~rand~ command defined in the
book. The main change is to dispatch on a ~command~ argument to ~rand~. Also,
since the ~reset~ argument sets the seed of the random number generator, I
don't define a ~random-init~ variable here. Thus, it is necessary to make at
least one call to ~(rand 'reset)~ before using ~(rand 'generate)~ to make sure
the seed is initialized.

#+BEGIN_SRC scheme :tangle ex-3-6.scm
  (define (rand command)
    (define x nil)                        ; Don't produce random numbers until initialized
    (cond ((equal? command 'generate)
           (set! x (rand-update x))
           x)
          ((equal? command 'reset)
           (lambda (x-init)
             (set! x x-init)))
          (else
           (error "RAND -- bad command")
           command)))
#+END_SRC

*** DONE 3.1.3: The Costs of Introducing Assignment

**** DONE [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.7][Exercise 3.7.]]

#+BEGIN_SRC scheme :tangle ex-3-7.scm
  (include "ex-3-3")
  (define (make-joint account original-password new-password)
    (define (dispatch p m)
      ;; The underlying account accepts only original-password, so accept
      ;; new-password by passing original-password. Otherwise, let the underlying
      ;; account deal with error handling for a wrong password.
      (display p) (newline)
      (if (equal? p new-password)
          (account original-password m)
          (account p m)))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-7-test.scm
  (use test)
  (include "ex-3-7")
  (define acc (make-account 140 'secret-password))
  (define joint-acc
    (make-joint acc 'secret-password 'proxy-password))
  ;;; Both `acc` and `joint-acc` accept the original password, and actions on
  ;;; either affect the other since `joint-acc` delegates all messages to `acc`.
  (test 100
        ((joint-acc 'secret-password 'withdraw) 40))
  (test 60
        ((joint-acc 'secret-password 'withdraw) 40))
  ;;; Neither account works with an unknown password.
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
  (test "Incorrect password"
        ((joint-acc 'some-other-password 'deposit) 50))
  ;;; Original account `acc` doesn't work with the proxy password, but the joint
  ;;; account `joint-acc` does.
  (test "Incorrect password"
        ((acc 'proxy-password 'withdraw) 20))
  (test 40
        ((joint-acc 'proxy-password 'withdraw) 20))
#+END_SRC

**** DONE [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.8][Exercise 3.8.]]

#+BEGIN_SRC scheme :tangle ex-3-8.scm
  (define f
    (let ((cache '()))
      (lambda (x)
        (cond ((null? x) (set! cache '())) ; Allow cache to be cleared.
              ((not (null? cache)) 0)      ; Return 0 if cache isn't clear.
              (else (set! cache x)       ; Set cache if it isn't clear already.
                    x)))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-8-test.scm
  (use test)
  (include "ex-3-8")

  ;;; Simulate left-to-right evaluation by assigning to temporaries
  (define x (f 0))
  (define y (f 1))
  (test 0
        (+ x y))

  ;;; Reset cache
  (f '())

  ;;; Right-to-left evaluation
  (define y (f 1))
  (define x (f 0))
  (test 1
        (+ x y))
#+END_SRC


** DONE 3.2: The Environment Model of Evaluation

*** DONE 3.2.1: The Rules for Evaluation

No exercises

*** DONE 3.2.2: Applying Simple Procedures
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.9][Exercise 3.9.]]

I don't want to draw, so I'll use Scheme S-expressions instead.

In general, each invocation of a procedure creates an environment containing a
reference to its enclosing environment and a list of references to its
parameters. The global environment is much the same except that has a nil
pointer for the enclosing environment since there is no enclosing
environment. In the below, I've represented each parameter as a list of the
symbol name and value, but the symbol name is only preserved here for ease of
following the examples -- it doesn't necessarily have to be kept in an actual
interpreter.

The recursive definition of ~factorial~,

#+BEGIN_SRC scheme
  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))
#+END_SRC

spawns a separate environment for each call of ~factorial~, each of which has a
reference to the global environment and the value of its one argument:

#+BEGIN_SRC scheme
  (define global-env `(() (factorial ,factorial-proc)
                          (fact-iter ,fact-iter-proc)
                          ,@intrinsic-defs))
  (define all-envs `((,global-env (n ,6))))
  (set! ,all-envs `((,global-env (n ,5)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,4)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,3)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,2)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,1)) ,all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (assert (null? all-envs))

#+END_SRC

In contrast, the iterative version,

#+BEGIN_SRC scheme
  (define (factorial n)
    (fact-iter 1 1 n))
  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
#+END_SRC

because it is tail recursive, replaces the environment of the function from
which a tail recursive call is made with the environment for the target
function of the tail recursive call. Since all function calls in both
~factorial~ and ~fact-iter~ are tail recursive, the list of environments
changes basically as described in the pseudocode below:

#+BEGIN_SRC scheme
  (define global-env `(() (factorial ,factorial-proc)
                       (fact-iter ,fact-iter-proc)
                       ,@intrinsic-defs))
  (define all-envs `((global-env (n ,6))))
  (set-car! all-envs `(global-env (product ,1)
                                  (counter ,1)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,1)
                                  (counter ,2)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,2)
                                  (counter ,3)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,6)
                                  (counter ,4)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,24)
                                  (counter ,5)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,120)
                                  (counter ,6)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,720)
                                  (counter ,7)
                                  (max-count ,6)))
  (set! all-envs (cdr all-envs))
  (assert (null? all-envs))
#+END_SRC

Notice above that we've really simulated a stack, with ~set-car!~ performing a
mutation-in-place of the top entry of the stack.

*** DONE 3.2.3: Frames as the Repository of Local State
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.10][Exercise 3.10.]]

The procedure to be analyzed,

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    (let ((balance initial-amount))
      (lambda (amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))))
#+END_SRC

expands to the following when ~let~ is expanded to its underlying syntax:

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    ((lambda (balance)
       (lambda (amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds")))
     initial-amount))
#+END_SRC

Without TCE, the function returned by ~make-withdraw~ (i.e.,
~(lambda (amount) ⋯)~), has a pointer the environment of
~(lambda (balance) ⋯)~, which has a pointer to the global environment. However,
the call to ~(lambda (balance) ⋯)~ is in tail position, so it replaces the
environment formed by the call of ~make-withdraw~. When the returned
~(lambda (amount) ⋯)~ is called, it therefore has a pointer to the environment
of ~(lambda (balance) ⋯)~, which points to the global environment.

*** DONE 3.2.4: Internal Definitions
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.11][Exercise 3.11.]]

The environment for ~make-account~ points to the global environment. In this
environment exist references to the argument ~balance~ as well as the local
procedures ~withdraw~, ~deposit~, and ~dispatch~. Each local procedure points to
the environment of ~make-account~ (and retains references to its own arguments
as well). It's necessary to keep references to the local procedures in the
environment of ~make-account~ so that ~dispatch~ can resolve the references to
~withdraw~ and ~deposit~ in its body. (On the other hand, it should not
strictly be necessary to retain a reference to ~dispatch~ since a reference to
that procedure is returned.)


** TODO 3.3: Modeling with Mutable Data

*** TODO 3.3.1: Applying Simple Procedures
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.12][Exercise 3.12.]]

#+BEGIN_SRC scheme :tangle ex-3-12-test.scm
  (use test)

  ;;; Nondestructive
  (define x (list 'a 'b))
  (define y (list 'c 'd))
  (define z (append x y))

  (test z
        '(a b c d))
  (test (cdr x)
        '(b))

  ;;; Destructive
  (define w (append! x y))

  (test w
        '(a b c d))
  (test (cdr w)
        '(b c d))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.13][Exercise 3.13.]]

When a circular list is constructed from a linear list, the last cons cell in
the original list has its cdr set to the head of the original list. Thus,
~(null? (cdr x))~ never returns true for any element ~x~ in the list and the
~last-pair~ procedure loops around the list forever.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.14][Exercise 3.14.]]

~mystery~ reverses a list destructively:

#+NAME: ex-3-14
#+BEGIN_SRC scheme
  (define (mystery x)
    (define (loop x y)
      (if (null? x)
          y
          (let ((temp (cdr x)))
            (set-cdr! x y)
            (loop temp x))))
    (loop x '()))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-14-test.scm
  (use test)
  <<ex-3-14>>
  (define v '(a b c d))
  (define w (mystery v))
  (test w
        '(d c b a))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.15][Exercise 3.15.]]

In Figure 3.16, modify the diagram so that the arrow pointing to the ~'a~ cell
now points to a ~'wow~ cell.

In Figure 3.17, only the arrow pointing to ~'a~ from below now points to ~'wow~
-- the arrow from above continues to point to ~'a~.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.16][Exercise 3.16.]]

Ben Bitdiddle's flawed procedure:

#+NAME: ex-3-16-count-pairs
#+BEGIN_SRC scheme
  (define (count-pairs x)
    (if (not (pair? x))
        0
        (+ (count-pairs (car x))
           (count-pairs (cdr x))
           1)))
#+END_SRC

We define some test data here, containing a simple list, some more complex
linked structures, and a list containing a cycle, for this and the rest of the
exercises in this section.

#+BEGIN_SRC scheme :tangle sharing-identity-test-data.scm
  (define pairs-3 '(a b c))
  (define pairs-4
    (begin
      (define x '(a b c))
      (set-car! x (cddr x))
      x))
  (define pairs-7
    (begin
      (define x '(a b c))
      (set-car! x (cdr x))
      (set-car! (cdr x) (cddr x))
      x))
  (define pairs-cycle
    (begin
      (define x '(a b c))
      (set-cdr! (cddr x) x)
      x))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-16-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (test 0
        (count-pairs '()))
  (test 0
        (count-pairs 'a))
  (test 3
        (count-pairs pairs-3))
  (test 4
        (count-pairs pairs-4))
  (test 7
        (count-pairs pairs-7))
  ;;; No test for pairs-cycle, because a cycle causes this version of count-pairs
  ;;; to run forever.
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.17][Exercise 3.17.]]

#+BEGIN_SRC scheme :tangle ex-3-17-count-pairs.scm
  (define (count-pairs x)
    (let ((seens '()))
      (let inner ((x x))
        (if (or (not (pair? x))
                (memq x seens))
            0
            (begin
              (set! seens (cons x seens))
              (+ (inner (car x))
                 (inner (cdr x))
                 1))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-17-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-17-count-pairs")
  (test 0
        (count-pairs '()))
  (test 0
        (count-pairs 'a))
  (test 3
        (count-pairs pairs-3))
  (test 4
        (count-pairs pairs-4))
  (test 7
        (count-pairs pairs-7))
  (test 3
        (count-pairs pairs-cycle))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.18][Exercise 3.18.]]

#+BEGIN_SRC scheme :tangle ex-3-18.scm
  (define (cycle? x)
    (let ((seens '()))
      (let inner ((x x))
        (cond ((not (pair? x)) #f)
              ((memq x seens) #t)
              (else (set! seens (cons x seens))
                    (inner (cdr x)))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-18-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-18")
  (test #f
        (cycle? '()))
  (test #f
        (cycle? 'a))
  (test #f
        (cycle? pairs-3))
  (test #f
        (cycle? pairs-4))
  (test #f
        (cycle? pairs-7))
  (test #t
        (cycle? pairs-cycle))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.19][Exercise 3.19.]]

Use [[http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare][Floyd's cycle-finding algorithm]], also known as the "tortoise-and-hare"
algorithm. Two pointers to the list elements are kept. The "tortoise" is
advanced by 1 position for every call, while the "hare" is advanced by 2
positions. If a cycle exists, the tortoise and hare will eventually run into
other (i.e., compare equal via ~eq?~ after the initial call).

#+BEGIN_SRC scheme :tangle ex-3-19.scm
  (define (cycle? x)
    (define (cdr-safe x)
      (if (not (pair? x))
          x
          (cdr x)))
    (define (cddr-safe x)
      (if (not (pair? x))
          x
          (cdr-safe (cdr x))))
    (define (inner tortoise hare first-run)
      (cond ((any (lambda (p) (not (pair? p)))
                  (list tortoise hare))
             #f)
            ((and (not first-run)
                  (eq? tortoise hare))
             #t)
            (else (inner (cdr-safe tortoise)
                         (cddr-safe hare)
                         #f))))
    (inner x x #t))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-19-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-19")
  (test #f
        (cycle? '()))
  (test #f
        (cycle? 'a))
  (test #f
        (cycle? pairs-3))
  (test #f
        (cycle? pairs-4))
  (test #f
        (cycle? pairs-7))
  (test #t
        (cycle? pairs-cycle))
#+END_SRC

** TODO 3.4: Concurrency: Time Is of the Essence

*** TODO 3.4.1: The Nature of Time in Concurrent Systems

Complexity of concurrent systems comes from:

- Dependence of ordering of events in a system with mutation.
- Reduced ability to control ordering of events, and difficulty in mentally
  taking this into account.

Concurrency models:

- No two operations on any shared state variable can occur at the same
  time. Too strict for most uses (for example, implies that only one
  transaction can occur at a time in a bank system).
- System must proceed as if events had been executed sequentially in /some/
  order (not guaranteed what order is used).
  - There can still be more than one "correct" answer -- may need to restrict
    some parts of the program further depending on requirements.

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.38][Exercise 3.38.]]

a. There are 6 combinations of Peter (A), Paul (B), and Mary (C):

   | Order     | Final amount |
   |-----------+--------------|
   | (A, B, C) |           45 |
   | (A, C, B) |           35 |
   | (B, A, C) |           45 |
   | (B, C, A) |           50 |
   | (C, A, B) |           40 |
   | (C, B, A) |           40 |

b. For each transaction, there are 3 steps:

   - Read the current balance from the shared account.
   - Modify the balance of the individual account.
   - Write the new balance to the shared account.

   However, the second step doesn't modify a shared variable, so the relevant
   combinations for each transaction can be represented by two operations (Xr
   for read and Xw for write for person X). The six combinations where each
   account is read and then immediately written by the same person is
   represented above.

   Here are some things to notice about concurrency in this scenario:

   - The actions of A and B don't depend on the current balance, only those
     of C.
   - Because of this, it only matters when C reads relative to the times that A
     or B read, for which there are 4 distinct possibilities.
     - If C reads before or after both A and B write, the final
       balance will be the same no matter what order A and B write.

   Here is the table for completeness. Note that no final balances appear here
   that did not appear above.

   | Order        | Final amount |
   |--------------+--------------|
   | (Aw, Bw, Cr) |           45 |
   | (Bw, Aw, Cr) |           45 |
   | (Cr, Aw, Bw) |           40 |
   | (Cr, Bw, Aw) |           40 |
   | (Aw, Cr, Bw) |           35 |
   | (Bw, Cr, Aw) |           50 |

*** TODO 3.4.2: Mechanisms for Controlling Concurrency

There are too many possible orderings of concurrent processes to ensure a
single answer or to analyze in many cases.

Serializer:
- Ensures that only one procedure under the control of the serializer can be
  executed at a time.
- Example: In the below, ~foo~ and ~bar~ are guaranteed to not execute at the
  same time (i.e., their execution is /serialized/).

  #+BEGIN_SRC scheme
    (define s (make-serializer))
    (parallel-execute (s (foo))
                      (s (bar)))
  #+END_SRC

- Implemented in terms of /mutexes/.
- Mutex implemented as a spin lock using a test-and-set instruction.

Here's an implementation of the threading tools ~parallel-execute~ and
~make-serializer~ using SRFI-18 mutexes and threads:

#+BEGIN_SRC scheme :tangle concurrency.scm
  (use srfi-18)

  (define (make-serializer)
    (let ((mutex (make-mutex)))
      (lambda (p)
        (define (serialized-p . args)
          (mutex-lock! mutex)
          (let ((val (apply p args)))
            (mutex-unlock! mutex)
            val))
        serialized-p)))

  (define (parallel-execute . fs)
    (let ((ts (map make-thread fs)))
      (for-each thread-start! ts)
      (for-each thread-join! ts)
      '()))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.39][Exercise 3.39.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.40][Exercise 3.40.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.41][Exercise 3.41.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.42][Exercise 3.42.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.43][Exercise 3.43.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.44][Exercise 3.44.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.45][Exercise 3.45.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.46][Exercise 3.46.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.47][Exercise 3.47.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.48][Exercise 3.48.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.49][Exercise 3.49.]]

** TODO 3.5: Streams

Basic stream procedures used throughout the section.

#+BEGIN_SRC scheme :tangle stream.scm
  <<stream-primitives>>
  <<stream-fold>>

  (define (stream-ref s n)
    (if (= n 0)
        (stream-car s)
        (stream-ref (stream-cdr s) (- n 1))))
  <<stream-map-poly>>
  (define (stream-for-each proc s)
    (if (stream-null? s)
        'done
        (begin (proc (stream-car s))
               (stream-for-each proc (stream-cdr s)))))
  (define (stream-filter proc s)
    (cond ((stream-null? s) the-empty-stream)
          ((proc (stream-car s))
           (cons-stream (stream-car s)
                        (stream-filter proc (stream-cdr s))))
          (else
           (stream-filter proc (stream-cdr s)))))
  (define (display-line x)
    (newline)
    (display x))
  (define (display-stream s)
    (stream-for-each display-line s))
  (define (stream-enumerate-interval low high)
    (if (> low high)
        the-empty-stream
        (cons-stream
         low
         (stream-enumerate-interval (+ low 1) high))))
#+END_SRC

We start with the primitive procedures on the stream data type:

#+NAME: stream-primitives
#+BEGIN_SRC scheme
  (define the-empty-stream 'the-empty-stream)
  (define (stream-null? s) (eq? s the-empty-stream))
  (define-syntax cons-stream
    (syntax-rules ()
      ((cons-stream a b)
       (cons a (delay b)))))
  (define (stream-car stream) (car stream))
  (define (stream-cdr stream) (force (cdr stream)))
#+END_SRC

Another very useful and generally-applicable stream function is ~fold~. In
fact, both ~map~ and ~filter~ can be implemented in terms of ~fold~:

#+NAME: stream-fold
#+BEGIN_SRC scheme
  (define (stream-fold kons knil . streams)
    (if (or (map stream-null? streams))
        knil
        (cons-stream (apply kons (append (map stream-car streams)
                                         knil))
                     (apply stream-fold kons knil (map stream-cdr streams)))))
#+END_SRC

*** TODO 3.5.1: Streams Are Delayed Lists
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.50][Exercise 3.50.]]

The ~apply~ procedure can be used to call a function with arguments drawn from
a list, and we can iterate along the argument streams in turn (which are all
assumed to be of the same length):

#+NAME: stream-map-poly
#+BEGIN_SRC scheme :tangle ex-3-50.scm
  (define (stream-map proc . argstreams)
    (if (stream-null? (car argstreams))
        the-empty-stream
        (cons-stream
         (apply proc (map stream-car argstreams))
         (apply stream-map
                (cons proc (map stream-cdr argstreams))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-50-test.scm
  (include "stream")
  (use test)
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.51][Exercise 3.51.]]

#+BEGIN_SRC scheme :tangle ex-3-51-test.scm
  (include "stream")
  (define (show x) (display-line x) x)
  (define x (stream-map show (stream-enumerate-interval 0 10)))
  (stream-ref x 5)
  (stream-ref x 7)
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.52][Exercise 3.52.]]

We have these definitions, which in particular include a mutating procedure
~accum~:

#+BEGIN_SRC scheme :tangle ex-3-52-test.scm
  (include "stream")
  (use test)
  (define sum 0)
  (define (accum x)
    (set! sum (+ x sum))
    sum)
  (define seq (stream-map accum (stream-enumerate-interval 1 20)))
  (define y (stream-filter even? seq))
  (define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                           seq))

  <<ex-3-52-eval-y>>
  <<ex-3-52-eval-z>>
#+END_SRC

First, we obtain the 7^{th} element of ~y~, which is the 14^{th} element of ~seq~,
obtaining the expected result of \( \sum_{i=1}^{14} i = 136 \):
#+NAME: ex-3-52-eval-y
#+BEGIN_SRC scheme
  (stream-ref y 7)
  (test 136
        sum)
#+END_SRC

Next, we look at ~z~, which should contain only those entries of ~seq~
divisible by ~5~. Since \( \sum_{i=1}^{n} i = \frac{n(n + 1)}{2} \), we expect
that both every \(i\)^{th} entry and \(i-1\)^{th} entry of
~(stream-enumerate-interval 1 20)~ should produce a corresponding entry in ~z~,
and this is what we indeed observe, finally obtaining ~(= sum 210)~.

#+NAME: ex-3-52-eval-y
#+BEGIN_SRC scheme
  (display-stream z)
  (test 210
        sum)
#+END_SRC

However, if ~delay~ did not cache its results, the mutation in ~accum~ would
cause a different result to be obtained for ~z~ (but not for ~y~, since it was
the first evaluated). The execution of ~y~ would have gone through the first 14
integers, as before, giving ~(= sum 136)~. The values of ~seq~ when ~z~ was
executed would therefore all be increased by 136, producing a different stream
for ~z~ and a final sum of \(136 + 210 = 346\).


*** TODO 3.5.2: Infinite Streams

The book defines several miscellaneous procedures that are useful for exercises
in this section:

#+BEGIN_SRC scheme :tangle stream-util.scm
  (include "stream")

  (define (integers-starting-from n)
    (cons-stream n (integers-starting-from (+ n 1))))

  (define integers (integers-starting-from 1))

  (define (add-streams s1 s2)
    (stream-map + s1 s2))
  (define (scale-stream stream factor)
    (stream-map (lambda (x) (* x factor)) stream))

  <<stream-partial-sums>>
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.53][Exercise 3.53.]]

This produces a stream consisting of the powers of 2: ~1 2 4 8 16 ...~.

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.54][Exercise 3.54.]]

#+BEGIN_SRC scheme

#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.55][Exercise 3.55.]]

In order to calculate the partial sum corresponding to an element in the input
stream, you need two pieces of information: the partial sum of the elements
before this one and the element itself. This is most easily done using
recursion. The recursive function call tracks in its parameters the partial sum
of the preceding elements and the start of the remaining input stream and
returns the entire output stream.

#+NAME: stream-partial-sums
#+BEGIN_SRC scheme
  (include "stream")
  (define (partial-sums s)
    (let rec ((partial-sum 0)
              (s s))
      (if (stream-null? s)
          the-empty-stream
          (let ((new-sum (+ partial-sum (stream-car s))))
            (cons-stream new-sum
                         (rec new-sum (stream-cdr s)))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-55-test.scm
  (use test)
  (include "stream-util")

  (test 15
        (stream-ref (partial-sums integers) 4))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.56][Exercise 3.56.]]

The ~merge~ procedure combines two streams ordered in ascending order,
eliminating repetitions:

#+NAME: stream-merge
#+BEGIN_SRC scheme
  (define (merge s1 s2)
    (cond ((stream-null? s1) s2)
          ((stream-null? s2) s1)
          (else
           (let ((s1car (stream-car s1))
                 (s2car (stream-car s2)))
             (cond ((< s1car s2car)
                    (cons-stream s1car (merge (stream-cdr s1) s2)))
                   ((> s1car s2car)
                    (cons-stream s2car (merge s1 (stream-cdr s2))))
                   (else
                    (cons-stream s1car
                                 (merge (stream-cdr s1)
                                        (stream-cdr s2)))))))))
#+END_SRC

Given this, we can create ~S~, the list of integers with no prime factors but
2, 3, and 5:

#+BEGIN_SRC scheme :tangle ex-3-56.scm
  (include "stream")
  (include "stream-util")
  <<stream-merge>>

  (define S (cons-stream 1 (merge (scale-stream S 2)
                                  (merge (scale-stream S 3)
                                         (scale-stream S 5)))))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.57][Exercise 3.57.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.58][Exercise 3.58.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.59][Exercise 3.59.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.60][Exercise 3.60.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.61][Exercise 3.61.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.62][Exercise 3.62.]]

*** TODO 3.5.3: Exploiting the Stream Paradigm

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.63][Exercise 3.63.]]

*TODO*: Explain better.

First, note that both procedures are inefficient without memoization, because
~guesses~ has to be evaluated always in Alyssa's version as well. However, with
memoization, the ~guesses~ variable is bound in the environment of
~sqrt-stream~, so the delayed cdr of the stream returned by ~cons-stream~ is
memoized after the first call.

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.64][Exercise 3.64.]]

A straightforward recursive procedure:

#+BEGIN_SRC scheme :tangle ex-3-64.scm
  (include "stream")

  (define (stream-limit stream tol)
    (let rec ((stream stream)
              (previous +inf))  ; +INF is IEEE-754 positive infinity
      (if (stream-null? stream)
          (error "STREAM-LIMIT - stream exhausted without tolerance achieved")
          (let ((current (stream-car stream))
                (rest (stream-cdr stream)))
            (if (< (abs (- previous current)) tol)
                current
                (rec rest current))))))

#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.65][Exercise 3.65.]]

This is the original sequence:

#+NAME: ln2-stream
#+BEGIN_SRC scheme
  (include "stream")
  (include "stream-util")

  (define (ln2-summands)
    (cons-stream 1.0
                 (stream-map (lambda (k)
                               (* (if (even? k) -1.0 1.0)
                                  (/ 1.0 k)))
                             (integers-starting-from 2))))
  (define (ln2-stream)
    (partial-sums (ln2-summands)))
#+END_SRC

In order to accelerate the \(\ln{2}\) sequence, we use the Euler transform from
this subsection:

#+NAME: stream-euler-transform
#+BEGIN_SRC scheme
  (define (make-tableau transform s)
    (cons-stream s
                 (make-tableau transform
                               (transform s))))

  (define (accelerated-sequence transform s)
    (stream-map stream-car
                (make-tableau transform s)))

  (define (square x) (* x x))
  (define (euler-transform s)
    (let ((s0 (stream-ref s 0))           ; S_{n-1}
          (s1 (stream-ref s 1))           ; S_{n}
          (s2 (stream-ref s 2)))          ; S_{n+1}
      (cons-stream (- s2 (/ (square (- s2 s1))
                            (+ s0 (* -2 s1) s2)))
                   (euler-transform (stream-cdr s)))))
#+END_SRC

We put the sequence and the transform in the same file for ease of testing:

#+BEGIN_SRC scheme :tangle ex-3-65.scm
  <<stream-euler-transform>>
  <<ln2-stream>>
#+END_SRC

With that, we can calculate the convergence of the original sequence as well as
its acceleration one and two times. As expected, the more accelerated sequences
converge much faster---while the original sequence has not converged even after
hundreds of iterations, it only takes 10 iterations for the first accelerated
sequence to converge to the limits of floating-point accuracy, and 5 iterations
for the second accelerated sequence.

#+BEGIN_SRC scheme :tangle ex-3-65-test.scm
  (use test)
  (include "ex-3-65")

  (define orig (ln2-stream))
  (define acc1 (accelerated-sequence euler-transform orig))
  (define acc2 (accelerated-sequence euler-transform acc1))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.66][Exercise 3.66.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.67][Exercise 3.67.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.68][Exercise 3.68.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.69][Exercise 3.69.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.70][Exercise 3.70.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.71][Exercise 3.71.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.72][Exercise 3.72.]]

*** TODO 3.5.4: Streams and Delayed Evaluation
*** TODO 3.5.5: Modularity of Functional Programs and Modularity of Objects
