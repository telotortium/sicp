#+TITLE: Structure and Interpretation of Computer Programs (SICP)
#+AUTHOR: Robert Irelan
#+EMAIL: rirelan@gmail.com
#+OPTIONS: author:t email:t f:t num:nil H:4
#+PROPERTY: header-args :comments link :noweb no-export
#+PROPERTY: header-args:scheme :shebang #!/usr/bin/env chicken-scheme
#+FILETAGS: :SICP:

* TODO Chapter 3: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-19.html#%_chap_3][Modularity, Objects, and State]]

** DONE 3.1: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1][Assignment and Local State]]

*** DONE 3.1.1: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.1][Local State Variables]]

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.1][Exercise 3.1.]]

#+BEGIN_SRC scheme :tangle ex-3-1.scm
  (define (make-accumulator initial)
    (lambda (increment)
      (set! initial (+ initial increment))
      initial))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-1-test.scm
  (use test)
  (include "ex-3-1")
  (define A (make-accumulator 5))
  (test 15
        (A 10))
  (test 25
        (A 10))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.2][Exercise 3.2.]]

#+BEGIN_SRC scheme :tangle ex-3-2.scm
  (define (make-monitored f)
    (define counter 0)
    (lambda (x)
      (cond ((equal? x 'how-many-calls?)
             counter)
            ((equal? x 'reset-count)
             (set! counter 0))
            (else
             (f x)
             (set! counter (+ counter 1))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-2-test.scm
  (use test)
  (include "ex-3-2")
  (define s (make-monitored sqrt))
  (test 10
        (s 100))
  (test 1
        (s 'how-many-calls?))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.3][Exercise 3.3.]]

Modify the ~make-account~ procedure so that it creates password-protected
accounts. That is, ~make-account~ should take a symbol as an additional
argument, as in

#+BEGIN_SRC scheme :tangle ex-3-3.scm
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x) "Incorrect password")
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request -- MAKE-ACCOUNT"
                             m)))))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-3-test.scm
  (use test)
  (include "ex-3-3")
  (define acc (make-account 100 'secret-password))
  (test 60
        ((acc 'secret-password 'withdraw) 40))
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.4][Exercise 3.4.]]

As the prompt states, there's little more work involved than to add
a ~incorrect-password-attempts~, which we use to ~call-the-cops~ when too many
incorrect attempts in a row have been made. Ideally, a different response
would not be returned to the user when the cops have been called, but I've
decided to do so for ease of testing.

#+BEGIN_SRC scheme :tangle ex-3-4.scm
  (define (make-account balance password)
    (define incorrect-password-attempts 0)
    (define (call-the-cops)
      "Please wait -- calling the cops...")
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x)
            (set! incorrect-password-attempts
                  (+ incorrect-password-attempts 1))
            (if (> incorrect-password-attempts 7)
                (call-the-cops)
                "Incorrect password"))
          (begin
            (set! incorrect-password-attempts 0)
            (cond ((eq? m 'withdraw) withdraw)
                  ((eq? m 'deposit) deposit)
                  (else (error "Unknown request -- MAKE-ACCOUNT"
                               m))))))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-4-test.scm
  (use test)
  (include "ex-3-4")
  (define acc (make-account 100 'secret-password))
  (for-each (lambda (i)
              (test "Incorrect password"
                    ((acc 'some-other-password 'withdraw) 100)))
            (iota 7))
  (test "Please wait -- calling the cops..."
        ((acc 'some-other-password 'withdraw) 100))
#+END_SRC

*** DONE 3.1.2: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.2][The Benefits of Introducing Assignment]]

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.5][Exercise 3.5.]]

#+BEGIN_SRC scheme :tangle ex-3-5.scm
  (define (estimate-integral P x1 x2 y1 y2 ntrial)
    ;; Number of trials for which the trial point was inside the region to be
    ;; integrated (i.e., where (= (P x y) #t)).
    (define ninside 0)
    (define (random-x)
      (random-in-range x1 x2))
    (define (random-y)
      (random-in-range y1 y2))
    (define (try x y)
      (if (P x y)
          (set! ninside (+ ninside 1))))
    (for-each (lambda (i)
                (try (random-x) (random-y)))
              (iota ntrial))
    (* (- x2 x1)
       (- y2 y1)
       (/ ninside ntrial)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-5-test.scm
  (use test)
  (include "ex-3-5")
  (define (p-circle)
    (lambda (x y)
      (> (* 1.0 1.0)
         (+ (* x x)
            (* y y)))))
  (current-test-epsilon 0.10)
  (define pi (* 4 (atan 1 1)))
  (parameterize ((current-test-epsilon 0.10))
                (test pi
                      (estimate-integral (p-circle) -2.0 2.0 -2.0 2.0 100000)))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.6][Exercise 3.6.]]

This is a fairly simple modification of the ~rand~ command defined in the
book. The main change is to dispatch on a ~command~ argument to ~rand~. Also,
since the ~reset~ argument sets the seed of the random number generator, I
don't define a ~random-init~ variable here. Thus, it is necessary to make at
least one call to ~(rand 'reset)~ before using ~(rand 'generate)~ to make sure
the seed is initialized.

#+BEGIN_SRC scheme :tangle ex-3-6.scm
  (define (rand command)
    (define x nil)                        ; Don't produce random numbers until initialized
    (cond ((equal? command 'generate)
           (set! x (rand-update x))
           x)
          ((equal? command 'reset)
           (lambda (x-init)
             (set! x x-init)))
          (else
           (error "RAND -- bad command")
           command)))
#+END_SRC

*** DONE 3.1.3: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.3][The Costs of Introducing Assignment]]

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.7][Exercise 3.7.]]

#+BEGIN_SRC scheme :tangle ex-3-7.scm
  (include "ex-3-3")
  (define (make-joint account original-password new-password)
    (define (dispatch p m)
      ;; The underlying account accepts only original-password, so accept
      ;; new-password by passing original-password. Otherwise, let the underlying
      ;; account deal with error handling for a wrong password.
      (if (equal? p new-password)
          (account original-password m)
          (account p m)))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-7-test.scm
  (use test)
  (include "ex-3-7")
  (define acc (make-account 140 'secret-password))
  (define joint-acc
    (make-joint acc 'secret-password 'proxy-password))
  ;;; Both `acc` and `joint-acc` accept the original password, and actions on
  ;;; either affect the other since `joint-acc` delegates all messages to `acc`.
  (test 100
        ((joint-acc 'secret-password 'withdraw) 40))
  (test 60
        ((joint-acc 'secret-password 'withdraw) 40))
  ;;; Neither account works with an unknown password.
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
  (test "Incorrect password"
        ((joint-acc 'some-other-password 'deposit) 50))
  ;;; Original account `acc` doesn't work with the proxy password, but the joint
  ;;; account `joint-acc` does.
  (test "Incorrect password"
        ((acc 'proxy-password 'withdraw) 20))
  (test 40
        ((joint-acc 'proxy-password 'withdraw) 20))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.8][Exercise 3.8.]]

#+BEGIN_SRC scheme :tangle ex-3-8.scm
  (define f
    (let ((cache '()))
      (lambda (x)
        (cond ((null? x) (set! cache '())) ; Allow cache to be cleared.
              ((not (null? cache)) 0)      ; Return 0 if cache isn't clear.
              (else (set! cache x)       ; Set cache if it isn't clear already.
                    x)))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-8-test.scm
  (use test)
  (include "ex-3-8")

  ;;; Simulate left-to-right evaluation by assigning to temporaries
  (define x (f 0))
  (define y (f 1))
  (test 0
        (+ x y))

  ;;; Reset cache
  (f '())

  ;;; Right-to-left evaluation
  (define y (f 1))
  (define x (f 0))
  (test 1
        (+ x y))
#+END_SRC


** DONE 3.2: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2][The Environment Model of Evaluation]]

*** DONE 3.2.1: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2.1][The Rules for Evaluation]]

No exercises


*** DONE 3.2.2: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2.2][Applying Simple Procedures]]

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.9][Exercise 3.9.]]

I don't want to draw, so I'll use Scheme S-expressions instead.

In general, each invocation of a procedure creates an environment containing a
reference to its enclosing environment and a list of references to its
parameters. The global environment is much the same except that has a nil
pointer for the enclosing environment since there is no enclosing
environment. In the below, I've represented each parameter as a list of the
symbol name and value, but the symbol name is only preserved here for ease of
following the examples -- it doesn't necessarily have to be kept in an actual
interpreter.

The recursive definition of ~factorial~,

#+BEGIN_SRC scheme
  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))
#+END_SRC

spawns a separate environment for each call of ~factorial~, each of which has a
reference to the global environment and the value of its one argument:

#+BEGIN_SRC scheme
  (define global-env `(() (factorial ,factorial-proc)
                          (fact-iter ,fact-iter-proc)
                          ,@intrinsic-defs))
  (define all-envs `((,global-env (n ,6))))
  (set! ,all-envs `((,global-env (n ,5)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,4)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,3)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,2)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,1)) ,all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (assert (null? all-envs))

#+END_SRC

In contrast, the iterative version,

#+BEGIN_SRC scheme
  (define (factorial n)
    (fact-iter 1 1 n))
  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
#+END_SRC

because it is tail recursive, replaces the environment of the function from
which a tail recursive call is made with the environment for the target
function of the tail recursive call. Since all function calls in both
~factorial~ and ~fact-iter~ are tail recursive, the list of environments
changes basically as described in the pseudocode below:

#+BEGIN_SRC scheme
  (define global-env `(() (factorial ,factorial-proc)
                       (fact-iter ,fact-iter-proc)
                       ,@intrinsic-defs))
  (define all-envs `((global-env (n ,6))))
  (set-car! all-envs `(global-env (product ,1)
                                  (counter ,1)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,1)
                                  (counter ,2)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,2)
                                  (counter ,3)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,6)
                                  (counter ,4)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,24)
                                  (counter ,5)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,120)
                                  (counter ,6)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,720)
                                  (counter ,7)
                                  (max-count ,6)))
  (set! all-envs (cdr all-envs))
  (assert (null? all-envs))
#+END_SRC

Notice above that we've really simulated a stack, with ~set-car!~ performing a
mutation-in-place of the top entry of the stack.

*** DONE 3.2.3: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2.3][Frames as the Repository of Local State]]

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.10][Exercise 3.10.]]

The procedure to be analyzed,

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    (let ((balance initial-amount))
      (lambda (amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))))
#+END_SRC

expands to the following when ~let~ is expanded to its underlying syntax:

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    ((lambda (balance)
       (lambda (amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds")))
     initial-amount))
#+END_SRC

Without TCE, the function returned by ~make-withdraw~ (i.e.,
~(lambda (amount) ⋯)~), has a pointer the environment of
~(lambda (balance) ⋯)~, which has a pointer to the global environment. However,
the call to ~(lambda (balance) ⋯)~ is in tail position, so it replaces the
environment formed by the call of ~make-withdraw~. When the returned
~(lambda (amount) ⋯)~ is called, it therefore has a pointer to the environment
of ~(lambda (balance) ⋯)~, which points to the global environment.

*** DONE 3.2.4: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2.4][Internal Definitions]]

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.11][Exercise 3.11.]]

The environment for ~make-account~ points to the global environment. In this
environment exist references to the argument ~balance~ as well as the local
procedures ~withdraw~, ~deposit~, and ~dispatch~. Each local procedure points to
the environment of ~make-account~ (and retains references to its own arguments
as well). It's necessary to keep references to the local procedures in the
environment of ~make-account~ so that ~dispatch~ can resolve the references to
~withdraw~ and ~deposit~ in its body. (On the other hand, it should not
strictly be necessary to retain a reference to ~dispatch~ since a reference to
that procedure is returned.)


** DONE 3.3: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3][Modeling with Mutable Data]]

*** DONE 3.3.1: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1][Mutable List Structure]]

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.12][Exercise 3.12.]]

#+BEGIN_SRC scheme :tangle ex-3-12-test.scm
  (use test)

  ;;; Nondestructive
  (define x (list 'a 'b))
  (define y (list 'c 'd))
  (define z (append x y))

  (test z
        '(a b c d))
  (test (cdr x)
        '(b))

  ;;; Destructive
  (define w (append! x y))

  (test w
        '(a b c d))
  (test (cdr w)
        '(b c d))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.13][Exercise 3.13.]]

When a circular list is constructed from a linear list, the last cons cell in
the original list has its cdr set to the head of the original list. Thus,
~(null? (cdr x))~ never returns true for any element ~x~ in the list and the
~last-pair~ procedure loops around the list forever.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.14][Exercise 3.14.]]

~mystery~ reverses a list destructively:

#+NAME: ex-3-14
#+BEGIN_SRC scheme
  (define (mystery x)
    (define (loop x y)
      (if (null? x)
          y
          (let ((temp (cdr x)))
            (set-cdr! x y)
            (loop temp x))))
    (loop x '()))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-14-test.scm
  (use test)
  <<ex-3-14>>
  (define v '(a b c d))
  (define w (mystery v))
  (test w
        '(d c b a))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.15][Exercise 3.15.]]

In Figure 3.16, modify the diagram so that the arrow pointing to the ~'a~ cell
now points to a ~'wow~ cell.

In Figure 3.17, only the arrow pointing to ~'a~ from below now points to ~'wow~
-- the arrow from above continues to point to ~'a~.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.16][Exercise 3.16.]]

Ben Bitdiddle's flawed procedure:

#+NAME: ex-3-16-count-pairs
#+BEGIN_SRC scheme
  (define (count-pairs x)
    (if (not (pair? x))
        0
        (+ (count-pairs (car x))
           (count-pairs (cdr x))
           1)))
#+END_SRC

We define some test data here, containing a simple list, some more complex
linked structures, and a list containing a cycle, for this and the rest of the
exercises in this section.

#+BEGIN_SRC scheme :tangle sharing-identity-test-data.scm
  (define pairs-3 '(a b c))
  (define pairs-4
    (begin
      (define x '(a b c))
      (set-car! x (cddr x))
      x))
  (define pairs-7
    (begin
      (define x '(a b c))
      (set-car! x (cdr x))
      (set-car! (cdr x) (cddr x))
      x))
  (define pairs-cycle
    (begin
      (define x '(a b c))
      (set-cdr! (cddr x) x)
      x))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-16-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (test 0
        (count-pairs '()))
  (test 0
        (count-pairs 'a))
  (test 3
        (count-pairs pairs-3))
  (test 4
        (count-pairs pairs-4))
  (test 7
        (count-pairs pairs-7))
  ;;; No test for pairs-cycle, because a cycle causes this version of count-pairs
  ;;; to run forever.
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.17][Exercise 3.17.]]

#+BEGIN_SRC scheme :tangle ex-3-17-count-pairs.scm
  (define (count-pairs x)
    (let ((seens '()))
      (let inner ((x x))
        (if (or (not (pair? x))
                (memq x seens))
            0
            (begin
              (set! seens (cons x seens))
              (+ (inner (car x))
                 (inner (cdr x))
                 1))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-17-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-17-count-pairs")
  (test 0
        (count-pairs '()))
  (test 0
        (count-pairs 'a))
  (test 3
        (count-pairs pairs-3))
  (test 4
        (count-pairs pairs-4))
  (test 7
        (count-pairs pairs-7))
  (test 3
        (count-pairs pairs-cycle))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.18][Exercise 3.18.]]

#+BEGIN_SRC scheme :tangle ex-3-18.scm
  (define (cycle? x)
    (let ((seens '()))
      (let inner ((x x))
        (cond ((not (pair? x)) #f)
              ((memq x seens) #t)
              (else (set! seens (cons x seens))
                    (inner (cdr x)))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-18-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-18")
  (test #f
        (cycle? '()))
  (test #f
        (cycle? 'a))
  (test #f
        (cycle? pairs-3))
  (test #f
        (cycle? pairs-4))
  (test #f
        (cycle? pairs-7))
  (test #t
        (cycle? pairs-cycle))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.19][Exercise 3.19.]]

Use [[http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare][Floyd's cycle-finding algorithm]], also known as the "tortoise-and-hare"
algorithm. Two pointers to the list elements are kept. The "tortoise" is
advanced by 1 position for every call, while the "hare" is advanced by 2
positions. If a cycle exists, the tortoise and hare will eventually run into
other (i.e., compare equal via ~eq?~ after the initial call).

#+BEGIN_SRC scheme :tangle ex-3-19.scm
  (define (cycle? x)
    (define (cdr-safe x)
      (if (not (pair? x))
          x
          (cdr x)))
    (define (cddr-safe x)
      (if (not (pair? x))
          x
          (cdr-safe (cdr x))))
    (define (inner tortoise hare first-run)
      (cond ((any (lambda (p) (not (pair? p)))
                  (list tortoise hare))
             #f)
            ((and (not first-run)
                  (eq? tortoise hare))
             #t)
            (else (inner (cdr-safe tortoise)
                         (cddr-safe hare)
                         #f))))
    (inner x x #t))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-19-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-19")
  (test #f
        (cycle? '()))
  (test #f
        (cycle? 'a))
  (test #f
        (cycle? pairs-3))
  (test #f
        (cycle? pairs-4))
  (test #f
        (cycle? pairs-7))
  (test #t
        (cycle? pairs-cycle))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.20][Exercise 3.20.]]

Given the implementation of the primitive list functions in terms of
dispatching, now including mutation,

#+BEGIN_SRC scheme :tangle ex-3-20-cons-dispatch.scm
  ;;; -d for dispatching.
  (define (cons-d x y)
    (define (set-x! v) (set! x v))
    (define (set-y! v) (set! y v))
    (define (dispatch m)
      (cond ((eq? m 'car) x)
            ((eq? m 'cdr) y)
            ((eq? m 'set-car!) set-x!)
            ((eq? m 'set-cdr!) set-y!)
            (else (error "Undefined operation -- CONS" m))))
    dispatch)
  (define (car-d z) (z 'car))
  (define (cdr-d z) (z 'cdr))
  (define (set-car-d! z new-value)
    ((z 'set-car!) new-value)
    z)
  (define (set-cdr-d! z new-value)
    ((z 'set-cdr!) new-value)
    z)
#+END_SRC

we can understand the environment diagram of the following code

#+BEGIN_SRC scheme :tangle ex-3-20-test.scm
  (use test)
  (include "ex-3-20-cons-dispatch")
  (define x (cons 1 2))
  (define z (cons x x))
  (set-car! (cdr z) 17)
  (test 17
        (car x))
#+END_SRC

as follows:

- Every call to ~cons-d~ returns a ~dispatch~ closure which has a pointer to
  the environment of the ~cons-d~ closure, which holds the arguments to
  ~cons-d~, ~x~ and ~y~.
- All messages to the ~dispatch~ closure read or write to the environment of
  the original ~cons-d~ call, which is preserved by the link from ~dispatch~.
- ~x~ and ~y~, the arguments to ~cons-d~, are acted upon in precisely the same
  way as the ~car~ and ~cdr~ of a normal ~cons~ cell.


*** DONE 3.3.2: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.2][Representing Queues]]

#+BEGIN_SRC scheme :tangle queue-cons.scm
  (define (front-ptr queue) (car queue))
  (define (rear-ptr queue) (cdr queue))
  (define (set-front-ptr! queue item) (set-car! queue item))
  (define (set-rear-ptr! queue item) (set-cdr! queue item))
  (define (empty-queue? queue) (null? (front-ptr queue)))
  (define (make-queue) (cons '() '()))
  (define (front-queue queue)
    (if (empty-queue? queue)
        (error "FRONT called with an empty queue" queue)
        (car (front-ptr queue))))
  (define (insert-queue! queue item)
    (let ((new-pair (cons item '())))
      (cond ((empty-queue? queue)
             (set-front-ptr! queue new-pair)
             (set-rear-ptr! queue new-pair)
             queue)
            (else
             (set-cdr! (rear-ptr queue) new-pair)
             (set-rear-ptr! queue new-pair)
             queue))))
  (define (delete-queue! queue)
    (cond ((empty-queue? queue)
           (error "DELETE! called with an empty queue" queue))
          (else
           (set-front-ptr! queue (cdr (front-ptr queue)))
           queue)))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.21][Exercise 3.21.]]

The standard Lisp printer recursively prints the contents of a list (or cons
cell) in order. In particular, this implementation does not treat two pointers
to the same underlying object specially. With the mutation used to implement
the queue, ~(rear-ptr queue)~ points to the last item in the queue, while
~(front-ptr queue)~ points to the head of the list that actually stores the
items in the queue. Since the last item is in the queue list, it is printed
twice, once as an element of the list and once as a lone item. (As an aside, it
appears that the queue is keeping the last item alive longer than necessary
through the pointer ~rear-ptr~ after the queue is empty. The implementation
should set ~rear-ptr~ to nil (or some other small, primitive, immutable value)
to fix this.)

Since ~front-ptr~ returns a pointer to the list that represents the queue, all
we need to do to print the queue properly is print that list:

#+BEGIN_SRC scheme :tangle ex-3-21-print-queue.scm
  (define (print-queue q)
    (display (front-ptr q)))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.22][Exercise 3.22.]]

A straightforward implementation uses the same approach as implementing cons
cells using dispatch -- the arguments to the constructor, retained by the
~dispatch~ closure, are manipulated by subprocedures in ~dispatch~ in the same
way as the car and cdr of the cons cell we use to implement the queue above.

#+BEGIN_SRC scheme :tangle ex-3-22-queue-dispatch.scm
  (define (make-queue-d)
    (let ((front-ptr '())
          (rear-ptr '()))
      ;; Some of these procedures are defined to return a reference to the queue
      ;; on which the procedure was invoked. For consistency, we define all these
      ;; procedures to take `queue`.
      (define (set-front-ptr! queue item) (set! front-ptr item))
      (define (set-rear-ptr! queue item) (set! rear-ptr item))
      (define (empty-queue? queue) (null? front-ptr))
      (define (front-queue queue)
        (if (empty-queue? queue)
            (error "FRONT called with an empty queue" queue)
            (car front-ptr)))
      (define (insert-queue! queue item)
        (let ((new-pair (cons item '())))
          (cond ((empty-queue? queue)
                 (set-front-ptr! queue new-pair)
                 (set-rear-ptr! queue new-pair)
                 queue)
                (else
                 (set-cdr! rear-ptr new-pair)
                 (set-rear-ptr! queue new-pair)
                 queue))))
      (define (delete-queue! queue)
        (cond ((empty-queue? queue)
               (error "DELETE! called with an empty queue" queue))
              (else
               (set-front-ptr! queue (cdr front-ptr))
               ;; If the queue becomes empty, clear `rear-ptr` to avoid
               ;; unnecessarily retaining a reference to it.
               (when (null? front-ptr)
                     (set-rear-ptr! queue '()))
               queue)))
      (define (dispatch m)
        (cond ((eq? m 'front-ptr) front-ptr)
              ((eq? m 'rear-ptr) rear-ptr)
              ((eq? m 'set-front-ptr!)
               (lambda (item) (set-front-ptr! dispatch item)))
              ((eq? m 'set-rear-ptr!)
               (lambda (item) (set-rear-ptr! dispatch item)))
              ((eq? m 'empty-queue?)
               (empty-queue? dispatch))
              ((eq? m 'front-queue)
               (front-queue dispatch))
              ((eq? m 'insert-queue!)
               (lambda (item) (insert-queue! dispatch item)))
              ((eq? m 'delete-queue!)
               (delete-queue! dispatch))
              (else
               error "Undefined operation - QUEUE" m)))
      dispatch))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-22-test.scm
  (use test)
  (include "ex-3-22-queue-dispatch")
  (define q (make-queue-d))
  ((q 'insert-queue!) 0)
  (test 0
        (q 'front-queue))
  ((q 'insert-queue!) 1)
  ((q 'insert-queue!) 2)
  (test 2
        (car (q 'rear-ptr)))
  (q 'delete-queue!)
  (test 1
        (q 'front-queue))
  (q 'delete-queue!)
  (q 'delete-queue!)
  (test #t
        (q 'empty-queue?))
  (test #t
        (null? (q 'rear-ptr)))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.23][Exercise 3.23.]]

Represent as doubly-linked list. Will need selectors for DLL:

#+BEGIN_SRC scheme :tangle ex-3-23.scm
  (define (make-deque)
    (let ((header (cons '() '())))
      ;; Internal procedures on internal representation of deque.
      (define (make-node item prev next)
        (cons (cons item prev) next))
      (define (front) (car header))
      (define (rear) (cdr header))
      (define (set-front! node) (set-car! header node))
      (define (set-rear! node) (set-cdr! header node))
      (define (item node) (caar node))
      (define (prev node) (cdar node))
      (define (next node) (cdr node))
      (define (set-prev! this that) (set-cdr! (car this) that))
      (define (set-next! this that) (set-cdr! this that))

      ;; Exported procedures
      (define (empty? self)
        (eq? (front) '()))
      (define (front-deque self)
        (item (front)))
      (define (rear-deque self)
        (item (rear)))
      (define (front-insert! self item)
        (set-front! (make-node item '() (front))))
      (define (rear-insert! self item)
        (set-rear! (make-node item (rear) '())))
      (define (front-delete! self)
        (set-front! (next (front))))
      (define (rear-delete! self)
        (set-rear! (prev (rear))))

      (define (dispatch m)
        (cond ((eq? m 'empty?) (empty? header))
              ((eq? m 'front-deque) (front-deque header))
              ((eq? m 'rear-deque) (rear-deque header))
              ((eq? m 'front-insert!) (front-insert! header item))
              ((eq? m 'rear-insert!) (rear-insert! header item))
              ((eq? m 'front-delete!) (front-delete! header))
              ((eq? m 'rear-delete!) (rear-delete! header))
              (else (error "Undefined operation -- DEQUE" m))))
      dispatch))
#+END_SRC


*** DONE 3.3.3: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.3][Representing Tables]]

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.24][Exercise 3.24.]]

#+BEGIN_SRC scheme :tangle ex-3-24.scm
  (define (make-table same-key?)
    (let ((tbl (cons '*table* '())))
      ;; Internal procedure
      (define (assoc key records)
        (cond ((null? records) #f)
              ((same-key? key (caar records)) (car records))
              (else (assoc key (cdr records)))))
      ;; Exported procedures
      (define (lookup key)
        (let ((record (assoc key (cdr tbl))))
          (if record
              (cdr record)
              #f)))
      (define (insert! key value)
        (let ((record (assoc key (cdr tbl))))
          (if record
              (set! (cdr record) value)
              (set! (cdr tbl) (cons (cons key value) (cdr tbl))))))
      ;; Dispatch
      (define (dispatch msg)
        (cond ((equal? msg 'lookup) lookup)
              ((equal? msg 'insert!) insert!)
              (else (error "TABLE -- unknown message")))))
      dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-24-test.scm
  (include "ex-3-24")
  (use test)

  (define tbl-exact (make-table (lambda (x y) (equal? x y))))
  (test #f
        ((tbl-exact 'lookup) 'foo))

  ((tbl-exact 'insert!) 'a 1)
  ((tbl-exact 'insert!) 'b 2)
  ((tbl-exact 'insert!) 'c 3)
  (test 1
        ((tbl-exact 'lookup) 'a))
  (test 2
        ((tbl-exact 'lookup) 'b))
  (test 3
        ((tbl-exact 'lookup) 'c))

  (define tbl-inexact (make-table (lambda (x y)
                                    (< (abs (- x y)) .1))))
  (test #f
        ((tbl-inexact 'lookup) 'foo))
  ((tbl-inexact 'insert!) 1.0 'x)
  (test 'x
        ((tbl-inexact 'lookup) 1.05))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.25][Exercise 3.25.]]

#+BEGIN_SRC scheme :tangle ex-3-25.scm
  (define (make-table same-key?)
    (let ((tbl (cons '*table* '())))
      (define (assoc key records)
        (cond ((null? records) #f)
              ((same-key? key (caar records)) (car records))
              (else (assoc key (cdr records)))))
      (define (lookup keys)
        (let recur ((elems (cdr tbl))
                    (keys keys))
          (let ((record (assoc (car keys) elems)))
            (if record
                (cond
                 ;; If the current key maps to a list, there must be more keys to
                 ;; continue the search.
                 ((and (pair? (cdr keys)) (pair? (cdr record)))
                  (recur (cdr record) (cdr keys)))
                 ;; Ensure that e.g. `(lookup '(a b))` does not succeed if
                 ;; `(lookup '(a))` does not return a list.
                 ((null? (cdr keys))
                  (cdr record))
                 (else #f))
                #f))))
      (define (insert! keys value)
        (when (null? keys)
              (error "INSERT! -- keys cannot be empty"))
        (let recur ((header tbl)
                    (keys keys))
          (define (recursively-insert record)
            (if (null? (cdr keys))
                (set! (cdr record) value)
                (begin
                  ;; Obliterate any non-list associated with the current key,
                  ;; since it will need to be replaced.
                  (when (not (pair? (cdr record)))
                        (set! (cdr record) '()))
                  (recur record (cdr keys)))))
          (let ((record (assoc (car keys) (cdr header))))
            (if (pair? record)
                (recursively-insert record)
                (let ((inserted (if record
                                    record
                                    (cons (car keys) '()))))
                  (when (not record)
                        (set! (cdr header) (cons inserted (cdr header))))
                  (recursively-insert inserted))))))
      (define (dispatch msg)
        (cond ((equal? msg 'lookup) lookup)
              ((equal? msg 'insert!) insert!)
              (else (error "TABLE -- unknown message"))))
      dispatch))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-25-test.scm
  (include "ex-3-25")
  (use test)

  (define (lookup tbl keys)
    ((tbl 'lookup) keys))
  (define (insert! tbl keys value)
    ((tbl 'insert!) keys value))
  (define tbl (make-table equal?))
  (test #f
        (lookup tbl '(a)))
  (test #f
        (lookup tbl '(0 1 2)))

  (insert! tbl '(a) 'foo)
  (insert! tbl '(0 1 2) 'bar)
  (test 'foo
        (lookup tbl '(a)))
  (test #f
        (lookup tbl '(a b)))
  (test 'bar
        (lookup tbl '(0 1 2)))
  (test #t
        (pair? (lookup tbl '(0))))

  (insert! tbl '(a b) 'baz)
  (test 'baz
        (lookup tbl '(a b)))
  (test #t
        (pair? (lookup tbl '(a))))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.26][Exercise 3.26.]]

#+BEGIN_SRC scheme :tangle ex-3-26.scm
  (define (make-table cmp)
    (let ((tbl (cons '*table* '())))
      ;; Accessor functions
      (define (key node) (caar node))
      (define (value node) (cdar node))
      (define (left node) (cadr node))
      (define (right node) (cddr node))
      (define (set-value! node v) (set-cdr! (car node) v))
      (define (set-left! node n) (set-car! (cdr node) n))
      (define (set-right! node n) (set-cdr! (cdr node) n))
      (define (make-node k v) (cons #|payload|#  (cons k v)
                                    #|children|# (cons '() '())))

      (define (lookup k)
        (let recur ((node (cdr tbl)))
          (cond ((null? node) #f)
                ((< (cmp k (key node)) 0) (recur (left node)))
                ((> (cmp k (key node)) 0) (recur (right node)))
                (else (value node)))))
      (define (insert! k v)
        (set! (cdr tbl)
              (let recur ((node (cdr tbl)))
                (cond ((null? node) (make-node k v))
                      ((< (cmp k (key node)) 0)
                       (set-left! node (recur (left node)))
                       node)
                      ((> (cmp k (key node)) 0)
                       (set-right! node (recur (right node)))
                       node)
                      (else (set-value! node v)
                            node)))))
      (define (dispatch msg)
        (cond ((equal? msg 'lookup) lookup)
              ((equal? msg 'insert!) insert!)
              (else (error "TABLE -- unknown message"))))
      dispatch))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-26-test.scm
  (include "ex-3-26")
  (use test)

  (define (lookup tbl key)
    ((tbl 'lookup) key))
  (define (insert! tbl key value)
    ((tbl 'insert!) key value))
  (define tbl (make-table (lambda (x y)
                            (cond ((< x y) -1)
                                  ((> x y) 1)
                                  (else 0)))))

  (test #f
        (lookup tbl 0))
  (insert! tbl 0 'foo)
  (test 'foo
        (lookup tbl 0))
  (test #f
        (lookup tbl 1))
  (insert! tbl -3 'bar)
  (test 'foo
        (lookup tbl 0))
  (test 'bar
        (lookup tbl -3))
#+END_SRC

**** HOLD [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.27][Exercise 3.27.]]                                               :HOLD:
     - State "HOLD"       from "TODO"       [2015-01-18 Sun 19:09]

Ehh...


*** DONE 3.3.4: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.4][A Simulator for Digital Circuits]]

Some common procedures, most copied from the book.

#+BEGIN_SRC scheme :tangle logic-gates-common.scm
  (include "logic-gates-agenda")

  (define (make-wire)
    (let ((signal-value 0) (action-procedures '()))
      (define (set-my-signal! new-value)
        (if (not (= signal-value new-value))
            (begin (set! signal-value new-value)
                   (call-each action-procedures))
            'done))
      (define (accept-action-procedure! proc)
        (set! action-procedures (cons proc action-procedures))
        (proc))
      (define (dispatch m)
        (cond ((eq? m 'get-signal) signal-value)
              ((eq? m 'set-signal!) set-my-signal!)
              ((eq? m 'add-action!) accept-action-procedure!)
              (else (error "Unknown operation -- WIRE" m))))
      dispatch))
  (define (call-each procedures)
    (if (null? procedures)
        'done
        (begin
          ((car procedures))
          (call-each (cdr procedures)))))
  (define (get-signal wire)
    (wire 'get-signal))
  (define (set-signal! wire new-value)
    ((wire 'set-signal!) new-value))
  (define (add-action! wire action-procedure)
    ((wire 'add-action!) action-procedure))


#+END_SRC

#+BEGIN_SRC scheme
  (define (make-probe log)
    (define (probe name wire)
      (add-action! wire
                   (lambda ()
                     (cons (list name
                                 (current-time the-agenda)
                                 (get-signal wire))
                           log))))
    probe)

#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.28][Exercise 3.28.]]

#+NAME: ex-3-28-or-gate
#+BEGIN_SRC scheme
  (define (or-gate a1 a2 output)
    (define (logical-or s1 s2)
      (define (signal-valid s)
        (or (= s 0) (= s 1)))
      (cond ((not (signal-valid s1)) (error "Invalid signal on a1" s1))
            ((not (signal-valid s2)) (error "Invalid signal on a2" s2))
            ((and (= s1 0) (= s2 0)) 0)
            ((and (= s1 1) (= s2 0)) 1)
            ((and (= s1 0) (= s2 1)) 1)
            ((and (= s1 1) (= s2 1)) 1)
            (else (error "Unreachable"))))
    (define (or-action-procedure)
      (let ((new-value
             (logical-or (get-signal a1) (get-signal a2))))
        (after-delay or-gate-delay
                     (lambda ()
                       (set-signal! output new-value)))))
    (add-action! a1 or-action-procedure)
    (add-action! a2 or-action-procedure)
    'ok)
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.29][Exercise 3.29.]]

We use this result from De Morgan's laws

\begin{equation*}
a \vee b = \neg \left( \neg a \wedge \neg b \right)
\end{equation*}

to implement the or-gate in terms of and-gates and inverters:

#+BEGIN_SRC scheme
  (define (or-gate a1 a2 output)
    (let ((na (make-wire)) (nb (make-wire))
          (c (make-wire)))
      (inverter a na)
      (inverter b nb)
      (and-gate na nb c)
      (inverter c output)
      'ok))
#+END_SRC

This construction is simpler than the primitive and-gate constructed
above. However, its propagation times are more complex -- the formula for the
total propagation time \(t_{\mathrm{total}}\), where \(t_{x}\) is the
propagation delay due to the gate that begins the wire \(x\), is

\begin{equation*}
t_{\mathrm{total}} = \t_{output} + \t_{c} + \max{(na, nb)}
\end{equation*}

This may be a larger delay than that of the primitive or-gate if the primitive
gate can be manufactured to have a delay similar to that of the and-gate, for
example. On the other hand, if the composition of inverters and and-gates has
enough of an advantage, such as individual speed or cost, over a single
primitive or-gate or-gate for whatever reason, the composed or-gate may still
be preferable.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.30][Exercise 3.30.]]

Straightforward implementation of the diagram:

#+BEGIN_SRC scheme :tangle ex-3-30.scm
  (define (ripple-carry-adder as bs ss carry)
    (let ((cs
           ;; Construct the n internal wires needed to link the full-adders
           ;; internally and verify that as, bs, and ss all have the same length.
           (let make-cs ((as as) (bs bs) (ss ss) (cs '()))
                (cond ((and (null? as) (null? bs) (null? ss)) cs)
                      ((null? as) (error "Too few bits in as"))
                      ((null? bs) (error "Too few bits in bs"))
                      ((null? ss) (error "Too few bits in ss"))
                      (else (make-cs (cdr as) (cdr bs) (cdr ss)
                                   (cons (make-wire) cs)))))))
      (let make-adder ((as as) (bs bs) (cs cs) (ss ss) (carry carry))
        (cond ((null? as) 'ok)  ; Only test `as` since all lists have same length.
            (else (full-adder (car as) (car bs) (car cs) (car ss) carry)
                  (make-adder (cdr as) (cdr bs) (cdr cs) (cdr ss) (car cs)))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-30-test.scm
  (include "ex-3-30")
  (use test)
#+END_SRC

The delay is troublesome -- \(n \mathrm{delay}_{\mathrm{full-adder}}\).

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.31][Exercise 3.31.]]

If the procedure is merely added without executing it, the state of the circuit
can become inconsistent until the first change to the inputs is made. For
example, consider the execution of ~(half-adder a b s c)~, with ~a~ and ~b~
initially ~1~ and ~s~ and ~c~ initially ~0~. Without the argument ~proc~ being
called immediately on the call to ~accept-action-procedure!~, no calls to
~set-my-signal!~, which is the only means now to call any of the
~action-procedures~, are made, so ~s~ and ~c~ remain set to ~0~ until the first
input is set.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.32][Exercise 3.32.]]

It is necessary to execute the events in the same queue (i.e., those that take
place "at the same time") in FIFO order because it is in fact the case that the
and-gate observes the change to ~a1~ while it is scheduling ~a2~.

#+NAME: FIFO-agenda
#+BEGIN_SRC scheme
  (define agenda
    '((0 ((lambda () (set-a1! 0))
          (lambda () (set-a2! 1))))
      ;; Stable value of and-gate output after initialization.
      (5 ((lambda () (assert-output 0))))
      ;; Change a1 and a2 simultaneously.
      (10 ((lambda () (set-a1! 1))
           (lambda () (set-a2! 0))))
      (13 ((lambda ()
             ;; Lexical capture of new-value at t = 10 after setting just a1.
             (set-output! 1))
           (lambda ()
             ;; Lexical capture of new-value at t = 10 after setting a1 followed
             ;; by a2.
             (set-output! 0))))))
#+END_SRC

#+NAME: LIFO-agenda
#+BEGIN_SRC scheme
  (define agenda
    '((0 ((lambda () (set-a1! 0))
          (lambda () (set-a2! 1))))
      ;; Stable value of and-gate output after initialization.
      (5 ((lambda () (assert-output 0))))
      ;; Change a1 and a2 simultaneously.
      (10 ((lambda () (set-a1! 1))
           (lambda () (set-a2! 0))))
      (13 ((lambda ()
             ;; Lexical capture of new-value at t = 10 after setting a1 followed
             ;; by a2.
             (set-output! 0))
           (lambda ()
             ;; Lexical capture of new-value at t = 10 after setting just a1.
             ;; THIS IS THE INCORRECT RESULT.
             (set-output! 1))))))
#+END_SRC

*** DONE 3.3.5: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.4][Propagation of Constraints]]

Implementation of constraint objects from book. Includes the primitive
procedures

#+BEGIN_SRC scheme :tangle constraint-primitive.scm
  ;;; Primitive connector construction
  (define (make-connector)
    (let ((value #f) (informant #f) (constraints '()))
      (define (set-my-value newval setter)
        (cond ((not (has-value? me))
               (set! value newval)
               (set! informant setter)
               (for-each-except setter
                                inform-about-value
                                constraints))
              ((not (= value newval))
               (error "Contradiction" (list value newval)))
              (else 'ignored)))
      (define (forget-my-value retractor)
        (if (eq? retractor informant)
            (begin (set! informant #f)
                   (for-each-except retractor
                                    inform-about-no-value
                                    constraints))
            'ignored))
      (define (connect new-constraint)
        (if (not (memq new-constraint constraints))
            (set! constraints
                  (cons new-constraint constraints)))
        (if (has-value? me)
            (inform-about-value new-constraint))
        'done)
      (define (me request)
        (cond ((eq? request 'has-value?)
               (if informant #t #f))
              ((eq? request 'value) value)
              ((eq? request 'set-value!) set-my-value)
              ((eq? request 'forget) forget-my-value)
              ((eq? request 'connect) connect)
              (else (error "Unknown operation -- CONNECTOR"
                           request))))
      me))

  ;;; Convenience procedures for make-connector.
  (define (for-each-except exception procedure list)
    (define (loop items)
      (cond ((null? items) 'done)
            ((eq? (car items) exception) (loop (cdr items)))
            (else (procedure (car items))
                  (loop (cdr items)))))
    (loop list))
  (define (has-value? connector)
    (connector 'has-value?))
  (define (get-value connector)
    (connector 'value))
  (define (set-value! connector new-value informant)
    ((connector 'set-value!) new-value informant))
  (define (forget-value! connector retractor)
    ((connector 'forget) retractor))
  (define (connect connector new-constraint)
    ((connector 'connect) new-constraint))
  (define (inform-about-value constraint)
    (constraint 'I-have-a-value))
  (define (inform-about-no-value constraint)
    (constraint 'I-lost-my-value))
#+END_SRC

and some commonly used constraints, implemented in terms of the primitives:

#+BEGIN_SRC scheme :tangle constraint-common.scm
  (include "constraint-primitive")

  ;;; Adder constraint between summands and sum
  (define (adder a1 a2 sum)
    (define (process-new-value)
      (cond ((and (has-value? a1) (has-value? a2))
             (set-value! sum
                         (+ (get-value a1) (get-value a2))
                         me))
            ((and (has-value? a1) (has-value? sum))
             (set-value! a2
                         (- (get-value sum) (get-value a1))
                         me))
            ((and (has-value? a2) (has-value? sum))
             (set-value! a1
                         (- (get-value sum) (get-value a2))
                         me))))
    (define (process-forget-value)
      (forget-value! sum me)
      (forget-value! a1 me)
      (forget-value! a2 me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
             (process-new-value))
            ((eq? request 'I-lost-my-value)
             (process-forget-value))
            (else
             (error "Unknown request -- ADDER" request))))
    (connect a1 me)
    (connect a2 me)
    (connect sum me)
    me)

  ;;; Multiplier constraint between multiplicands and product.
  (define (multiplier m1 m2 product)
    (define (process-new-value)
      (cond ((or (and (has-value? m1) (= (get-value m1) 0))
                 (and (has-value? m2) (= (get-value m2) 0)))
             (set-value! product 0 me))
            ((and (has-value? m1) (has-value? m2))
             (set-value! product
                         (* (get-value m1) (get-value m2))
                         me))
            ((and (has-value? product) (has-value? m1))
             (set-value! m2
                         (/ (get-value product) (get-value m1))
                         me))
            ((and (has-value? product) (has-value? m2))
             (set-value! m1
                         (/ (get-value product) (get-value m2))
                         me))))
    (define (process-forget-value)
      (forget-value! product me)
      (forget-value! m1 me)
      (forget-value! m2 me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
             (process-new-value))
            ((eq? request 'I-lost-my-value)
             (process-forget-value))
            (else
             (error "Unknown request -- MULTIPLIER" request))))
    (connect m1 me)
    (connect m2 me)
    (connect product me)
    me)

  ;;; Constrain connector to a constant
  (define (constant value connector)
    (define (me request)
      (error "Unknown request -- CONSTANT" request))
    (connect connector me)
    (set-value! connector value me)
    me)

  ;;; Print a message about setting or unsetting of a connector (e.g., for
  ;;; testing).
  (define (probe name connector)
    (define (print-probe value)
      (display "Probe: ")
      (display name)
      (display " = ")
      (display value)
      (newline))
    (define (process-new-value)
      (print-probe (get-value connector)))
    (define (process-forget-value)
      (print-probe "?"))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
             (process-new-value))
            ((eq? request 'I-lost-my-value)
             (process-forget-value))
            (else
             (error "Unknown request -- PROBE" request))))
    (connect connector me)
    me)
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.33][Exercise 3.33.]]

#+BEGIN_SRC scheme :tangle ex-3-33.scm
  (define (averager a b c)
    (let ((half (make-connector))
          (sum (make-connector)))
      (constant 0.5 half)
      (adder a b sum)
      (multiplier half sum c)
      'ok))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.34][Exercise 3.34.]]

The procedure suggested by Louis won't work when propagation from the
product to the multiplicands is needed. ~multiplier~ needs at least two of
~m1~, ~m2~, and ~product~ to be set in order to propagate the constraint from
the set values to the unset value. However, if one of the multiplicands is
unset, both are, a situation that ~multiplier~ can't handle.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.35][Exercise 3.35.]]

Straightforward implementation based on ~multiplier~:

#+BEGIN_SRC scheme :tangle ex-3-35.scm
  (define (squarer a b)
    (define (process-new-value)
      (if (has-value? b)
          (if (< (get-value b) 0)
              (error "square less than 0 -- SQUARER" (get-value b))
              (set-value! a (sqrt b)))
          (let ((aval (get-value a)))
            (set-value! b (* aval aval))))
    (define (process-forget-value)
      (forget-value! b me)
      (forget-value! a me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
             (process-new-value))
            ((eq? request 'I-lost-my-value)
             (process-forget-value))
            (else
             (error "Unknown request -- SQUARER" request))))
    (connect a me)
    (connect b me)
    me)
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.36][Exercise 3.36.]]

Do in class.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.37][Exercise 3.37.]]

The expression-oriented constraint adder is defined thus in the book:

#+NAME: constraint-adder-expression
#+BEGIN_SRC scheme
  (define (c+ x y)
    (let ((z (make-connector)))
      (adder x y z)
      z))
#+END_SRC

We define similar procedures for subtraction, multiplication, division, and
constant values:

#+BEGIN_SRC scheme :tangle ex-3-37.scm
  (include "constraint-common")

  <<constraint-adder-expression>>

  ;;; Constant
  (define (cv x)
    (let ((z (make-connector)))
      (constant x z)
      z))

  ;;; Subtraction
  (define (c- x y)
    ;; $x - y = z \Rightarrow x = y + z$ to avoid having to introduce an
    ;; additional multiplier and constant constraint.
    (let ((z (make-connector)))
      (adder y z x)
      z))

  ;;; Multiplication
  (define (c* x y)
    (let ((z (make-connector)))
      (multiplier x y z)
      z))

  ;;; Division
  (define (c/ x y)
    ;; $x / y = z \Rightarrow x = y * z$ to avoid having to implement division as
    ;; a primitive constraint. Pray that $y \neq 0$.
    (let ((z (make-connector)))
      (multiplier y z x)
      z))
#+END_SRC


** TODO 3.4: Concurrency: Time Is of the Essence

*** DONE Read Section 3.4
    SCHEDULED: <2014-11-22 Sat>
    - State "DONE"       from "STARTED"    [2014-11-22 Sat 15:07]
    CLOCK: [2014-11-22 Sat 14:43]--[2014-11-22 Sat 15:07] =>  0:24
    - State "STARTED"    from "TODO"       [2014-11-22 Sat 14:42]
    [2014-11-22 Sat]

*** TODO 3.4.1: The Nature of Time in Concurrent Systems

Complexity of concurrent systems comes from:

- Dependence of ordering of events in a system with mutation.
- Reduced ability to control ordering of events, and difficulty in mentally
  taking this into account.

Concurrency models:

- No two operations on any shared state variable can occur at the same
  time. Too strict for most uses (for example, implies that only one
  transaction can occur at a time in a bank system).
- System must proceed as if events had been executed sequentially in /some/
  order (not guaranteed what order is used).
  - There can still be more than one "correct" answer -- may need to restrict
    some parts of the program further depending on requirements.

   CLOCK: [2014-11-22 Sat 16:42]--[2014-11-22 Sat 17:09] =>  0:27
   - State "STARTED"    from "STARTED"    [2014-11-22 Sat 16:41] \\
   - State "STARTED"    from "TODO"       [2014-11-22 Sat 14:26]
     Want SRFI-18 to support concurrency.
   :PROPERTIES:
   :Effort:   0:30
   :END:
   [2014-11-22 Sat]

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.38][Exercise 3.38.]]

a. There are 6 combinations of Peter (A), Paul (B), and Mary (C):

   | Order     | Final amount |
   |-----------+--------------|
   | (A, B, C) |           45 |
   | (A, C, B) |           35 |
   | (B, A, C) |           45 |
   | (B, C, A) |           50 |
   | (C, A, B) |           40 |
   | (C, B, A) |           40 |

b. For transactions A and B, there are 3 steps:

   - Read the current balance from the shared account [Xr].
   - Perform the calculation.
   - Write the new balance to the shared account [Xw].

   However, transaction C reads the shared variable ~balance~ twice, so there
   are 5 steps:

   - Read the current balance from the shared account [Cr1].
   - Perform the division.
   - Read the current balance from the shared account [Cr2].
   - Perform the subtraction.
   - Write the new balance to the shared account [Cw].

   The calculations don't modify a shared variable, so the relevant
   combinations for each transaction are combinations of Ar, Aw, Br, Bw, Cr1,
   Cr2, and Cw, with the constraint that \(t(Ar) \leq t(Aw)\),
   \(t(Br) \leq t(Bw)\), and \(t(Cr1) \leq t(Cr2) \leq t(Cw)\) or
   \(t(Cr2) \leq t(Cr1) \leq t(Cw)\).

*** TODO 3.4.2: Mechanisms for Controlling Concurrency

There are too many possible orderings of concurrent processes to ensure a
single answer or to analyze in many cases.

Serializer:
- Ensures that only one procedure under the control of the serializer can be
  executed at a time.
- Example: In the below, ~foo~ and ~bar~ are guaranteed to not execute at the
  same time (i.e., their execution is /serialized/).

  #+BEGIN_SRC scheme
    (define s (make-serializer))
    (parallel-execute (s (foo))
                      (s (bar)))
  #+END_SRC

- Implemented in terms of /mutexes/.
- Mutex implemented as a spin lock using a test-and-set instruction.

Here's an implementation of the threading tools ~parallel-execute~ and
~make-serializer~ using SRFI-18 mutexes and threads:

#+BEGIN_SRC scheme :tangle concurrency.scm
  (use srfi-18)

  (define (make-serializer)
    (let ((mutex (make-mutex)))
      (lambda (p)
        (define (serialized-p . args)
          (mutex-lock! mutex)
          (let ((val (apply p args)))
            (mutex-unlock! mutex)
            val))
        serialized-p)))

  (define (parallel-execute . fs)
    (let ((ts (map make-thread fs)))
      (for-each thread-start! ts)
      (for-each thread-join! ts)
      '()))
#+END_SRC

   - State "HOLD"       from "STARTED"    [2014-12-10 Wed 19:54] \\
     Do at some point
   CLOCK: [2014-12-07 Sun 23:25]--[2014-12-07 Sun 23:48] =>  0:23
   - State "STARTED"    from "STARTED"    [2014-11-22 Sat 17:31] \\
     Implemented those two functions.
   CLOCK: [2014-11-22 Sat 17:11]--[2014-11-22 Sat 17:30] =>  0:19
   - State "STARTED"    from "TODO"       [2014-11-22 Sat 17:11]
   Need to implement ~make-serializer~ and perhaps ~parallel-execute~.
   :PROPERTIES:
   :Effort:   3:00
   :END:
   [2014-11-22 Sat]

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.39][Exercise 3.39.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.40][Exercise 3.40.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.41][Exercise 3.41.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.42][Exercise 3.42.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.43][Exercise 3.43.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.44][Exercise 3.44.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.45][Exercise 3.45.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.46][Exercise 3.46.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.47][Exercise 3.47.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.48][Exercise 3.48.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%25_thm_3.49][Exercise 3.49.]]

** TODO 3.5: Streams

Basic stream procedures used throughout the section.

#+BEGIN_SRC scheme :tangle stream.scm
  <<stream-primitives>>
  <<stream-fold>>

  (define (stream-ref s n)
    (if (= n 0)
        (stream-car s)
        (stream-ref (stream-cdr s) (- n 1))))
  <<stream-map-poly>>
  (define (stream-for-each proc s)
    (if (stream-null? s)
        'done
        (begin (proc (stream-car s))
               (stream-for-each proc (stream-cdr s)))))
  (define (stream-filter proc s)
    (cond ((stream-null? s) the-empty-stream)
          ((proc (stream-car s))
           (cons-stream (stream-car s)
                        (stream-filter proc (stream-cdr s))))
          (else
           (stream-filter proc (stream-cdr s)))))
  (define (display-line x)
    (newline)
    (display x))
  (define (display-stream s)
    (stream-for-each display-line s))
  (define (stream-enumerate-interval low high)
    (if (> low high)
        the-empty-stream
        (cons-stream
         low
         (stream-enumerate-interval (+ low 1) high))))
#+END_SRC

We start with the primitive procedures on the stream data type:

#+NAME: stream-primitives
#+BEGIN_SRC scheme
  (define the-empty-stream 'the-empty-stream)
  (define (stream-null? s) (eq? s the-empty-stream))
  (define-syntax cons-stream
    (syntax-rules ()
      ((cons-stream a b)
       (cons a (delay b)))))
  (define (stream-car stream) (car stream))
  (define (stream-cdr stream) (force (cdr stream)))
#+END_SRC

Another very useful and generally-applicable stream function is ~fold~. In
fact, both ~map~ and ~filter~ can be implemented in terms of ~fold~:

#+NAME: stream-fold
#+BEGIN_SRC scheme
  (define (stream-fold kons knil . streams)
    (if (or (map stream-null? streams))
        knil
        (cons-stream (apply kons (append (map stream-car streams)
                                         knil))
                     (apply stream-fold kons knil (map stream-cdr streams)))))
#+END_SRC

*** DONE 3.5.1: Streams Are Delayed Lists
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.50][Exercise 3.50.]]

The ~apply~ procedure can be used to call a function with arguments drawn from
a list, and we can iterate along the argument streams in turn (which are all
assumed to be of the same length):

#+NAME: stream-map-poly
#+BEGIN_SRC scheme :tangle ex-3-50.scm
  (define (stream-map proc . argstreams)
    (if (stream-null? (car argstreams))
        the-empty-stream
        (cons-stream
         (apply proc (map stream-car argstreams))
         (apply stream-map
                (cons proc (map stream-cdr argstreams))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-50-test.scm
  (include "stream")
  (use test)
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.51][Exercise 3.51.]]

#+BEGIN_SRC scheme :tangle ex-3-51-test.scm
  (include "stream")
  (define (show x) (display-line x) x)
  (define x (stream-map show (stream-enumerate-interval 0 10)))
  (stream-ref x 5)
  (stream-ref x 7)
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.52][Exercise 3.52.]]

We have these definitions, which in particular include a mutating procedure
~accum~:

#+BEGIN_SRC scheme :tangle ex-3-52-test.scm
  (include "stream")
  (use test)
  (define sum 0)
  (define (accum x)
    (set! sum (+ x sum))
    sum)
  (define seq (stream-map accum (stream-enumerate-interval 1 20)))
  (define y (stream-filter even? seq))
  (define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                           seq))

  <<ex-3-52-eval-y>>
  <<ex-3-52-eval-z>>
#+END_SRC

First, we obtain the 7^{th} element of ~y~, which is the 14^{th} element of ~seq~,
obtaining the expected result of \( \sum_{i=1}^{14} i = 136 \):
#+NAME: ex-3-52-eval-y
#+BEGIN_SRC scheme
  (stream-ref y 7)
  (test 136
        sum)
#+END_SRC

Next, we look at ~z~, which should contain only those entries of ~seq~
divisible by ~5~. Since \( \sum_{i=1}^{n} i = \frac{n(n + 1)}{2} \), we expect
that both every \(i\)^{th} entry and \(i-1\)^{th} entry of
~(stream-enumerate-interval 1 20)~ should produce a corresponding entry in ~z~,
and this is what we indeed observe, finally obtaining ~(= sum 210)~.

#+NAME: ex-3-52-eval-y
#+BEGIN_SRC scheme
  (display-stream z)
  (test 210
        sum)
#+END_SRC

However, if ~delay~ did not cache its results, the mutation in ~accum~ would
cause a different result to be obtained for ~z~ (but not for ~y~, since it was
the first evaluated). The execution of ~y~ would have gone through the first 14
integers, as before, giving ~(= sum 136)~. The values of ~seq~ when ~z~ was
executed would therefore all be increased by 136, producing a different stream
for ~z~ and a final sum of \(136 + 210 = 346\).


   CLOCK: [2014-12-14 Sun 15:04]--[2014-12-14 Sun 16:11] =>  1:07
   CLOCK: [2014-12-14 Sun 15:01]--[2014-12-14 Sun 15:04] =>  0:03
   :PROPERTIES:
   :Effort:   1:00
   :END:
   [2014-11-22 Sat]

*** TODO 3.5.2: Infinite Streams

The book defines several miscellaneous procedures that are useful for exercises
in this section:

#+BEGIN_SRC scheme :tangle stream-util.scm
  (include "stream")

  (define (integers-starting-from n)
    (cons-stream n (integers-starting-from (+ n 1))))

  (define integers (integers-starting-from 1))

  (define (add-streams s1 s2)
    (stream-map + s1 s2))
  (define (scale-stream stream factor)
    (stream-map (lambda (x) (* x factor)) stream))

  <<stream-partial-sums>>
  <<stream-pairs>>
#+END_SRC

   CLOCK: [2015-01-03 Sat 20:05]--[2015-01-03 Sat 21:19] =>  1:14
   :PROPERTIES:
   :Effort:   3:00
   :END:
   [2014-11-22 Sat]

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.53][Exercise 3.53.]]

This produces a stream consisting of the powers of 2: ~1 2 4 8 16 ...~.

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.54][Exercise 3.54.]]

#+BEGIN_SRC scheme

#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.55][Exercise 3.55.]]

In order to calculate the partial sum corresponding to an element in the input
stream, you need two pieces of information: the partial sum of the elements
before this one and the element itself. This is most easily done using
recursion. The recursive function call tracks in its parameters the partial sum
of the preceding elements and the start of the remaining input stream and
returns the entire output stream.

#+NAME: stream-partial-sums
#+BEGIN_SRC scheme
  (include "stream")
  (define (partial-sums s)
    (let rec ((partial-sum 0)
              (s s))
      (if (stream-null? s)
          the-empty-stream
          (let ((new-sum (+ partial-sum (stream-car s))))
            (cons-stream new-sum
                         (rec new-sum (stream-cdr s)))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-55-test.scm
  (use test)
  (include "stream-util")

  (test 15
        (stream-ref (partial-sums integers) 4))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.56][Exercise 3.56.]]

The ~merge~ procedure combines two streams ordered in ascending order,
eliminating repetitions:

#+NAME: stream-merge
#+BEGIN_SRC scheme
  (define (merge s1 s2)
    (cond ((stream-null? s1) s2)
          ((stream-null? s2) s1)
          (else
           (let ((s1car (stream-car s1))
                 (s2car (stream-car s2)))
             (cond ((< s1car s2car)
                    (cons-stream s1car (merge (stream-cdr s1) s2)))
                   ((> s1car s2car)
                    (cons-stream s2car (merge s1 (stream-cdr s2))))
                   (else
                    (cons-stream s1car
                                 (merge (stream-cdr s1)
                                        (stream-cdr s2)))))))))
#+END_SRC

Given this, we can create ~S~, the list of integers with no prime factors but
2, 3, and 5:

#+BEGIN_SRC scheme :tangle ex-3-56.scm
  (include "stream")
  (include "stream-util")
  <<stream-merge>>

  (define S (cons-stream 1 (merge (scale-stream S 2)
                                  (merge (scale-stream S 3)
                                         (scale-stream S 5)))))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.57][Exercise 3.57.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.58][Exercise 3.58.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.59][Exercise 3.59.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.60][Exercise 3.60.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.61][Exercise 3.61.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.62][Exercise 3.62.]]
*** TODO 3.5.3: Exploiting the Stream Paradigm
    CLOCK: [2015-01-19 Mon 16:53]--[2015-01-19 Mon 17:15] =>  0:22
    CLOCK: [2015-01-19 Mon 15:27]--[2015-01-19 Mon 15:48] =>  0:21
    CLOCK: [2015-01-19 Mon 13:27]--[2015-01-19 Mon 15:27] =>  2:00

For convenience:

#+NAME: stream-pairs
#+BEGIN_SRC scheme
  (define (interleave s1 s2)
    (if (stream-null? s1)
        s2
        (cons-stream (stream-car s1)
                     (interleave s2 (stream-cdr s1)))))
  (define (pairs s t)
    (cons-stream
     (list (stream-car s) (stream-car t))
     (interleave
      (stream-map (lambda (x) (list (stream-car s) x))
                  (stream-cdr t))
      (pairs (stream-cdr s) (stream-cdr t)))))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.63][Exercise 3.63.]]

*TODO*: Explain better.

First, note that both procedures are inefficient without memoization, because
~guesses~ has to be evaluated always in Alyssa's version as well. However, with
memoization, the ~guesses~ variable is bound in the environment of
~sqrt-stream~, so the delayed cdr of the stream returned by ~cons-stream~ is
memoized after the first call.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.64][Exercise 3.64.]]

A straightforward recursive procedure:

#+BEGIN_SRC scheme :tangle ex-3-64.scm
  (include "stream")

  (define (stream-limit stream tol)
    (let rec ((stream stream)
              (previous +inf))  ; +INF is IEEE-754 positive infinity
      (if (stream-null? stream)
          (error "STREAM-LIMIT - stream exhausted without tolerance achieved")
          (let ((current (stream-car stream))
                (rest (stream-cdr stream)))
            (if (< (abs (- previous current)) tol)
                current
                (rec rest current))))))

#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.65][Exercise 3.65.]]

This is the original sequence:

#+NAME: ln2-stream
#+BEGIN_SRC scheme
  (include "stream")
  (include "stream-util")

  (define (ln2-summands)
    (cons-stream 1.0
                 (stream-map (lambda (k)
                               (* (if (even? k) -1.0 1.0)
                                  (/ 1.0 k)))
                             (integers-starting-from 2))))
  (define (ln2-stream)
    (partial-sums (ln2-summands)))
#+END_SRC

In order to accelerate the \(\ln{2}\) sequence, we use the Euler transform from
this subsection:

#+NAME: stream-euler-transform
#+BEGIN_SRC scheme
  (define (make-tableau transform s)
    (cons-stream s
                 (make-tableau transform
                               (transform s))))

  (define (accelerated-sequence transform s)
    (stream-map stream-car
                (make-tableau transform s)))

  (define (square x) (* x x))
  (define (euler-transform s)
    (let ((s0 (stream-ref s 0))           ; S_{n-1}
          (s1 (stream-ref s 1))           ; S_{n}
          (s2 (stream-ref s 2)))          ; S_{n+1}
      (cons-stream (- s2 (/ (square (- s2 s1))
                            (+ s0 (* -2 s1) s2)))
                   (euler-transform (stream-cdr s)))))
#+END_SRC

We put the sequence and the transform in the same file for ease of testing:

#+BEGIN_SRC scheme :tangle ex-3-65.scm
  <<stream-euler-transform>>
  <<ln2-stream>>
#+END_SRC

With that, we can calculate the convergence of the original sequence as well as
its acceleration one and two times. As expected, the more accelerated sequences
converge much faster---while the original sequence has not converged even after
hundreds of iterations, it only takes 10 iterations for the first accelerated
sequence to converge to the limits of floating-point accuracy, and 5 iterations
for the second accelerated sequence.

#+BEGIN_SRC scheme :tangle ex-3-65-test.scm
  (use test)
  (include "ex-3-65")

  (define orig (ln2-stream))
  (define acc1 (accelerated-sequence euler-transform orig))
  (define acc2 (accelerated-sequence euler-transform acc1))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.66][Exercise 3.66.]]

Here are the first twenty pairs:

#+BEGIN_SRC scheme :tangle ex-3-66-test.scm
  (include "stream")
  (include "stream-util")

  (test (map (lambda (i) (stream-ref (pairs integers integers) i))
             (iota 20))
        '((1 1) (1 2) (2 2) (1 3) (2 3) (1 4) (3 3) (1 5) (2 4) (1 6)
          (3 4) (1 7) (2 5) (1 8) (4 4) (1 9) (2 6) (1 10) (3 5) (1 11)))
#+END_SRC

Notice that two streams seem to be interleaved:

- A stream of pairs ~(1 k)~ in the second, fourth, etc. positions; i.e., where
  \(i\) is odd (starting from \(0\)). More
  precisely, if ~(odd? i)~, ~(stream-ref pairs-stream i)~ is
  ~(+ 1 (quotient (- i 1) 2))~.
- A stream of pairs where all pairs that sum to \(n\) are generated before those
  that sum to \(n + 1\). In these pairs, \(i\) decreases from \(\lfloor n / 2 \rfloor\) to \(2\),
  since \(i = 1\) is already taken.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.67][Exercise 3.67.]]

We proceed by induction. Consider the case where all pairs \((S_{k < i}, T_{j})\)
have been generated. Then the stream to generate consists of the following
three parts:

- The single element \((S_{i}, T_{0})\).
- The pairs of \(S_{i}\) with the rest of the elements in \(T\): \((S_{i}, T_{j > 0})\).
- The pairs the remaining elements of \(S\) with everything: \((S_{k > i}, T_{j})\).

The pair \((S_{0}, T_{0})\) is obviously in the stream to be generated, so our
construction in fact does produce all the pairs \((S_{i}, T_{j})\). The Scheme
implementation below straightforwardly generates these three parts of the
stream (see the comments):

#+BEGIN_SRC scheme :tangle ex-3-67.scm
  (include "stream")
  (include "stream-util")

  (define (both-pairs s t)
    (cons-stream
     ;; (S_{i}, T_{0})
     (list (stream-car s) (stream-car t))
     (interleave
      ;; (S_{i}, T_{j > 0})
      (stream-map (lambda (x) (list (stream-car s) x))
                  (stream-cdr t))
      ;; (S_{k > i}, T_{j})
      (both-pairs (stream-cdr s) t))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-67-test.scm
  (use test)
  (include "ex-3-67")
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.68][Exercise 3.68.]]

This does not work---it generates the list \((S_{i}, T_{j}), i \leq j\).

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.69][Exercise 3.69.]]

#+BEGIN_SRC scheme ex-3-69.scm
  (define (triples s t u)
    )
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.70][Exercise 3.70.]]

Here, we want to construct a list of all pairs \((S_{i}, T_{j})\) just as in Exercise
3.67, but we want to make sure that instead of interleaving streams one after
the other, we interleave according to whichever stream has a first element with
a smaller weight.

#+BEGIN_SRC scheme
  (include "stream")
  (include "stream-util")

  (define (merge-weighted s1 s2 weight)
    (let recur ((s1 s1) (s2 s2))
      (cond ((stream-null? s1) s2)
            ((stream-null? s2) s1)
            (else
             (let* ((s1car (stream-car s1))
                    (s2car (stream-car s2))
                    (w (weight s1car s2car))
                    (wrev (weight s2car s1car)))
               (cond ((< w wrev)
                      (cons-stream s1car (recur (stream-cdr s1) s2)))
                     ((> w wrev)
                      (cons-stream s2car (recur s1 (stream-cdr s2))))
                     (else
                      (cons-stream s1car
                                   (recur (stream-cdr s1)
                                          (stream-cdr s2))))))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-70.scm
  (define (weighted-pairs s t weight)
    (cons-stream
     ;; (S_{i}, T_{0})
     (list (stream-car s) (stream-car t))
     (merge-weighted
      ;; (S_{i}, T_{j > 0})
      (stream-map (lambda (x) (list (stream-car s) x))
                  (stream-cdr t))
      ;; (S_{k > i}, T_{j})
      (both-pairs (stream-cdr s) t)
      weight)))
#+END_SRC

Now we can compute:

a. the stream of all pairs of positive integers \((i, j)\) with \((i \leq j)\)
   ordered according to the sum \(i + j\):

   #+BEGIN_SRC scheme :tangle ex-3-70-test.scm
     (use test)
     (include "ex-3-70")

     (define stream-a (weighted-pairs integers integers <))
     (define stream-b
       (stream-filter (lambda (p)
                        (not (apply or
                                    (map (lambda (q)
                                           (= 0 (remainder p q)))
                                         '(2 3 5)))))
                      (weighted-pairs integers integers
                                      (lambda (i j)
                                        (+ (* 2 i)
                                           (* 3 j)
                                           (* 5 i j))))))
   #+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.71][Exercise 3.71.]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.72][Exercise 3.72.]]
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.73][Exercise 3.73.]]

#+BEGIN_SRC scheme :tangle stream-integral.scm
  (include "stream")
  (include "stream-util")

  (define (integral integrand initial-value dt)
    (define int
      (cons-stream initial-value
                   (add-streams (scale-stream integrand dt)
                                int)))
    int)
#+END_SRC


#+BEGIN_SRC scheme :tangle ex-3-73.scm
  (include "stream")
  (include "stream-util")

  (define (RC R C dt)
    (define (circuit i v0)
      (add-streams (scale-stream i R)
                   (integral (scale-stream i (/ 1.0 C)) v0)))
    circuit)
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.74][Exercise 3.74.]]

#+BEGIN_SRC scheme ex-3-74.scm
  (define zero-crossings
    (stream-map sign-change-detector
                sense-data
                (stream-cdr sense-data)))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.75][Exercise 3.75.]]

Alyssa wants to run the sign change detector on the smoothed stream. In other
words, the sign change detector should be run on two values: first, the average
of the current and last points; second, the average between the last and
previous-to-last points. However, Louis' program runs the sign change detector
between the average point and the previous, unsmoothed point. Here is the
correct version, which needs to preserve the average between the last and
previous-to-last points:

#+BEGIN_SRC scheme
  (define (make-zero-crossings input-stream last-value last-avpt)
    (let* ((current (stream-car input-stream))
           (avpt (/ (+ current last-value) 2)))
      (cons-stream
       (sign-change-detector avpt last-avpt)
       (make-zero-crossings
        (stream-cdr input-stream) current avpt))))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.76][Exercise 3.76.]]

Here, we exploit the inherent independence between the smoothing process and
the sign-change detection to compose the two transformations:

#+BEGIN_SRC scheme
  (define (smooth input-stream)
    (define (inner input-stream last-value)
      (let* ((current (stream-car input-stream))
             (avpt (/ (+ current last-value) 2)))
        (cons-stream avpt
                     (inner (stream-cdr input-stream) current))))
    (inner input-stream 0))

  (define zero-crossings
    (let ((s (smooth sense-stream)))
      (stream-map sign-change-detector
                  s (cdr s))))
#+END_SRC


*** DONE 3.5.4: Streams and Delayed Evaluation
    CLOCK: [2015-01-25 Sun 19:37]--[2015-01-25 Sun 20:50] =>  1:13
    CLOCK: [2015-01-19 Mon 13:19]--[2015-01-19 Mon 13:25] =>  0:06
    :PROPERTIES:
    :Effort:   2:00
    :END:

**** Code

Stream integral function from text:

#+BEGIN_SRC scheme :tangle stream-integral.scm
  (include "stream")
  (include "stream-util")

  (define (integral delayed-integrand initial-value dt)
    (define int
      (cons-stream initial-value
                   (let ((integrand (force delayed-integrand)))
                     (add-streams (scale-stream integrand dt)
                                  int))))
    int)
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.77][Exercise 3.77.]]

This should just be a matter of delaying the evaluation of ~integrand~ until
the ~cdr~ of the ~cons-stream~ is forced, the same way as is done for the
implicit definition:

#+BEGIN_SRC scheme :tangle ex-3-77.scm
  (include "stream")
  (include "stream-util")

  (define (integral delayed-integrand initial-value dt)
    (cons-stream
     initial-value
     (let ((integrand (force delayed-integrand)))
       (if (stream-null? integrand)
           the-empty-stream
           (integral
            ;; The first argument to INTEGRAL is a *delayed* integrand.
            (delay (stream-cdr integrand))
            (+ (* dt (stream-car integrand))
               initial-value)
            dt)))))

#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-77-test.scm
  (include "ex-3-77")
  (use test)

  (define (solve f y0 dt)
    (define y (integral (delay dy) y0 dt))
    (define dy (stream-map f y))
    y)

  (test 2.716924
        (stream-ref (solve (lambda (y) y) 1 0.001) 1000))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.78][Exercise 3.78.]]

Straightforward encoding of the diagram in the text:

#+BEGIN_SRC scheme
  (include "stream")
  (include "stream-util")

  (define (solve-2nd a b dt y0 dy0)
    (define y (integrate (delay dy) y0 dt))
    (define dy (integrate (delay ddy) dy0 dt))
    (define ddy (add-streams (scale-stream dy a) (scale-stream y b)))
    y)
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.79][Exercise 3.79.]]

The integration of ~ddy~ to ~dy~ and ~dy~ to ~y~ remain identical with the
previous answer. The only change is to generalize the definition of ~ddy~ to an
arbitrary function of the two variables \(\mathtt{dy} \equiv \frac{dy}{dt}\) and
\(\mathtt{y} \equiv y\):

#+BEGIN_SRC scheme
  (include "stream")
  (include "stream-util")

  (define (solve-2nd f dt y0 dy0)
    (define y (integrate (delay dy) y0 dt))
    (define dy (integrate (delay ddy) dy0 dt))
    (define ddy (stream-map-poly f dy y))  ; (define (f dy y) ...)
    y)
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.80][Exercise 3.80.]]


Another transcription of the equations/signal-flow diagram:

#+BEGIN_SRC scheme :tangle ex-3-80.scm
  (include "stream")
  (include "stream-util")
  (include "stream-integral")

  (define (RLC R L C dt vC0 iL0)
    (define iL (integral (delay diL) iL0 dt))
    (define vC (integral (delay dVC) vC0 dt))
    (define dVC (scale-stream iL (/ (- 1) C)))
    (define diL (add-streams (scale-stream vC (/ 1 L))
                             (scale-stream iL (/ (- R) L))))
    (cons vC iL))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-80-test.scm
  (include "ex-3-80")
  (use test)

  (define vCiL (RLC 1 0.2 1 0.1 0 10))
  (define vC (car vCiL))
  (define iL (cdr vCiL))

  (parameterize ((current-test-epsilon 0.01))
                (test -0.9605
                      (stream-ref vC 10))
                (test -1.2153
                      (stream-ref iL 10)))
#+END_SRC

*** DONE 3.5.5: Modularity of Functional Programs and Modularity of Objects
    SCHEDULED: <2015-01-25 Sun>
    CLOCK: [2015-01-25 Sun 22:57]--[2015-01-26 Mon 00:20] =>  1:23
    CLOCK: [2015-01-25 Sun 22:53]--[2015-01-25 Sun 22:56] =>  0:03
    CLOCK: [2015-01-25 Sun 22:34]--[2015-01-25 Sun 22:39] =>  0:05
    :PROPERTIES:
    :Effort:   2:00
    :END:

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.81][Exercise 3.81.]]

#+BEGIN_SRC scheme :tangle ex-3-81.scm
  (include "stream")
  (include "stream-util")

  ;;; Generates a stream of random numbers given a stream of requests to the RNG,
  ;;; which can take two forms:
  ;;;
  ;;; - GENERATE: emit the next number in the random number sequence
  ;;; - a number: reset the sequence using the number as the seed. Should be
  ;;;   between 0 and 1.
  ;;;
  ;;; REQUEST-STREAM must start with a number to initialize the seed.
  (define (rand-stream request-stream)
    ;; Linear congruential generator -- glibc coefficients
    (define (rand-update x)
      (define m (expt 2 31))
      (/ (modulo (+ (* 1103515245 (floor (* x m))) 12345) (expt 2 31))
         m))
    (define (reset? request) (number? request))
    (when (not (or (stream-null? request-stream)
                   (reset? (stream-car request-stream))))
          (error "RAND-STREAM -- first element must be random seed"))
    (let recur ((request-stream request-stream)
                (value-stream the-empty-stream))
      (if (stream-null? request-stream)
          the-empty-stream
          (let ((request (stream-car request-stream)))
            (define output-stream
              (cond ((eq? request 'generate) value-stream)
                    ((reset? request)
                     (cons-stream request
                                  (stream-map rand-update output-stream)))
                    (else (error "RAND-STREAM -- bad request"))))
            (cons-stream (stream-car output-stream)
                         (rec (stream-cdr request-stream)
                              (stream-cdr output-stream)))))))
#+END_SRC


#+BEGIN_SRC scheme :tangle

#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%25_thm_3.82][Exercise 3.82.]]

#+BEGIN_SRC scheme :tangle ex-3-82.scm
  (include "ex-3-81")

  (define (stream-estimate-interval P x1 x2 y1 y2)
    (define (constant-stream c)
      (define s (cons-stream c s))
      s)
    (define area (* (- x2 x1) (- y2 y1)))
    (define rand-stream-input
      (cons-stream seed
                   (constant-stream 'generate)))
    (let recur ((rands (rand-stream rand-stream-input))
                (pf (cons 0 0)))
      (let ((x (stream-car rands))
            (y (stream-car (stream-cdr rands))))
        (let* ((pass (car pf))
               (fail (cdr pf))
               (pfnext
                (if (P x y)
                    (cons (+ 1 pass) fail)
                    (cons pass (+ 1 fail)))))
          (cons-stream (* area
                          ;; Probability of satisfying P
                          (/ (car pfnext) (+ (car pfnext) (cdr pfnext))))
                       (recur (stream-cdr rands) pfnext))))))
#+END_SRC
