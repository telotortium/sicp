#+TITLE: Structure and Interpretation of Computer Programs (SICP)
#+AUTHOR: Robert Irelan
#+EMAIL: rirelan@gmail.com
#+OPTIONS: author:t email:t f:t
#+PROPERTY: header-args :comments link :noweb no-export
#+PROPERTY: header-args:scheme :shebang #!/usr/bin/env chicken-scheme

* Chapter 3: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-19.html#%_chap_3][Modularity, Objects, and State]]

** 3.1: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1][Assignment and Local State]]

*** 3.1.1: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.1][Local State Variables]]

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.1][Exercise 3.1.]]

#+BEGIN_SRC scheme :tangle ex-3-1.scm
  (define (make-accumulator initial)
    (lambda (increment)
      (set! initial (+ initial increment))
      initial))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-1-test.scm
  (use test)
  (include "ex-3-1")
  (define A (make-accumulator 5))
  (test 15
        (A 10))
  (test 25
        (A 10))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.2][Exercise 3.2.]]

#+BEGIN_SRC scheme :tangle ex-3-2.scm
  (define (make-monitored f)
    (define counter 0)
    (lambda (x)
      (cond ((equal? x 'how-many-calls?)
             counter)
            ((equal? x 'reset-count)
             (set! counter 0))
            (else
             (f x)
             (set! counter (+ counter 1))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-2-test.scm
  (use test)
  (include "ex-3-2")
  (define s (make-monitored sqrt))
  (test 10
        (s 100))
  (test 1
        (s 'how-many-calls?))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.3][Exercise 3.3.]]

#+BEGIN_SRC scheme :tangle ex-3-3.scm
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x) "Incorrect password")
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request -- MAKE-ACCOUNT"
                             m)))))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-3-test.scm
  (use test)
  (include "ex-3-3")
  (define acc (make-account 100 'secret-password))
  (test 60
        ((acc 'secret-password 'withdraw) 40))
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.4][Exercise 3.4.]]

As the prompt states, there's little more work involved than to add
a ~incorrect-password-attempts~, which we use to ~call-the-cops~ when too many
incorrect attempts in a row have been made. Ideally, a different response
would not be returned to the user when the cops have been called, but I've
decided to do so for ease of testing.

#+BEGIN_SRC scheme :tangle ex-3-4.scm
  (define (make-account balance password)
    (define incorrect-password-attempts 0)
    (define (call-the-cops)
      "Please wait -- calling the cops...")
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x)
            (set! incorrect-password-attempts
                  (+ incorrect-password-attempts 1))
            (if (> incorrect-password-attempts 7)
                (call-the-cops)
                "Incorrect password"))
          (begin
            (set! incorrect-password-attempts 0)
            (cond ((eq? m 'withdraw) withdraw)
                  ((eq? m 'deposit) deposit)
                  (else (error "Unknown request -- MAKE-ACCOUNT"
                               m))))))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-4-test.scm
  (use test)
  (include "ex-3-4")
  (define acc (make-account 100 'secret-password))
  (for-each (lambda (i)
              (test "Incorrect password"
                    ((acc 'some-other-password 'withdraw) 100)))
            (iota 7))
  (test "Please wait -- calling the cops..."
        ((acc 'some-other-password 'withdraw) 100))
#+END_SRC


*** 3.1.2: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.2][The Benefits of Introducing Assignment]]

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.5][Exercise 3.5.]]

#+BEGIN_SRC scheme :tangle ex-3-5.scm
  (define (estimate-integral P x1 x2 y1 y2 ntrial)
    ;; Number of trials for which the trial point was inside the region to be
    ;; integrated (i.e., where (= (P x y) #t)).
    (define ninside 0)
    (define (random-x)
      (random-in-range x1 x2))
    (define (random-y)
      (random-in-range y1 y2))
    (define (try x y)
      (if (P x y)
          (set! ninside (+ ninside 1))))
    (for-each (lambda (i)
                (try (random-x) (random-y)))
              (iota ntrial))
    (* (- x2 x1)
       (- y2 y1)
       (/ ninside ntrial)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-5-test.scm
  (use test)
  (include "ex-3-5")
  (define (p-circle)
    (lambda (x y)
      (> (* 1.0 1.0)
         (+ (* x x)
            (* y y)))))
  (current-test-epsilon 0.10)
  (define pi (* 4 (atan 1 1)))
  (parameterize ((current-test-epsilon 0.10))
                (test pi
                      (estimate-integral (p-circle) -2.0 2.0 -2.0 2.0 100000)))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.6][Exercise 3.6.]]

This is a fairly simple modification of the ~rand~ command defined in the
book. The main change is to dispatch on a ~command~ argument to ~rand~. Also,
since the ~reset~ argument sets the seed of the random number generator, I
don't define a ~random-init~ variable here. Thus, it is necessary to make at
least one call to ~(rand 'reset)~ before using ~(rand 'generate)~ to make sure
the seed is initialized.

#+BEGIN_SRC scheme :tangle ex-3-6.scm
  (define (rand command)
    (define x nil)                        ; Don't produce random numbers until initialized
    (cond ((equal? command 'generate)
           (set! x (rand-update x))
           x)
          ((equal? command 'reset)
           (lambda (x-init)
             (set! x x-init)))
          (else
           (error "RAND -- bad command")
           command)))
#+END_SRC


*** 3.1.3: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.3][The Costs of Introducing Assignment]]

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.7][Exercise 3.7.]]

#+BEGIN_SRC scheme :tangle ex-3-7.scm
  (include "ex-3-3")
  (define (make-joint account original-password new-password)
    (define (dispatch p m)
      ;; The underlying account accepts only original-password, so accept
      ;; new-password by passing original-password. Otherwise, let the underlying
      ;; account deal with error handling for a wrong password.
      (if (equal? p new-password)
          (account original-password m)
          (account p m)))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-7-test.scm
  (use test)
  (include "ex-3-7")
  (define acc (make-account 140 'secret-password))
  (define joint-acc
    (make-joint acc 'secret-password 'proxy-password))
  ;;; Both `acc` and `joint-acc` accept the original password, and actions on
  ;;; either affect the other since `joint-acc` delegates all messages to `acc`.
  (test 100
        ((joint-acc 'secret-password 'withdraw) 40))
  (test 60
        ((joint-acc 'secret-password 'withdraw) 40))
  ;;; Neither account works with an unknown password.
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
  (test "Incorrect password"
        ((joint-acc 'some-other-password 'deposit) 50))
  ;;; Original account `acc` doesn't work with the proxy password, but the joint
  ;;; account `joint-acc` does.
  (test "Incorrect password"
        ((acc 'proxy-password 'withdraw) 20))
  (test 40
        ((joint-acc 'proxy-password 'withdraw) 20))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.8][Exercise 3.8.]]

#+BEGIN_SRC scheme :tangle ex-3-8.scm
  (define f
    (let ((cache '()))
      (lambda (x)
        (cond ((null? x) (set! cache '())) ; Allow cache to be cleared.
              ((not (null? cache)) 0)      ; Return 0 if cache isn't clear.
              (else (set! cache x)       ; Set cache if it isn't clear already.
                    x)))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-8-test.scm
  (use test)
  (include "ex-3-8")

  ;;; Simulate left-to-right evaluation by assigning to temporaries
  (define x (f 0))
  (define y (f 1))
  (test 0
        (+ x y))

  ;;; Reset cache
  (f '())

  ;;; Right-to-left evaluation
  (define y (f 1))
  (define x (f 0))
  (test 1
        (+ x y))
#+END_SRC


** 3.2: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2][The Environment Model of Evaluation]]

*** 3.2.1: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2.1][The Rules for Evaluation]]

No exercises


*** 3.2.2: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2.2][Applying Simple Procedures]]

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.9][Exercise 3.9.]]

I don't want to draw, so I'll use Scheme S-expressions instead.

In general, each invocation of a procedure creates an environment containing a
reference to its enclosing environment and a list of references to its
parameters. The global environment is much the same except that has a nil
pointer for the enclosing environment since there is no enclosing
environment. In the below, I've represented each parameter as a list of the
symbol name and value, but the symbol name is only preserved here for ease of
following the examples -- it doesn't necessarily have to be kept in an actual
interpreter.

The recursive definition of ~factorial~,

#+BEGIN_SRC scheme
  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))
#+END_SRC

spawns a separate environment for each call of ~factorial~, each of which has a
reference to the global environment and the value of its one argument:

#+BEGIN_SRC scheme
  (define global-env `(() (factorial ,factorial-proc)
                          (fact-iter ,fact-iter-proc)
                          ,@intrinsic-defs))
  (define all-envs `((,global-env (n ,6))))
  (set! ,all-envs `((,global-env (n ,5)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,4)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,3)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,2)) ,all-envs))
  (set! ,all-envs `((,global-env (n ,1)) ,all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (set! all-envs (cdr all-envs))
  (assert (null? all-envs))

#+END_SRC

In contrast, the iterative version,

#+BEGIN_SRC scheme
  (define (factorial n)
    (fact-iter 1 1 n))
  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
#+END_SRC

because it is tail recursive, replaces the environment of the function from
which a tail recursive call is made with the environment for the target
function of the tail recursive call. Since all function calls in both
~factorial~ and ~fact-iter~ are tail recursive, the list of environments
changes basically as described in the pseudocode below:

#+BEGIN_SRC scheme
  (define global-env `(() (factorial ,factorial-proc)
                       (fact-iter ,fact-iter-proc)
                       ,@intrinsic-defs))
  (define all-envs `((global-env (n ,6))))
  (set-car! all-envs `(global-env (product ,1)
                                  (counter ,1)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,1)
                                  (counter ,2)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,2)
                                  (counter ,3)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,6)
                                  (counter ,4)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,24)
                                  (counter ,5)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,120)
                                  (counter ,6)
                                  (max-count ,6)))
  (set-car! all-envs `(global-env (product ,720)
                                  (counter ,7)
                                  (max-count ,6)))
  (set! all-envs (cdr all-envs))
  (assert (null? all-envs))
#+END_SRC

Notice above that we've really simulated a stack, with ~set-car!~ performing a
mutation-in-place of the top entry of the stack.


*** 3.2.3: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2.3][Frames as the Repository of Local State]]

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.10][Exercise 3.10.]]

The procedure to be analyzed,

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    (let ((balance initial-amount))
      (lambda (amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))))
#+END_SRC

expands to the following when ~let~ is expanded to its underlying syntax:

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    ((lambda (balance)
       (lambda (amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds")))
     initial-amount))
#+END_SRC

Without TCE, the function returned by ~make-withdraw~ (i.e.,
~(lambda (amount) ⋯)~), has a pointer the environment of
~(lambda (balance) ⋯)~, which has a pointer to the global environment. However,
the call to ~(lambda (balance) ⋯)~ is in tail position, so it replaces the
environment formed by the call of ~make-withdraw~. When the returned
~(lambda (amount) ⋯)~ is called, it therefore has a pointer to the environment
of ~(lambda (balance) ⋯)~, which points to the global environment.


*** 3.2.4: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2.4][Internal Definitions]]

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%25_thm_3.11][Exercise 3.11.]]

The environment for ~make-account~ points to the global environment. In this
environment exist references to the argument ~balance~ as well as the local
procedures ~withdraw~, ~deposit~, and ~dispatch~. Each local procedure points to
the environment of ~make-account~ (and retains references to its own arguments
as well). It's necessary to keep references to the local procedures in the
environment of ~make-account~ so that ~dispatch~ can resolve the references to
~withdraw~ and ~deposit~ in its body. (On the other hand, it should not
strictly be necessary to retain a reference to ~dispatch~ since a reference to
that procedure is returned.)


** 3.3: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3][Modeling with Mutable Data]]

*** 3.3.1: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1][Mutable List Structure]]

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.12][Exercise 3.12.]]

#+BEGIN_SRC scheme :tangle ex-3-12-test.scm
  (use test)

  ;;; Nondestructive
  (define x (list 'a 'b))
  (define y (list 'c 'd))
  (define z (append x y))

  (test z
        '(a b c d))
  (test (cdr x)
        '(b))

  ;;; Destructive
  (define w (append! x y))

  (test w
        '(a b c d))
  (test (cdr w)
        '(b c d))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.13][Exercise 3.13.]]

When a circular list is constructed from a linear list, the last cons cell in
the original list has its cdr set to the head of the original list. Thus,
~(null? (cdr x))~ never returns true for any element ~x~ in the list and the
~last-pair~ procedure loops around the list forever.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.14][Exercise 3.14.]]

~mystery~ reverses a list destructively:

#+NAME: ex-3-14
#+BEGIN_SRC scheme
  (define (mystery x)
    (define (loop x y)
      (if (null? x)
          y
          (let ((temp (cdr x)))
            (set-cdr! x y)
            (loop temp x))))
    (loop x '()))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-14-test.scm
  (use test)
  <<ex-3-14>>
  (define v '(a b c d))
  (define w (mystery v))
  (test w
        '(d c b a))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.15][Exercise 3.15.]]

In Figure 3.16, modify the diagram so that the arrow pointing to the ~'a~ cell
now points to a ~'wow~ cell.

In Figure 3.17, only the arrow pointing to ~'a~ from below now points to ~'wow~
-- the arrow from above continues to point to ~'a~.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.16][Exercise 3.16.]]

Ben Bitdiddle's flawed procedure:

#+NAME: ex-3-16-count-pairs
#+BEGIN_SRC scheme
  (define (count-pairs x)
    (if (not (pair? x))
        0
        (+ (count-pairs (car x))
           (count-pairs (cdr x))
           1)))
#+END_SRC

We define some test data here, containing a simple list, some more complex
linked structures, and a list containing a cycle, for this and the rest of the
exercises in this section.

#+BEGIN_SRC scheme :tangle sharing-identity-test-data.scm
  (define pairs-3 '(a b c))
  (define pairs-4
    (begin
      (define x '(a b c))
      (set-car! x (cddr x))
      x))
  (define pairs-7
    (begin
      (define x '(a b c))
      (set-car! x (cdr x))
      (set-car! (cdr x) (cddr x))
      x))
  (define pairs-cycle
    (begin
      (define x '(a b c))
      (set-cdr! (cddr x) x)
      x))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-16-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (test 0
        (count-pairs '()))
  (test 0
        (count-pairs 'a))
  (test 3
        (count-pairs pairs-3))
  (test 4
        (count-pairs pairs-4))
  (test 7
        (count-pairs pairs-7))
  ;;; No test for pairs-cycle, because a cycle causes this version of count-pairs
  ;;; to run forever.
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.17][Exercise 3.17.]]

#+BEGIN_SRC scheme :tangle ex-3-17-count-pairs.scm
  (define (count-pairs x)
    (let ((seens '()))
      (let inner ((x x))
        (if (or (not (pair? x))
                (memq x seens))
            0
            (begin
              (set! seens (cons x seens))
              (+ (inner (car x))
                 (inner (cdr x))
                 1))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-17-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-17-count-pairs")
  (test 0
        (count-pairs '()))
  (test 0
        (count-pairs 'a))
  (test 3
        (count-pairs pairs-3))
  (test 4
        (count-pairs pairs-4))
  (test 7
        (count-pairs pairs-7))
  (test 3
        (count-pairs pairs-cycle))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.18][Exercise 3.18.]]

#+BEGIN_SRC scheme :tangle ex-3-18.scm
  (define (cycle? x)
    (let ((seens '()))
      (let inner ((x x))
        (cond ((not (pair? x)) #f)
              ((memq x seens) #t)
              (else (set! seens (cons x seens))
                    (inner (cdr x)))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-18-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-18")
  (test #f
        (cycle? '()))
  (test #f
        (cycle? 'a))
  (test #f
        (cycle? pairs-3))
  (test #f
        (cycle? pairs-4))
  (test #f
        (cycle? pairs-7))
  (test #t
        (cycle? pairs-cycle))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.19][Exercise 3.19.]]

Use [[http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare][Floyd's cycle-finding algorithm]], also known as the "tortoise-and-hare"
algorithm. Two pointers to the list elements are kept. The "tortoise" is
advanced by 1 position for every call, while the "hare" is advanced by 2
positions. If a cycle exists, the tortoise and hare will eventually run into
other (i.e., compare equal via ~eq?~ after the initial call).

#+BEGIN_SRC scheme :tangle ex-3-19.scm
  (define (cycle? x)
    (define (cdr-safe x)
      (if (not (pair? x))
          x
          (cdr x)))
    (define (cddr-safe x)
      (if (not (pair? x))
          x
          (cdr-safe (cdr x))))
    (define (inner tortoise hare first-run)
      (cond ((any (lambda (p) (not (pair? p)))
                  (list tortoise hare))
             #f)
            ((and (not first-run)
                  (eq? tortoise hare))
             #t)
            (else (inner (cdr-safe tortoise)
                         (cddr-safe hare)
                         #f))))
    (inner x x #t))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-19-test.scm
  (use test)
  (include "sharing-identity-test-data")
  (include "ex-3-19")
  (test #f
        (cycle? '()))
  (test #f
        (cycle? 'a))
  (test #f
        (cycle? pairs-3))
  (test #f
        (cycle? pairs-4))
  (test #f
        (cycle? pairs-7))
  (test #t
        (cycle? pairs-cycle))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.20][Exercise 3.20.]]

Given the implementation of the primitive list functions in terms of
dispatching, now including mutation,

#+BEGIN_SRC scheme :tangle ex-3-20-cons-dispatch.scm
  ;;; -d for dispatching.
  (define (cons-d x y)
    (define (set-x! v) (set! x v))
    (define (set-y! v) (set! y v))
    (define (dispatch m)
      (cond ((eq? m 'car) x)
            ((eq? m 'cdr) y)
            ((eq? m 'set-car!) set-x!)
            ((eq? m 'set-cdr!) set-y!)
            (else (error "Undefined operation -- CONS" m))))
    dispatch)
  (define (car-d z) (z 'car))
  (define (cdr-d z) (z 'cdr))
  (define (set-car-d! z new-value)
    ((z 'set-car!) new-value)
    z)
  (define (set-cdr-d! z new-value)
    ((z 'set-cdr!) new-value)
    z)
#+END_SRC

we can understand the environment diagram of the following code

#+BEGIN_SRC scheme :tangle ex-3-20-test.scm
  (use test)
  (include "ex-3-20-cons-dispatch")
  (define x (cons 1 2))
  (define z (cons x x))
  (set-car! (cdr z) 17)
  (test 17
        (car x))
#+END_SRC

as follows:

- Every call to ~cons-d~ returns a ~dispatch~ closure which has a pointer to
  the environment of the ~cons-d~ closure, which holds the arguments to
  ~cons-d~, ~x~ and ~y~.
- All messages to the ~dispatch~ closure read or write to the environment of
  the original ~cons-d~ call, which is preserved by the link from ~dispatch~.
- ~x~ and ~y~, the arguments to ~cons-d~, are acted upon in precisely the same
  way as the ~car~ and ~cdr~ of a normal ~cons~ cell.


*** 3.3.2: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.2][Representing Queues]]

#+BEGIN_SRC scheme :tangle queue-cons.scm
  (define (front-ptr queue) (car queue))
  (define (rear-ptr queue) (cdr queue))
  (define (set-front-ptr! queue item) (set-car! queue item))
  (define (set-rear-ptr! queue item) (set-cdr! queue item))
  (define (empty-queue? queue) (null? (front-ptr queue)))
  (define (make-queue) (cons '() '()))
  (define (front-queue queue)
    (if (empty-queue? queue)
        (error "FRONT called with an empty queue" queue)
        (car (front-ptr queue))))
  (define (insert-queue! queue item)
    (let ((new-pair (cons item '())))
      (cond ((empty-queue? queue)
             (set-front-ptr! queue new-pair)
             (set-rear-ptr! queue new-pair)
             queue)
            (else
             (set-cdr! (rear-ptr queue) new-pair)
             (set-rear-ptr! queue new-pair)
             queue))))
  (define (delete-queue! queue)
    (cond ((empty-queue? queue)
           (error "DELETE! called with an empty queue" queue))
          (else
           (set-front-ptr! queue (cdr (front-ptr queue)))
           queue)))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.21][Exercise 3.21.]]

The standard Lisp printer recursively prints the contents of a list (or cons
cell) in order. In particular, this implementation does not treat two pointers
to the same underlying object specially. With the mutation used to implement
the queue, ~(rear-ptr queue)~ points to the last item in the queue, while
~(front-ptr queue)~ points to the head of the list that actually stores the
items in the queue. Since the last item is in the queue list, it is printed
twice, once as an element of the list and once as a lone item. (As an aside, it
appears that the queue is keeping the last item alive longer than necessary
through the pointer ~rear-ptr~ after the queue is empty. The implementation
should set ~rear-ptr~ to nil (or some other small, primitive, immutable value)
to fix this.)

Since ~front-ptr~ returns a pointer to the list that represents the queue, all
we need to do to print the queue properly is print that list:

#+BEGIN_SRC scheme :tangle ex-3-21-print-queue.scm
  (define (print-queue q)
    (display (front-ptr q)))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.22][Exercise 3.22.]]

A straightforward implementation uses the same approach as implementing cons
cells using dispatch -- the arguments to the constructor, retained by the
~dispatch~ closure, are manipulated by subprocedures in ~dispatch~ in the same
way as the car and cdr of the cons cell we use to implement the queue above.

#+BEGIN_SRC scheme :tangle ex-3-22-queue-dispatch.scm
  (define (make-queue-d)
    (let ((front-ptr '())
          (rear-ptr '()))
      ;; Some of these procedures are defined to return a reference to the queue
      ;; on which the procedure was invoked. For consistency, we define all these
      ;; procedures to take `queue`.
      (define (set-front-ptr! queue item) (set! front-ptr item))
      (define (set-rear-ptr! queue item) (set! rear-ptr item))
      (define (empty-queue? queue) (null? front-ptr))
      (define (front-queue queue)
        (if (empty-queue? queue)
            (error "FRONT called with an empty queue" queue)
            (car front-ptr)))
      (define (insert-queue! queue item)
        (let ((new-pair (cons item '())))
          (cond ((empty-queue? queue)
                 (set-front-ptr! queue new-pair)
                 (set-rear-ptr! queue new-pair)
                 queue)
                (else
                 (set-cdr! rear-ptr new-pair)
                 (set-rear-ptr! queue new-pair)
                 queue))))
      (define (delete-queue! queue)
        (cond ((empty-queue? queue)
               (error "DELETE! called with an empty queue" queue))
              (else
               (set-front-ptr! queue (cdr front-ptr))
               ;; If the queue becomes empty, clear `rear-ptr` to avoid
               ;; unnecessarily retaining a reference to it.
               (when (null? front-ptr)
                     (set-rear-ptr! queue '()))
               queue)))
      (define (dispatch m)
        (cond ((eq? m 'front-ptr) front-ptr)
              ((eq? m 'rear-ptr) rear-ptr)
              ((eq? m 'set-front-ptr!)
               (lambda (item) (set-front-ptr! dispatch item)))
              ((eq? m 'set-rear-ptr!)
               (lambda (item) (set-rear-ptr! dispatch item)))
              ((eq? m 'empty-queue?)
               (empty-queue? dispatch))
              ((eq? m 'front-queue)
               (front-queue dispatch))
              ((eq? m 'insert-queue!)
               (lambda (item) (insert-queue! dispatch item)))
              ((eq? m 'delete-queue!)
               (delete-queue! dispatch))
              (else
               error "Undefined operation - QUEUE" m)))
      dispatch))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-22-test.scm
  (use test)
  (include "ex-3-22-queue-dispatch")
  (define q (make-queue-d))
  ((q 'insert-queue!) 0)
  (test 0
        (q 'front-queue))
  ((q 'insert-queue!) 1)
  ((q 'insert-queue!) 2)
  (test 2
        (car (q 'rear-ptr)))
  (q 'delete-queue!)
  (test 1
        (q 'front-queue))
  (q 'delete-queue!)
  (q 'delete-queue!)
  (test #t
        (q 'empty-queue?))
  (test #t
        (null? (q 'rear-ptr)))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.23][Exercise 3.23.]]

Represent as doubly-linked list. Will need selectors for DLL:

#+BEGIN_SRC scheme :tangle ex-3-23.scm
  (define (make-deque)
    (let ((header (cons '() '())))
      ;; Internal procedures on internal representation of deque.
      (define (make-node item prev next)
        (cons (cons item prev) next))
      (define (front) (car header))
      (define (rear) (cdr header))
      (define (set-front! node) (set-car! header node))
      (define (set-rear! node) (set-cdr! header node))
      (define (item node) (caar node))
      (define (prev node) (cdar node))
      (define (next node) (cdr node))
      (define (set-prev! this that) (set-cdr! (car this) that))
      (define (set-next! this that) (set-cdr! this that))

      ;; Exported procedures
      (define (empty? self)
        (eq? (front) '()))
      (define (front-deque self)
        (item (front)))
      (define (rear-deque self)
        (item (rear)))
      (define (front-insert! self item)
        (set-front! (make-node item '() (front))))
      (define (rear-insert! self item)
        (set-rear! (make-node item (rear) '())))
      (define (front-delete! self)
        (set-front! (next (front))))
      (define (rear-delete! self)
        (set-rear! (prev (rear))))

      (define (dispatch m)
        (cond ((eq? m 'empty?) (empty? header))
              ((eq? m 'front-deque) (front-deque header))
              ((eq? m 'rear-deque) (rear-deque header))
              ((eq? m 'front-insert!) (front-insert! header item))
              ((eq? m 'rear-insert!) (rear-insert! header item))
              ((eq? m 'front-delete!) (front-delete! header))
              ((eq? m 'rear-delete!) (rear-delete! header))
              (else (error "Undefined operation -- DEQUE" m))))
      dispatch))
#+END_SRC


*** 3.3.3: [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.3][Representing Tables]]

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.24][Exercise 3.24.]]

#+BEGIN_SRC scheme :tangle ex-3-24.scm
  (define (make-table same-key?)
    (let ((tbl (cons '*table* '())))
      ;; Internal procedure
      (define (assoc key records)
        (cond ((null? records) #f)
              ((same-key? key (caar records)) (car records))
              (else (assoc key (cdr records)))))
      ;; Exported procedures
      (define (lookup key)
        (let ((record (assoc key (cdr tbl))))
          (if record
              (cdr record)
              #f)))
      (define (insert! key value)
        (let ((record (assoc key (cdr tbl))))
          (if record
              (set! (cdr record) value)
              (set! (cdr tbl) (cons (cons key value) (cdr tbl))))))
      ;; Dispatch
      (define (dispatch msg)
        (cond ((equal? msg 'lookup) lookup)
              ((equal? msg 'insert!) insert!)
              (else (error "TABLE -- unknown message")))))
      dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-24-test.scm
  (include "ex-3-24")
  (use test)

  (define tbl-exact (make-table (lambda (x y) (equal? x y))))
  (test #f
        ((tbl-exact 'lookup) 'foo))

  ((tbl-exact 'insert!) 'a 1)
  ((tbl-exact 'insert!) 'b 2)
  ((tbl-exact 'insert!) 'c 3)
  (test 1
        ((tbl-exact 'lookup) 'a))
  (test 2
        ((tbl-exact 'lookup) 'b))
  (test 3
        ((tbl-exact 'lookup) 'c))

  (define tbl-inexact (make-table (lambda (x y)
                                    (< (abs (- x y)) .1))))
  (test #f
        ((tbl-inexact 'lookup) 'foo))
  ((tbl-inexact 'insert!) 1.0 'x)
  (test 'x
        ((tbl-inexact 'lookup) 1.05))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.25][Exercise 3.25.]]

#+BEGIN_SRC scheme :tangle ex-3-25.scm
  (define (make-table same-key?)
    (let ((tbl (cons '*table* '())))
      (define (assoc key records)
        (cond ((null? records) #f)
              ((same-key? key (caar records)) (car records))
              (else (assoc key (cdr records)))))
      (define (lookup keys)
        (let recur ((elems (cdr tbl))
                    (keys keys))
          (let ((record (assoc (car keys) elems)))
            (if record
                (cond
                 ;; If the current key maps to a list, there must be more keys to
                 ;; continue the search.
                 ((and (pair? (cdr keys)) (pair? (cdr record)))
                  (recur (cdr record) (cdr keys)))
                 ;; Ensure that e.g. `(lookup '(a b))` does not succeed if
                 ;; `(lookup '(a))` does not return a list.
                 ((null? (cdr keys))
                  (cdr record))
                 (else #f))
                #f))))
      (define (insert! keys value)
        (when (null? keys)
              (error "INSERT! -- keys cannot be empty"))
        (let recur ((header tbl)
                    (keys keys))
          (define (recursively-insert record)
            (if (null? (cdr keys))
                (set! (cdr record) value)
                (begin
                  ;; Obliterate any non-list associated with the current key,
                  ;; since it will need to be replaced.
                  (when (not (pair? (cdr record)))
                        (set! (cdr record) '()))
                  (recur record (cdr keys)))))
          (let ((record (assoc (car keys) (cdr header))))
            (if (pair? record)
                (recursively-insert record)
                (let ((inserted (if record
                                    record
                                    (cons (car keys) '()))))
                  (when (not record)
                        (set! (cdr header) (cons inserted (cdr header))))
                  (recursively-insert inserted))))))
      (define (dispatch msg)
        (cond ((equal? msg 'lookup) lookup)
              ((equal? msg 'insert!) insert!)
              (else (error "TABLE -- unknown message"))))
      dispatch))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-25-test.scm
  (include "ex-3-25")
  (use test)

  (define (lookup tbl keys)
    ((tbl 'lookup) keys))
  (define (insert! tbl keys value)
    ((tbl 'insert!) keys value))
  (define tbl (make-table equal?))
  (test #f
        (lookup tbl '(a)))
  (test #f
        (lookup tbl '(0 1 2)))

  (insert! tbl '(a) 'foo)
  (insert! tbl '(0 1 2) 'bar)
  (test 'foo
        (lookup tbl '(a)))
  (test #f
        (lookup tbl '(a b)))
  (test 'bar
        (lookup tbl '(0 1 2)))
  (test #t
        (pair? (lookup tbl '(0))))

  (insert! tbl '(a b) 'baz)
  (test 'baz
        (lookup tbl '(a b)))
  (test #t
        (pair? (lookup tbl '(a))))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.26][Exercise 3.26.]]

#+BEGIN_SRC scheme :tangle ex-3-26.scm
  (define (make-table cmp)
    (let ((tbl (cons '*table* '())))
      ;; Accessor functions
      (define (key node) (caar node))
      (define (value node) (cdar node))
      (define (left node) (cadr node))
      (define (right node) (cddr node))
      (define (set-value! node v) (set-cdr! (car node) v))
      (define (set-left! node n) (set-car! (cdr node) n))
      (define (set-right! node n) (set-cdr! (cdr node) n))
      (define (make-node k v) (cons #|payload|#  (cons k v)
                                    #|children|# (cons '() '())))

      (define (lookup k)
        (let recur ((node (cdr tbl)))
          (cond ((null? node) #f)
                ((< (cmp k (key node)) 0) (recur (left node)))
                ((> (cmp k (key node)) 0) (recur (right node)))
                (else (value node)))))
      (define (insert! k v)
        (set! (cdr tbl)
              (let recur ((node (cdr tbl)))
                (cond ((null? node) (make-node k v))
                      ((< (cmp k (key node)) 0)
                       (set-left! node (recur (left node)))
                       node)
                      ((> (cmp k (key node)) 0)
                       (set-right! node (recur (right node)))
                       node)
                      (else (set-value! node v)
                            node)))))
      (define (dispatch msg)
        (cond ((equal? msg 'lookup) lookup)
              ((equal? msg 'insert!) insert!)
              (else (error "TABLE -- unknown message"))))
      dispatch))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-26-test.scm
  (include "ex-3-26")
  (use test)

  (define (lookup tbl key)
    ((tbl 'lookup) key))
  (define (insert! tbl key value)
    ((tbl 'insert!) key value))
  (define tbl (make-table (lambda (x y)
                            (cond ((< x y) -1)
                                  ((> x y) 1)
                                  (else 0)))))

  (test #f
        (lookup tbl 0))
  (insert! tbl 0 'foo)
  (test 'foo
        (lookup tbl 0))
  (test #f
        (lookup tbl 1))
  (insert! tbl -3 'bar)
  (test 'foo
        (lookup tbl 0))
  (test 'bar
        (lookup tbl -3))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.27][Exercise 3.27.]]

Ehh...
