#+BEGIN_SRC scheme
  (use sicp test)
#+END_SRC

* Chapter 3: Modularity, Objects, and State

** 3.1: Assignment and Local State

*** 3.1.1: Local State Variables

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.1][Exercise 3.1.]]

#+BEGIN_SRC scheme :tangle ex-3-1.scm
  (define (make-accumulator initial)
    (lambda (increment)
      (set! initial (+ initial increment))
      initial))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-1-test.scm
  (use test)
  (include "ex-3-1")
  (define A (make-accumulator 5))
  (test 15
        (A 10))
  (test 25
        (A 10))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.2][Exercise 3.2.]]

#+BEGIN_SRC scheme :tangle ex-3-2.scm
  (define (make-monitored f)
    (define counter 0)
    (lambda (x)
      (cond ((equal? x 'how-many-calls?)
             counter)
            ((equal? x 'reset-count)
             (set! counter 0))
            (else
             (f x)
             (set! counter (+ counter 1))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-2-test.scm
  (use test)
  (include "ex-3-2")
  (define s (make-monitored sqrt))
  (test 10
        (s 100))
  (test 1
        (s 'how-many-calls?))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.3][Exercise 3.3.]]

#+BEGIN_SRC scheme :tangle ex-3-3.scm
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x) "Incorrect password")
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request -- MAKE-ACCOUNT"
                             m)))))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-3-test.scm
  (use test)
  (include "ex-3-3")
  (define acc (make-account 100 'secret-password))
  (test 60
        ((acc 'secret-password 'withdraw) 40))
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.4][Exercise 3.4.]]

As the prompt states, there's little more work involved than to add
a ~incorrect-password-attempts~, which we use to ~call-the-cops~ when too many
incorrect attempts in a row have been made. Ideally, a different response
would not be returned to the user when the cops have been called, but I've
decided to do so for ease of testing.

#+BEGIN_SRC scheme :tangle ex-3-4.scm
  (define (make-account balance password)
    (define incorrect-password-attempts 0)
    (define (call-the-cops)
      "Please wait -- calling the cops...")
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch p m)
      (if (not (equal? p password))
          (lambda (x)
            (set! incorrect-password-attempts
                  (+ incorrect-password-attempts 1))
            (if (> incorrect-password-attempts 7)
                (call-the-cops)
                "Incorrect password"))
          (begin
            (set! incorrect-password-attempts 0)
            (cond ((eq? m 'withdraw) withdraw)
                  ((eq? m 'deposit) deposit)
                  (else (error "Unknown request -- MAKE-ACCOUNT"
                               m))))))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-4-test.scm
  (use test)
  (include "ex-3-4")
  (define acc (make-account 100 'secret-password))
  (for-each (lambda (i)
              (test "Incorrect password"
                    ((acc 'some-other-password 'withdraw) 100)))
            (iota 7))
  (test "Please wait -- calling the cops..."
        ((acc 'some-other-password 'withdraw) 100))
#+END_SRC

*** 3.1.2: The Benefits of Introducing Assignment

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.5][Exercise 3.5.]]

#+BEGIN_SRC scheme :tangle ex-3-5.scm
  (define (estimate-integral P x1 x2 y1 y2 ntrial)
    ;; Number of trials for which the trial point was inside the region to be
    ;; integrated (i.e., where (= (P x y) #t)).
    (define ninside 0)
    (define (random-x)
      (random-in-range x1 x2))
    (define (random-y)
      (random-in-range y1 y2))
    (define (try x y)
      (if (P x y)
          (set! ninside (+ ninside 1))))
    (for-each (lambda (i)
                (try (random-x) (random-y)))
              (iota ntrial))
    (* (- x2 x1)
       (- y2 y1)
       (/ ninside ntrial)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-5-test.scm
  (use test)
  (include "ex-3-5")
  (define (p-circle)
    (lambda (x y)
      (> (* 1.0 1.0)
         (+ (* x x)
            (* y y)))))
  (current-test-epsilon 0.10)
  (define pi (* 4 (atan 1 1)))
  (parameterize ((current-test-epsilon 0.10))
                (test pi
                      (estimate-integral (p-circle) -2.0 2.0 -2.0 2.0 100000)))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.6][Exercise 3.6.]]

This is a fairly simple modification of the ~rand~ command defined in the
book. The main change is to dispatch on a ~command~ argument to ~rand~. Also,
since the ~reset~ argument sets the seed of the random number generator, I
don't define a ~random-init~ variable here. Thus, it is necessary to make at
least one call to ~(rand 'reset)~ before using ~(rand 'generate)~ to make sure
the seed is initialized.

#+BEGIN_SRC scheme :tangle ex-3-6.scm
  (define (rand command)
    (define x nil)                        ; Don't produce random numbers until initialized
    (cond ((equal? command 'generate)
           (set! x (rand-update x))
           x)
          ((equal? command 'reset)
           (lambda (x-init)
             (set! x x-init)))
          (else
           (error "RAND -- bad command")
           command)))
#+END_SRC

*** 3.1.3: The Costs of Introducing Assignment

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.7][Exercise 3.7.]]

#+BEGIN_SRC scheme :tangle ex-3-7.scm
  (include "ex-3-3")
  (define (make-joint account original-password new-password)
    (define (dispatch p m)
      ;; The underlying account accepts only original-password, so accept
      ;; new-password by passing original-password. Otherwise, let the underlying
      ;; account deal with error handling for a wrong password.
      (display p) (newline)
      (if (equal? p new-password)
          (account original-password m)
          (account p m)))
    dispatch)
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-3-7-test.scm
  (use test)
  (include "ex-3-7")
  (define acc (make-account 140 'secret-password))
  (define joint-acc
    (make-joint acc 'secret-password 'proxy-password))
  ;;; Both `acc` and `joint-acc` accept the original password, and actions on
  ;;; either affect the other since `joint-acc` delegates all messages to `acc`.
  (test 100
        ((joint-acc 'secret-password 'withdraw) 40))
  (test 60
        ((joint-acc 'secret-password 'withdraw) 40))
  ;;; Neither account works with an unknown password.
  (test "Incorrect password"
        ((acc 'some-other-password 'deposit) 50))
  (test "Incorrect password"
        ((joint-acc 'some-other-password 'deposit) 50))
  ;;; Original account `acc` doesn't work with the proxy password, but the joint
  ;;; account `joint-acc` does.
  (test "Incorrect password"
        ((acc 'proxy-password 'withdraw) 20))
  (test 40
        ((joint-acc 'proxy-password 'withdraw) 20))
#+END_SRC

**** [[view-source:http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_thm_3.8][Exercise 3.8.]]
