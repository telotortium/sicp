#+TITLE: Structure and Interpretation of Computer Programs (SICP)
#+AUTHOR: Robert Irelan
#+EMAIL: rirelan@gmail.com
#+OPTIONS: author:t email:t f:t num:nil H:4
#+PROPERTY: header-args :comments link :noweb no-export
#+PROPERTY: header-args:scheme :shebang #!/usr/bin/env chicken-scheme
#+FILETAGS: :SICP:

* Chapter 2

** 2.3: Symbolic Data

*** 2.3.1: Quotation

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-16.html#%25_thm_2.53][Exercise 2.53.]]
#+NAME: ex-2-53-test
#+BEGIN_SRC scheme
  (test '(a b c)
        (list 'a 'b 'c))
  (test '((george))
        (list (list 'george)))
  (test '((y1 y2))
        (cdr '((x1 x2) (y1 y2))))
  (test '(y1 y2)
        (cadr '((x1 x2) (y1 y2))))
  (test #f
        (pair? (car '(a short list))))
  (test #f
        (memq 'red '((red shoes) (blue socks))))
  (test '(red shoes blue socks)
        (memq 'red '(red shoes blue socks)))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-16.html#%25_thm_2.54][Exercise 2.54.]]
#+NAME: ex-2-54
#+BEGIN_SRC scheme
  (define (my-equal? a b)
    (cond ((not (and (pair? a) (pair? b)))
           (eq? a b))
          ((and (pair? a) (pair? b))
           (and (my-equal? (car a) (car b))
                (my-equal? (cdr a) (cdr b))))
          (else #f)))
#+END_SRC

#+NAME: ex-2-54-test
#+BEGIN_SRC scheme
  (test #t
        (my-equal? '(this is a list) '(this is a list)))
  (test #f
        (my-equal? '(this is a list) '(this (is a) list)))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-16.html#%25_thm_2.55][Exercise 2.55.]]

When this expression is evaluated, the outer ~quote~ is stripped, but the inner
one remains, giving the observed result, ~quote~.


*** 2.3.2: Example: Symbolic Differentiation

#+NAME: auxiliary-differentiation-procedures
#+BEGIN_SRC scheme
  ;; Provided in the book
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (=number? exp num)
    (and (number? exp) (= exp num)))
  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (list '+ a1 a2))))
  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2)) (* m1 m2))
          (else (list '* m1 m2))))
  (define (sum? x)
    (and (pair? x) (eq? (car x) '+)))
  (define (addend s) (cadr s))
  (define (augend s) (caddr s))
  (define (product? x)
    (and (pair? x) (eq? (car x) '*)))
  (define (multiplier p) (cadr p))
  (define (multiplicand p) (caddr p))
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
             (make-product (multiplier exp)
                           (deriv (multiplicand exp) var))
             (make-product (deriv (multiplier exp) var)
                           (multiplicand exp))))
          (else
           (error "unknown expression type -- DERIV" exp))))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-16.html#%25_thm_2.56][Exercise 2.56.]]

We define the exponentiation procedure:

#+NAME: ex-2-56-exponentiation
#+BEGIN_SRC scheme
  (define (make-exponentiation b e)
    (cond ((=number? b 1) 1)
          ((=number? e 0) 1)
          ((=number? e 1) b)
          ((and (number? b) (number? e)) (expt b e))
          (else (list '** b e))))
  (define (base e) (cadr e))
  (define (exponent e) (caddr e))
  (define (exponentiation? e)
    (and (pair? e) (eq? (car e) '**)))
#+END_SRC

and then re-define the top-level ~deriv~ procedure to include exponentiation.

#+NAME: ex-2-56-deriv
#+BEGIN_SRC scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
             (make-product (multiplier exp)
                           (deriv (multiplicand exp) var))
             (make-product (deriv (multiplier exp) var)
                           (multiplicand exp))))
          ((exponentiation? exp)
           (let ((b (base exp))
                 (e (exponent exp)))
             (make-product
               (if (number? e)
                 (make-product
                   (exponent exp)
                   (make-exponentiation (base exp)
                                        (make-sum (exponent exp) -1)))
                 (error "Can't evaluate non-constant exponents"))
               (deriv (base exp) var))))
          (else
           (error "unknown expression type -- DERIV" exp))))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-16.html#%25_thm_2.57][Exercise 2.57.]]
#+NAME: ex-2-57
#+BEGIN_SRC scheme
  (define (make-sum a . as)
    (define (rec a as)
      (if (null? as)
        (list a)
        (let ((a1 a)
              (a2 (car as))
              (arest (cdr as)))
          (cond ((=number? a1 0)
                 (rec a2 arest))
                ((=number? a2 0)
                 (rec a1 arest))
                ((and (number? a1) (number? a2))
                 (rec (+ a1 a2) arest))
                (else
                  (cons a1 (rec a2 arest)))))))
    (let ((val (rec a as)))
     (if (and (pair? val) (pair? (cdr val)))
       (cons '+ val)
       (car val))))
  (define (make-product m . ms)
    (define (rec m ms)
      (if (null? ms)
        (list m)
        (let ((m1 m)
              (m2 (car ms))
              (mrest (cdr ms)))
          (cond ((or (=number? m1 0) (=number? m2 0))
                 (list 0))
                ((=number? m1 1)
                 (rec m2 mrest))
                ((=number? m2 1)
                 (rec m1 mrest))
                ((and (number? m1) (number? m2))
                 (rec (* m1 m2) mrest))
                (else
                  (let ((val (rec m2 mrest)))
                   (if (=number? (car val) 0)
                     (list 0)
                     (cons m1 val))))))))
    (let ((val (rec m ms)))
     (if (and (pair? val) (pair? (cdr val)))
       (cons '* val)
       (car val))))
  (define (addend s) (cadr s))
  (define (augend s)
    (if (null? (cdddr s))
      (caddr s)
      (cons '+ (cddr s))))
  (define (multiplier p) (cadr p))
  (define (multiplicand s)
    (if (null? (cdddr s))
      (caddr s)
      (cons '* (cddr s))))
#+END_SRC

#+NAME: ex-2-57-test
#+BEGIN_SRC scheme
  (test 0
        (make-sum 0 0 0 0 0 0))
  (test 'x
        (make-sum (make-sum 'x)))
  (test '(+ x 3)
        (make-sum 'x 3))
  (test '(+ (+ x 3) (+ y 2))
        (make-sum (make-sum 'x 3)
                  (make-sum 'y 2)))
  (test 0
        (make-product 'x 'y 'z 0))
  (test 1
        (make-product 1 1 1 1 1 1))
  (test 'x
        (make-product (make-product 'x)))
  (test '(* x 3)
        (make-product 'x 3))
  (test '(* (* x 3) (* y 2))
        (make-product (make-product 'x 3)
                  (make-product 'y 2)))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-16.html#%25_thm_2.58][Exercise 2.58.]]

***** a. Differentiation in infix form, fully parenthesized
Given that each non-atomic expression is a list consisting of a left and right
expression separated by either a ~+~ or ~*~ symbol, differentiation is mostly
a case of pattern matching:

#+NAME: ex-2-58-a
#+BEGIN_SRC scheme
  (define (sum? x)
    (and (pair? x) (pair? (cdr x)) (eq? (cadr x) '+)))
  (define (product? x)
    (and (pair? x) (pair? (cdr x)) (eq? (cadr x) '*)))
  (define (addend s) (car s))
  (define (augend s) (caddr s))
  (define (multiplier p) (car p))
  (define (multiplicand p) (caddr p))

  (define (make-sum a1 a2)
    (cond ((=number? a1 0)
           a2)
          ((=number? a2 0)
           a1)
          ((and (number? a1) (number? a2))
           (+ a1 a2))
          (else
            (list a1 '+ a2))))
  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0))
           0)
          ((=number? m1 1)
           m2)
          ((=number? m2 1)
           m1)
          ((and (number? m1) (number? m2))
           (* m1 m2))
          (else
            (list m1 '* m2))))
#+END_SRC

#+NAME: ex-2-58-a-test
#+BEGIN_SRC scheme
  (define expr (make-sum 'x (make-product 3 (make-sum 'x (make-sum 'y 2)))))
  (test 4
        (deriv expr 'x))
  (test 3
        (deriv expr 'y))
  (test 0
        (deriv expr 'z))
#+END_SRC

***** b. Differentiation of infix form with precedence

With precedence, a non-atomic expression may now be a list of more than three
elements --- a well-formed non-atomic expression now begins and ends with a
expression (where an operator is not an expression) and alternates between
operators and expressions.

Nevertheless, we can continue to use the ~deriv~ procedure defined above just
by changing the predicates and selectors (in addition to the changes in
ex-2-58-a). Precedence is determined as follows:

- Sum: list contains ~+~
- Product: list contains ~*~ but not ~+~
- Exponent (not implemented): list contains ~**~ but not ~*~ or ~+~

The sum and product selectors consider everything to the left of the first
corresponding symbol to form the left subexpression and everything to the
right to form the right subexpression. The sum and product selectors are only
valid for lists for which ~sum?~ and ~product?~, respectively, return
true. ~deriv~ makes sure to obey this prerequisite (it would be nice if Scheme
had an assertion facility which could be disabled for performance -- this
requires a macro to avoid evaluating the condition).

Since the right subexpression consists of everything after the first operator,
these infix operators are right associative. I believe the ~+~ and ~*~
operators are conventionally assumed to be left associative, although I'm not
sure. It's not a problem here because these operators are commutative, but if
needed, left associativity can be implemented by searching for the last
occurrence of a symbol rather than the first.

#+NAME: ex-2-58-b
#+BEGIN_SRC scheme
  (define (sum? x)
    (and (pair? x) (pair? (cdr x)) (memq '+ x)))
  (define (product? x)
    (and (pair? x) (pair? (cdr x)) (and (memq '* x)
                                        (not (memq '+ x)))))

  (define (addend s)
    (let ((res (take-while (lambda (x) (not (eq? x '+))) s)))
     (if (null? (cdr res)) (car res) res)))
  (define (augend s)
    (let ((res (cdr (drop-while (lambda (x) (not (eq? x '+))) s))))
     (if (null? (cdr res)) (car res) res)))
  (define (multiplier p)
    (let ((res (take-while (lambda (x) (not (eq? x '*))) p)))
     (if (null? (cdr res)) (car res) res)))
  (define (multiplicand p)
    (let ((res (cdr (drop-while (lambda (x) (not (eq? x '*))) p))))
     (if (null? (cdr res)) (car res) res)))
#+END_SRC

#+NAME: ex-2-58-b-test
#+BEGIN_SRC scheme
  (define expr '(x + 3 * (x + y + 2)))

  (test 4
        (deriv expr 'x))
  (test 3
        (deriv expr 'y))
  (test 0
        (deriv expr 'z))
#+END_SRC


*** 2.3.3: Example: Representing Sets


*** 2.3.4: Example: Huffman Encoding Trees


** 2.4: Multiple Representations for Abstract Data

#+BEGIN_SRC scheme :tangle dispatch-table.scm
  ;; Operation, type -> procedure dispatch table.
  (use apropos)
  (if (not (= (length (apropos-list '*op-table*)) 1))
      (begin
        (display "Defining *op-table*")
        (newline)
        (define *op-table* (make-hash-table equal?))
        (define (put op type proc)
          (hash-table-set! *op-table* (list op type) proc))
        (define (get op type)
          (hash-table-ref *op-table* (list op type)))

        ;; Without loss of generality
        <<ex-2-78-type-tag-scheme-number>>

        (define (apply-generic op . args)
          (let ((type-tags (map type-tag args)))
            (let ((proc (get op type-tags)))
              (if proc
                  (apply proc (map contents args))
                  (error
                   "No method for these types -- APPLY-GENERIC"
                   (list op type-tags))))))))
#+END_SRC

*** 2.4.1: Representations for Complex Numbers

No exercises.

*** 2.4.2: Tagged data

No exercises.

*** 2.4.3: Data-Directed Programming and Additivity

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.73][Exercise 2.73.]]

a. We dispatch to an implementation of differentiation based on the operator of
   an expression, which indicates whether it's a sum, product, etc. Since
   numbers and variables are not operators, we cannot dispatch into the table
   based on them and must handle them specially.

b. Code:

   #+BEGIN_SRC scheme
     (define (install-deriv-package)
       ;; internal procedures
       (define (make-sum a1 a2) (list '+ a1 a2))
       (define (addend s) (car s))
       (define (augend s) (cadr s))

       (define (make-product m1 m2) (list '* m1 m2))
       (define (multiplier p) (car p))
       (define (multiplicand p) (cadr p))

       (define (deriv-sum exp var)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))

       (define (deriv-product exp var)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand  exp) var))
           (make-product (deriv (multiplier  exp) var)
                         (multiplicand exp))))

       ;; interface to the rest of the system
       (put 'deriv '+ deriv-sum)
       (put 'deriv '* deriv-product))
     (install-deriv-package)

   #+END_SRC

c. Here is an implementation for exponentiation:

   #+BEGIN_SRC scheme
     (define (make-exponentiation base power)
       (list '** base power))
     (define (base s) (car s))
     (define (exponent s) (cadr s))

     (define (deriv-exponentiation operands var)
       (make-product
         (make-product
           (exponent exp)
           (make-exponentiation
             (base exp)
             (- (exponent exp) 1)))
         (deriv (base exp) var)))
     (put 'deriv '** deriv-exponentiation)

   #+END_SRC

d. It is only necessary to change the places where the ~get~ or ~put~
   procedures are actually invoked. In my implementation above, since the only
   place these procedures are invoked besides in the definition of ~deriv~ is
   when registering the operator-specific commands, the order of the arguments
   to the ~put~ calls is the only thing to change.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.74][Exercise 2.74.]]

a. Assume that a procedure ~file-type~ can extract the type of a file without
   knowing the detailed structure of the file. For example, the first element
   of the file data structure always holds the type.

   The ~find-in-set~ procedure takes the set first and the key second.

   #+BEGIN_SRC scheme
     (define (get-record file employee-name)
       ((get (file-type file) 'find-in-set) file employee-name))
   #+END_SRC

b. Again, assume that the type of the record can be extracted without
   a detailed knowledge of the structure.

   Note that file and employee record types are in the same namespace so that
   the ~find-in-set~ procedure can easily be used for either.

   #+BEGIN_SRC scheme
     (define (get-salary record)
       ((get (record-type record) 'find-in-set) record 'salary))
   #+END_SRC

c. Note that this is abstracted away from the representation of the files and
   records -- everything is implemented in terms of the lower-level procedures
   given above.

   #+BEGIN_SRC scheme
     (define (find-employee-record files employee-name)
       (if (null? files)
         #f
         (let ((record (get-record (car files) employee-name)))
          (if record
            record
            (find-employee-record (cdr files) employee-name)))))
   #+END_SRC

d. Each file and employee record must be modified to place the type information
   in a place where ~file-type~ and ~record-type~ can extract it, and the
   primitive type-dependent procedures must be defined and put into the
   dispatch table.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.75][Exercise 2.75.]]

#+BEGIN_SRC scheme
  (define (make-from-mag-ang mag ang)
    (define (dispatch op)
      (cond ((eq? op 'magnitude) mag)
            ((eq? op 'angle) ang)
            ((eq? op 'real-part)
             (* mag (cos ang)))
            ((eq? op 'imag-part)
             (* mag (sin ang)))
            (else
             (error "Unknown op -- MAKE-FROM-MAG-ANG" op))))
    dispatch)

  (define pi (* 2 (asin 1)))
  (define z (make-from-mag-ang 1 (/ pi 4)))
  (test 1
        (z 'magnitude))
  (test (/ pi 4)
        (z 'angle))
  (test (/ (sqrt 2) 2)
        (z 'real-part))
  (test (/ (sqrt 2) 2)
        (z 'imag-part))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.76][Exercise 2.76.]]

Steps to add types or operations:

- explicit dispatch :: Need to add an additional case in every operation when a
     new type is added, and need to explicitly dispatch on all types when a new
     operation is added.

- data-directed style :: can add new types easily by implementing all the
     operations in a package and then importing it.

- message-passing style :: can add new operations easily defined for a type, it
     can fall back to a default implementation or an error -- but adding new
     operations requires modifying every type.


** 2.5: Systems with Generic Operations

*** Auxiliary definitions

#+BEGIN_SRC scheme :tangle generic-arithmetic-procedures.scm
  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))
#+END_SRC

#+BEGIN_SRC scheme :tangle scheme-number-package.scm
  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
         (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
         (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
         (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
         (lambda (x y) (tag (/ x y))))
    (put 'make '(scheme-number)
         (lambda (x) (tag x)))
    'done)
  (install-scheme-number-package)
  (define (make-scheme-number n)
    ((get 'make '(scheme-number)) n))
#+END_SRC


*** 2.5.1: Generic Arithmetic Operations

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.77][Exercise 2.77.]]

#+BEGIN_SRC scheme
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
#+END_SRC

The ~real-part~, etc. functions are in fact simple wrappers around the
application of the corresponding generic operations:

#+BEGIN_SRC scheme
  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))
#+END_SRC

The ~rectangular~ and ~polar~ packages define internal procedures to implement
these generic operations. The generic operations defined for ~complex~ numbers
just end up dispatching to the corresponding generic ~rectangular~ or ~polar~
operations, only after which is the underlying internal function called.

For example, calling ~(magnitude z)~, where ~z~ is a ~complex~ number, results
in the following calls:

#+BEGIN_SRC scheme
  ;; Original application to complex type.
  (magnitude z)
  ;; Expansion from generic definition of magnitude.
  (apply-generic 'magnitude z)
  ;; Definition in this problem applies magnitude to contents of z (which may be
  ;; rectangular or polar).
  (magnitude (contents z))
  ;; Again, expansion from generic definition of magnitude.
  (apply-generic 'magnitude (contents z))
  ;; Application of generic magnitude operation to numbers tagged rectangular or
  ;; polar results in calling the implementation of magnitude internal to the
  ;; package.
  (internal-magnitude (contents (contents z)))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.78][Exercise 2.78.]]

We special-case numbers to return ~scheme-number~ as their type tag and avoid
adding the type tag to numbers that would otherwise be tagged with
~scheme-number~.

#+NAME: ex-2-78-type-tag-scheme-number
#+BEGIN_SRC scheme
  (include "generic-arithmetic-procedures.scm")
  (include "scheme-number-package.scm")
  (define (attach-tag type-tag contents)
    (if (and (equal? type-tag 'scheme-number)
             ;; Leave open the possibility to apply SCHEME-NUMBER to non-numbers.
             (number? contents))
        contents
        (cons type-tag contents)))
  (define (type-tag datum)
    (cond ((number? datum) 'scheme-number)
          ((pair? datum) (car datum))
          (else error "Bad tagged datum -- TYPE-TAG" datum)))
  (define (contents datum)
    (cond ((number? datum) datum)
          ((pair? datum) (cdr datum))
          (else (error "Bad tagged datum -- CONTENTS" datum))))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.79][Exercise 2.79.]]

We define the top-level generic function for convenience:

#+BEGIN_SRC scheme :tangle generic-equ.scm
  (include "dispatch-table.scm")
  <<ex-2-79-impl>>
  (define equ? (apply-generic 'equ? x y))
#+END_SRC

Install the following functions as implementations for ~equ?~ in the
corresponding packages:

#+NAME: ex-2-79-impl
#+BEGIN_SRC scheme
  (define (equ?-scheme-number x y)
    (= x y))
  (put 'equ? '(scheme-number scheme-number) equ?-scheme-number)

  (define (equ?-rat x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (put 'equ? '(rational rational) equ?-rat)

  (define (equ?-complex x y)
    (and (= (real-part x) (real-part y)
            (imag-part x) (imag-part y))))
  (put 'equ? '(complex complex) equ?-complex)
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.80][Exercise 2.80.]]

We define the top-level generic function for convenience:

#+BEGIN_SRC scheme :tangle generic-zero.scm
  (include "dispatch-table.scm")
  <<ex-2-80-impl>>
  (define =zero? (lambda (x)  (apply-generic '=zero? x)))
#+END_SRC

Install the following functions as implementations for ~=zero?~ in the
corresponding packages:

#+NAME: ex-2-80-impl
#+BEGIN_SRC scheme
  (define (=zero?-scheme-number x)
    (= x 0))
  (put '=zero? '(scheme-number) =zero?-scheme-number)

  (define (=zero?-complex x y)
    (= (magnitude x) 0))
  (put '=zero? '(complex) =zero?-complex)
#+END_SRC

One could also imagine defining ~=zero?~ as a generic function

#+BEGIN_SRC scheme
  (define (=zero? x)
    (equ? x (zero x)))
#+END_SRC

where ~zero~ is a function that returns a zero value of the type of
~x~. Assuming ~equ?~ properly equates zero values that have the same type but
different representations (e.g., for ~rat~ and ~polar~ numbers), the above
definition will work. However, this requires another operation to be defined
anyway, and makes it harder to override the ~=zero?~ operation per-type in the
event that such an override is desirable for efficiency or correctness.


*** 2.5.2: Combining Data of Different Types

**** Auxiliary definitions

#+BEGIN_SRC scheme :tangle coercion-table.scm
  (define *coercion-table* (make-hash-table equal?))

  (define (put-coercion type-from type-to proc)
    (hash-table-set!
     *coercion-table*
     (list type-from type-to)
     proc))

  (define (get-coercion type-from type-to)
    (hash-table-ref
     *coercion-table*
     (list type-from type-to)))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.81][Exercise 2.81.]]

a. If ~exp~ is called with two ~complex~ numbers as arguments, ~apply-generic~
   will fail to find an implementation of ~exp~ for the arguments. However, it
   will then find a coercion ~complex->complex~ for ~t1->t2~ and then re-apply
   the ~exp~ operation with ~t1->t2~ applied to the first argument. Since this
   applies ~exp~ once again to two ~complex~ arguments, Louis' conversions
   will lead to an infinite loop.

b. Louis is not correct -- ~apply-generic~ works as is because it searches for
   an implementation of the generic operation for the argument types given
   before attempting coercion. If an implementation is found, coercion is
   never attempted, so there is no need to provide a coercion operation from a
   type to itself.

c. From the above, it is clear that the only time ~apply-generic~ would look
   for a conversion from a type to itself is when

   - The two arguments have the same type.
   - An implementation of the generic operation was not found.

   Therefore, the only thing to do is to raise an error for the lack of an
   implementation:

   #+BEGIN_SRC scheme
     (define (apply-generic op . args)
       (define (no-method op type-tags)
         (error "No method for these types"
                (list op type-tags)))
       (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
           (if proc
               (apply proc (map contents args))
               (if (= (length args) 2)
                   (let ((type1 (car type-tags))
                         (type2 (cadr type-tags))
                         (a1 (car args))
                         (a2 (cadr args)))
                     (if (equal? type1 type2)
                         (no-method op type-tags)
                         (let ((t1->t2 (get-coercion type1 type2))
                               (t2->t1 (get-coercion type2 type1)))
                           (cond (t1->t2
                                  (apply-generic op (t1->t2 a1) a2))
                                 (t2->t1
                                  (apply-generic op a1 (t2->t1 a2)))
                                 (else
                                  (no-method op type-tags))))))
                   (no-method op type-tags))))))
   #+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.82][Exercise 2.82.]]

Here's the steps:

- First, test if the args are the proper types already for the operation. If
  so, apply the op and return the result.
- Else, we'll want to keep the list of arguments, as well as keep an index to
  the current argument, whose type we want to coerce all the other arguments
  to.
#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (define (no-method op type-tags)
      (error "No method for these types"
             (list op type-tags)))
    (define (attempt-coercion tried to-try)
      (if (null? to-try)
          (no-method op (map type-tag tried))
          (letrec ((current-arg (car to-try))
                   (current-type (type-tag current-arg))
                   (coerce-to-current
                    (lambda (x)
                      ((get-coercion (type-tag x) current-type) x)))
                   (coerced-args
                    (append (map coerce-to-current tried)
                            (list current-arg)
                            (map coerce-to-current (cdr to-try)))))
            (if (/= (length coerced-args)
                   (length (append tried to-try)))
                (attempt-coercion (append tried (list (car to-try)))
                                  (cdr to-try))
                (apply apply-generic op coerced-args)))))
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (attempt-coercion '() args)))))
#+END_SRC

This procedure works for some simple cases. However, if

- the arguments to ~apply-generic~ are not of the appropriate type for ~op~,
- one argument ~t1~ cannot be coerced to the type of another argument ~t2~,
- a coercion for ~t1~ exists such that the argument list is valid for ~op~,

an appropriate coercion will not be found even though it exists.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.83][Exercise 2.83.]]

#+BEGIN_SRC scheme
  ;; Install these in the corresponding packages to implement the generic RAISE
  ;; operation.
  (define (raise-integer->rational x)
    (make-rat x 1))
  (define (raise-rational->real x)
    (/ (numer x) (denom x)))
  (define (raise-real->complex x)
    (make-from-real-imag x 0))

  ;; Raise over any numeric type
  (define (raise x) (apply-generic 'raise x))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.84][Exercise 2.84.]]

For simplicity, use the earlier two-argument version of ~apply-generic~.

One simple way to extend the earlier ~apply-generic~ procedure is to first
attempt coercing the arguments as before

#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (define (no-method op type-tags)
      (error "No method for these types"
             (list op type-tags)))
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (if (= (length args) 2)
                (let ((type1 (car type-tags))
                      (type2 (cadr type-tags))
                      (a1 (car args))
                      (a2 (cadr args)))
                  (if (equal? type1 type2)
                      (no-method op type-tags)
                      (let ((t1->t2 (get-coercion type1 type2))
                            (t2->t1 (get-coercion type2 type1)))
                        (cond (t1->t2
                               (apply-generic op (t1->t2 a1) a2))
                              (t2->t1
                               (apply-generic op a1 (t2->t1 a2)))
                              (else
                               (no-method op type-tags))))))
                (no-method op type-tags))))))
#+END_SRC


*** 2.5.3: Example: Symbolic Algebra

I've decided to distinguish dense and sparse polynomials with the ~poly-dense~
and ~poly-sparse~ tags to allow keeping functions for both variants defined at
the same time. A similar distinction is made when defining auxiliary functions
for the two types before putting them in the dispatch table.

**** Auxiliary definitions

#+BEGIN_SRC scheme :tangle poly-sparse-package.scm
  ;; <procedures same-variable? and variable? from section 2.3.2>
  (include "dispatch-table.scm")
  (include "generic-zero.scm")
  (include "generic-neg.scm")
  (include "generic-reduce.scm")
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  
  (define (install-poly-sparse-package)
    <<poly-sparse-basic-procs>>

    <<poly-sparse-arithmetic-terms>>

    <<poly-sparse-arithmetic-poly>>

    ;; interface to rest of the system
    (put 'make '(poly-sparse)
         (lambda (var terms) (tag (make-poly-sparse var terms))))
    'done)
  (install-poly-sparse-package)
  (define (make-poly-sparse var terms)
    ((get 'make '(poly-sparse)) var terms))
#+END_SRC

#+NAME: poly-sparse-basic-procs
#+BEGIN_SRC scheme
  ;; internal procedures
  ;; representation of poly
  (define (make-poly-sparse variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  ;; <procedures same-variable? and variable? from section 2.3.2>
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  ;; representation of terms and term lists
  ;; <procedures adjoin-term ...coeff from text below>
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  (define (tag p) (attach-tag 'poly-sparse p))
#+END_SRC

#+NAME: poly-sparse-arithmetic-terms
#+BEGIN_SRC scheme
  <<poly-sparse-add-terms>>
  <<poly-sparse-sub-terms>>
  <<poly-sparse-mul-terms>>
  <<poly-sparse-div-terms>>
  <<ex-2-94-terms>>
  <<ex-2-96-improved-terms>>
  <<ex-2-96-reimproved-terms>>
  <<poly-sparse-reduce-terms>>
#+END_SRC

#+NAME: poly-sparse-add-terms
#+BEGIN_SRC scheme
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1)) (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
#+END_SRC

#+NAME: poly-sparse-mul-terms
#+BEGIN_SRC scheme
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))
#+END_SRC

#+NAME: poly-sparse-arithmetic-poly
#+BEGIN_SRC scheme
  ;; Arithmetic on polynomials in terms of arithmetic on their term lists.
  <<ex-2-87-zero>>
  (define (neg-poly-sparse p)
    (make-poly-sparse (variable p)
                      (neg-terms (term-list p))))
  (put 'neg '(poly-sparse)
       (lambda (x) (tag (neg-poly-sparse x))))
  (define (add-poly-sparse p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly-sparse (variable p1)
                          (add-terms (term-list p1) (term-list p2)))
        (error "ADD-POLY -- cannot add two polynomials with different variables")))
  (put 'add '(poly-sparse poly-sparse)
       (lambda (x y) (tag (add-poly-sparse x y))))
  (define (sub-poly-sparse p1 p2)
    (add-poly-sparse p1 (neg-poly-sparse p2)))
  (put 'sub '(poly-sparse poly-sparse)
       (lambda (x y) (tag (sub-poly-sparse x y))))
  (define (mul-poly-sparse p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly-sparse (variable p1)
                          (mul-terms (term-list p1) (term-list p2)))
        (error "MUL-POLY -- cannot multiply two polynomials with different variables")))
  (put 'mul '(poly-sparse poly-sparse)
       (lambda (x y) (tag (mul-poly-sparse x y))))
  <<ex-2-91-div-poly-sparse>>
  <<ex-2-94-gcd-poly-sparse>>
  <<ex-2-96-improved-gcd-poly-sparse>>
  <<ex-2-96-reimproved-gcd-poly-sparse>>
  <<poly-sparse-reduce>>
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.87][Exercise 2.87.]]

Install ~=zero?~ for polynomials in the generic arithmetic package. This will
allow ~adjoin-term~ to work for polynomials with coefficients that are
themselves polynomials.

#+NAME: ex-2-87-zero
#+BEGIN_SRC scheme
  (include "generic-zero.scm")
  (define (=zero?-poly-sparse p)
    (let =zero?-terms ((terms (term-list p)))
      (or (empty-termlist? terms)
          (and (=zero? (coeff (first-term terms)))
               (=zero?-terms (rest-terms terms))))))
  (put '=zero? 'poly-sparse =zero?-poly-sparse)
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.88][Exercise 2.88.]]

We define subtraction in terms of negation. For this, it is useful to have a
generic negation function ~neg~:

#+BEGIN_SRC scheme :tangle generic-neg.scm
  (include "dispatch-table.scm")
  <<ex-2-88-neg-monomial>>
  (define (neg x) (apply-generic 'neg x))
#+END_SRC

#+NAME: ex-2-88-neg-monomial
#+BEGIN_SRC scheme
  (define (neg-complex z)
    (make-from-real-imag (- (real-part z))
                         (- (imag-part z))))
  (put 'neg '(complex) neg-complex)
  (put 'neg '(scheme-number)
       (lambda (x) (attach-tag 'scheme-number (- x))))
#+END_SRC

#+NAME: poly-sparse-sub-terms
#+BEGIN_SRC scheme
  (include "generic-neg.scm")
  (define (neg-terms terms)
    (if (empty-termlist? terms)
        (the-empty-termlist)
        (adjoin-term (make-term (order (first-term terms))
                                (neg (coeff (first-term terms))))
                     (neg-terms (rest-terms terms)))))
  (define (sub-terms L1 L2)
    (add-terms L1 (neg-terms L2)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-2-89-test.scm
  <<poly-sparse-basic-procs>>
  <<poly-sparse-sub-terms>>
  (test '((5 -3) (3 1))
        (neg-terms '((5 3) (3 -1))))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.89][Exercise 2.89.]]

#+BEGIN_SRC scheme :tangle poly-dense-package.scm
  (define (install-poly-dense-package)
    ;; internal procedures
    ;; representation of poly
    (define (make-poly variable term-list)
      (cons variable term-list))
    (define (variable p) (car p))
    (define (term-list p) (cdr p))
    ;; <procedures same-variable? and variable? from section 2.3.2>
    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    ;; representation of terms and term lists
    ;; <procedures adjoin-term ...coeff from text below>
    (define (adjoin-term term term-list)
      (if (=zero? term)
          term-list
          (cons term term-list)))
    (define (the-empty-termlist) '())
    (define (first-term term-list) (car term-list))
    (define (rest-terms term-list) (cdr term-list))
    (define (empty-termlist? term-list) (null? term-list))

    (define (add-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (add-terms (term-list p1) (term-list p2))))
      (error "ADD-POLY -- cannot add two polynomials with different variables"))
    ;; <procedures used by add-poly>
    (define (add-terms L1 L2)
      (let (rec (L1 L1)
                (L2 L2)
                (o1 (length L1))
                (o2 (length L2)))
        (cond ((empty-termlist? L1) L2)
              ((empty-termlist? L2) L1)
              ((> o1 o2)
               (adjoin-term (first-term L1) (rec (rest-terms L1) L2 (- o1 1) o2)))
              ((> o2 o1)
               (adjoin-term (first-term L2) (rec L1 (rest-terms L2) o1 (- o2 1))))
              (else
               (adjoin-term (add (first-term L1)
                                 (first-term L2))
                            (rec (rest-terms L1) (rest-terms L2)
                                 (- o1 1) (- o2 1)))))))
    (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (mul-terms (term-list p1) (term-list p2))))
      (error "MUL-POLY -- cannot multiply two polynomials with different variables"))
    ;; <procedures used by mul-poly>
    (define (mul-terms L1 L2)
      (let (rec ((L1 L1)
                 (L2 L2)
                 (o1 (- (length L1) 1)))
                (if (empty-termlist? L1)
                    (the-empty-termlist)
                    (add-terms (mul-term-by-all-terms (first-term L1) o1 L2)
                               (rec (rest-terms L1) L2 (- o1 1)))))))
    ;; c1, o1 -- coefficient, order of term to be multiplied by term list L
    ;; First multiply terms by c1, then append a list of (+ o1 1) zeros to the
    ;; end of L to represent the multiplication by the inderminate variable
    ;; raised to the power of o1.
    (define (mul-term-by-all-terms c1 o1 L)
      (define (rec c1 o1 L)
        (if (empty-termlist? L)
            (the-empty-termlist)
            (let ((t2 (first-term L)))
              (adjoin-term
               (mul c1 t2)
               (rec c1 (- o1 1) (rest-terms L))))))
      (append (rec t1 o1 L)
              (repeat 0 (+ o1 1))))
    ;; interface to rest of the system
    (define (tag p) (attach-tag 'poly-dense p))
    (put 'add '(poly-dense poly-dense)
         (lambda (p1 p2) (tag (add-poly p1 p2))))
    (put 'mul '(poly-dense poly-dense)
         (lambda (p1 p2) (tag (mul-poly p1 p2))))
    (put 'make '(poly-dense)
         (lambda (var terms) (tag (make-poly var terms))))
    'done)
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html\#%25_thm_2.90][Exercise 2.90.]]

We first want to define some coercions. I will use the ~get-coercion~ and
~put-coercion~ interface for this.

#+BEGIN_SRC scheme
  (include "coercion-table.scm")
  (define (coerce-poly-sparse->poly-dense p)
    (define (coeff t) (car t))
    (define (order t) (cdr t))
    (define (tag p) (attach-tag 'poly-dense p))
    (let ((terms (cdr p))
          (var (car p)))
      (cons var
            (list
             (let (rec (terms terms)
                       (o (order (car terms))))
               (cond ((null? terms)
                      '())
                     ((> o (order (car terms)))
                      (cons (attach-tag 'scheme-number 0)
                            (rec terms (- o 1))))
                     (else
                      (cons (coeff (car terms))
                            (rec terms (- o 1))))))))))
  (define (coerce-poly-dense->poly-sparse p)
    (define (make-term coeff order) (cons coeff order))
    (define (tag p) (attach-tag 'poly-dense p))
    (let ((terms (cdr p))
          (var (car p)))
      (cons var
            (list
             (let (rec (terms terms)
                       (o (- (length terms) 1)))
               (cond ((null? terms)
                      '())
                     ((=zero? (car terms))
                      (rec (cdr terms) (- o 1)))
                     (else
                      (cons (make-term (car terms) o)
                            (rec (cdr terms) (- o 1))))))))))
  (put-coercion 'poly-sparse 'poly-dense coerce-poly-sparse->poly-dense)
  (put-coercion 'poly-dense 'poly-sparse coerce-poly-dense->poly-sparse)
#+END_SRC

The idea here is to define a type ~poly-generic~, whose contents we assume are
always another tagged value (of type ~poly-sparse~ or ~poly-dense~, or perhaps
another representation that may be added in the future). Unfortunately, this
design requires manually coercing a ~poly-generic~ value to the underlying
representation, which is a major flaw the ~complex~ example doesn't have. This
arises because, unlike ~complex~, there are no primitives provided for the
polynomial types below ~add~, ~sub~, etc. with which these procedures can be
implemented.

#+BEGIN_SRC scheme
  (define (install-poly-generic-package)
    (define (tag x) (attach-tag 'poly-generic x))
    (put 'neg '(poly-generic)
         (lambda (p)
           (tag (neg (contents p)))))
    (put 'add '(poly-generic poly-generic)
         (lambda (p1 p2)
           (tag (add (contents p1) (contents p2)))))
    (put 'sub '(poly-generic poly-generic)
         (lambda (p1 p2)
           (tag (sub (contents p1) (contents p2)))))
    (put 'mul '(poly-generic poly-generic)
         (lambda (p1 p2)
           (tag (mul (contents p1) (contents p2)))))
    (put 'make '(poly-generic)
         (lambda (var terms)
           (tag ((get 'poly-sparse 'make) var terms))))
    'done)
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.91][Exercise 2.91.]]

#+NAME: poly-sparse-div-terms
#+BEGIN_SRC scheme :tangle ex-2-91-division.scm
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       (div-terms
                        (sub-terms L1
                                   (mul-terms (list (make-term new-o new-c))
                                              L2))
                        L2)))
                  (list (adjoin-term (make-term new-o new-c)
                                     (list-ref rest-of-result 0))
                        (list-ref rest-of-result 1))))))))
#+END_SRC

#+NAME: ex-2-91-div-poly-sparse
#+BEGIN_SRC scheme
  (define (div-poly-sparse p1 p2)
    (if (same-variable? (variable p1)
                        (variable p2))
        (letrec ((var (variable p1))
                 (result (div-terms (term-list p1)
                                    (term-list p2)))
                 (quotient (list-ref result 0))
                 (remainder (list-ref result 1)))
          (list (make-poly-sparse var quotient)
                (make-poly-sparse var remainder)))
        (error "DIV-POLY-SPARSE -- division between different variables NYI")))
  (put 'div '(poly-sparse poly-sparse)
       (lambda (p1 p2) (map tag (div-poly-sparse p1 p2))))
#+END_SRC

#+NAME: ex-2-91-test
#+BEGIN_SRC scheme :tangle ex-2-91-test.scm
  (use test)
  (include "poly-sparse-package.scm")
  (define tl1 '((5 1) (0 -1)))
  (define tl2 '((2 1) (0 -1)))
  (define p1 (make-poly-sparse 'x tl1))
  (define p2 (make-poly-sparse 'x tl2))
  (define result-quotient (make-poly-sparse 'x '((3 1) (1 1))))
  (define result-remainder (make-poly-sparse 'x '((1 1) (0 -1))))
  (test (list result-quotient result-remainder)
        (div p1 p2))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.92][Exercise 2.92.]]

Skipping.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.93][Exercise 2.93.]]

#+BEGIN_SRC scheme :tangle rational-package.scm
  (include "dispatch-table")
  (include "generic-zero")
  (include "generic-neg")
  (define (install-rational-package)
    ;; internal procedures
    (define (numer x) (list-ref x 0))
    (define (denom x) (list-ref x 1))
    (define (make-rat n d)
      (list n d))

    (define (=zero?-rat x y)
      (and (= (numer x) 0)
           ;; Denominator of 0 is undefined -- choose not to make such a number
           ;; equal to 0 even if the numerator is 0.
           (not (= (denom x) 0))))
    (define (neg-rat x)
      (make-rat (neg (numer x)) (denom x)))
    (define (add-rat x y)
      (make-rat (add (mul (numer x) (denom y))
                     (mul (numer y) (denom x)))
                (mul (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (sub (mul (numer x) (denom y))
                     (mul (numer y) (denom x)))
                (mul (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (mul (numer x) (numer y))
                (mul (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (mul (numer x) (denom y))
                (mul (denom x) (numer y))))
    ;; interface to rest of the system
    (define (tag x) (attach-tag 'rational x))
    (put '=zero? '(rational) =zero?-rat)
    (put 'neg '(rational) neg-rat)
    (put 'add '(rational rational)
         (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
         (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
         (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
         (lambda (x y) (tag (div-rat x y))))
  
    (put 'make 'rational
         (lambda (n d) (tag (make-rat n d))))
    'done)
  (install-rational-package)
  (define (make-rational n d)
    ((get 'make 'rational) n d))
#+END_SRC


#+BEGIN_SRC scheme :tangle ex-2-93-test.scm
  (include "poly-sparse-package")
  (include "rational-package")
  (define p1 (make-poly-sparse 'x '((2 1)(0 1))))
  (define p2 (make-poly-sparse 'x '((3 1)(0 1))))
  (define rf (make-rational p2 p1))
  (define result (make-rational (make-poly-sparse 'x '((5 2) (3 2) (2 2) (0 2)))
                                (make-poly-sparse 'x '((4 1) (2 2) (0 1)))))
  (test result
        (add rf rf))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%25_thm_2.94][Exercise 2.94.]]

#+NAME: ex-2-94-terms
#+BEGIN_SRC scheme
  (define (remainder-terms L1 L2)
    (list-ref (div-terms L1 L2) 1))
  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (remainder-terms a b))))
#+END_SRC

#+NAME: ex-2-94-gcd-poly-sparse
#+BEGIN_SRC scheme
  (define (gcd-poly-sparse p1 p2)
    (if (same-variable? (variable p1)
                        (variable p2))
        (letrec ((var (variable p1))
                 (result (gcd-terms (term-list p1)
                                    (term-list p2))))
          (make-poly-sparse var result))
        (error "GCD-POLY -- GCD between different variables NYI")))
  (put 'greatest-common-divisor '(poly-sparse poly-sparse)
       (lambda (x y) (tag (gcd-poly-sparse x y))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-2-94-test.scm
  (use test)
  (include "poly-sparse-package")
  (define p1 (make-poly-sparse 'x '((4 1) (3 -1) (2 -2) (1 2))))
  (define p2 (make-poly-sparse 'x '((3 1) (1 -1))))
  (define gcd (make-poly-sparse 'x '((2 -1) (1 1))))
  (test gcd
        (apply-generic 'greatest-common-divisor p1 p2))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%25_thm_2.95][Exercise 2.95.]]

#+BEGIN_SRC scheme :tangle ex-2-95-test.scm
  (use test)
  (include "poly-sparse-package")
  (define p1 (make-poly-sparse 'x '((2 1) (1 -2) (0 1))))
  (define p2 (make-poly-sparse 'x '((2 11) (0 7))))
  (define p3 (make-poly-sparse 'x '((1 13) (0 5))))
  (define q1 (mul p1 p2))
  (define q2 (mul p1 p3))
  (parameterize ((test-epsilon 0.01))
                (test '(0 1.10004)
                      (caddr (apply-generic 'greatest-common-divisor q1 q2))))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%25_thm_2.96][Exercise 2.96.]]

a. Pseudoremainder

#+NAME: ex-2-96-improved-terms
#+BEGIN_SRC scheme
  (define (pseudoremainder-terms L1 L2)
    (letrec ((integerizing-factor (expt (coeff (first-term L2))
                                        (+ 1 (- (order (first-term L1))
                                                (order (first-term L2))))))
             (dividend (mul-terms L1 `((0 ,integerizing-factor)))))
      (list-ref (div-terms dividend L2) 1)))
  (define (improved-gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (pseudoremainder-terms a b))))
#+END_SRC

#+NAME: ex-2-96-improved-gcd-poly-sparse
#+BEGIN_SRC scheme
  (define (improved-gcd-poly-sparse p1 p2)
    (if (same-variable? (variable p1)
                        (variable p2))
        (letrec ((var (variable p1))
                 (result (improved-gcd-terms (term-list p1)
                                             (term-list p2))))
          (make-poly-sparse var result))
        (error "GCD-POLY -- GCD between different variables NYI")))
  (put 'improved-greatest-common-divisor '(poly-sparse poly-sparse)
       (lambda (x y) (tag (improved-gcd-poly-sparse x y))))
#+END_SRC


b. Reduce to lowest terms

#+NAME: ex-2-96-gcd-integer
#+BEGIN_SRC scheme
  (define (gcd a . terms)
    (define (gcd-dyadic a b)
      (if (= b 0)
          a
          (gcd-dyadic b (remainder a b))))
    (fold gcd-dyadic 0 (append (list a) terms)))
#+END_SRC

#+NAME: ex-2-96-reimproved-terms
#+BEGIN_SRC scheme
  <<ex-2-96-gcd-integer>>
  (define (reimproved-gcd-terms a b)
    (define (rec a b)
      (if (empty-termlist? b)
          a
          (gcd-terms b (pseudoremainder-terms a b))))
    (letrec ((gcd-terms-result (rec a b))
             (common-coeff (apply gcd (map coeff gcd-terms-result))))
      (div-terms gcd-terms-result (list (make-term 0 common-coeff)))))
#+END_SRC

#+NAME: ex-2-96-reimproved-gcd-poly-sparse
#+BEGIN_SRC scheme
  (define (reimproved-gcd-poly-sparse p1 p2)
    (if (same-variable? (variable p1)
                        (variable p2))
        (letrec ((var (variable p1))
                 (result (reimproved-gcd-terms (term-list p1)
                                               (term-list p2))))
          (make-poly-sparse var result))
        (error "GCD-POLY -- GCD between different variables NYI")))
  (put 'reimproved-greatest-common-divisor '(poly-sparse poly-sparse)
       (lambda (x y) (tag (reimproved-gcd-poly-sparse x y))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-2-96-test.scm
  (use test)
  (include "poly-sparse-package")
  (define p1 (make-poly-sparse 'x '((2 1) (1 -2) (0 1))))
  (define p2 (make-poly-sparse 'x '((2 11) (0 7))))
  (define p3 (make-poly-sparse 'x '((1 13) (0 5))))
  (define q1 (mul p1 p2))
  (define q2 (mul p1 p3))
  (define improved-result (make-poly-sparse 'x '((2 1458) (1 -2916) (0 1458))))
  (test improved-result
        (apply-generic 'improved-greatest-common-divisor q1 q2))
  (define reimproved-result (make-poly-sparse 'x '((2 1) (1 -2) (0 1))))
  (test reimproved-result
        (apply-generic 'reimproved-greatest-common-divisor q1 q2))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%25_thm_2.97][Exercise 2.97.]]

#+BEGIN_SRC scheme
  (define (reduce-integers n d)
    (let ((g (gcd n d)))
      (list (/ n g) (/ d g))))
#+END_SRC

#+BEGIN_SRC scheme
  (define (reduce n d)
    (lambda (n d) (apply-generic 'reduce n d)))
#+END_SRC

#+NAME: poly-sparse-reduce-terms
#+BEGIN_SRC scheme
  (define (reduce-terms n d)
    (define (scalar-terms c) (list (make-term 0 c)))
    (letrec (
             ;; Compute GCD of terms using code from Exercise 2.96
             (gcd-n-d (reimproved-gcd-terms n d))
             ;; Multiply numerator and denominator by integerizing factor before
             ;; dividing both by GCD to ensure no noninteger coefficients are
             ;; introduced.
             (integerizing-factor (expt (coeff (first-term gcd-n-d))
                                        (+ 1 (- (max (order (first-term n))
                                                     (order (first-term d)))
                                                (order (first-term gcd-n-d))))))
             (n-integerized (mul-terms n (scalar-terms integerizing-factor)))
             (d-integerized (mul-terms d (scalar-terms integerizing-factor)))
             (n-reduced (div-terms n-integerized gcd-n-d))
             (d-reduced (div-terms d-integerized gcd-n-d)))
      (begin
        ;; Division by GCD of numerator and denominator should produce no
        ;; remainder by definition.
        (define (quotient-terms x) (list-ref x 0))
        (define (remainder-terms x) (list-ref x 1))
        (assert (empty-termlist? (remainder-terms n-reduced)))
        (assert (empty-termlist? (remainder-terms d-reduced)))
        (letrec ((gcd-coeffs (apply gcd (append (map coeff (quotient-terms n-reduced))
                                                (map coeff (quotient-terms d-reduced)))))
                 (nn (div-terms n-reduced (scalar-terms gcd-coeffs)))
                 (dd (div-terms d-reduced (scalar-terms gcd-coeffs))))
          (list nn dd)))))
#+END_SRC

#+NAME: poly-sparse-reduce
#+BEGIN_SRC scheme
  (define (reduce-poly-sparse p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (map (lambda (p) (make-poly-sparse (variable p1) p))
             (reduce-terms (term-list p1) (term-list p2)))
        (error "REDUCE-POLY -- cannot reduce two polynomials with different variables")))
  (put 'reduce '(poly-sparse poly-sparse)
       (lambda (x y) (tag (reduce-poly-sparse x y))))
#+END_SRC

#+NAME: ex-2-97-reduce-integers
#+BEGIN_SRC scheme
  (define (reduce-integers n d)
    <<ex-2-96-gcd-integers>>
    (let ((g (gcd n d)))
      (list (/ n g) (/ d g))))
  (put 'reduce '(scheme-number scheme-number)
       (lambda (x y) (attach-tag 'scheme-number (reduce-integers x y))))
#+END_SRC

#+BEGIN_SRC scheme :tangle generic-reduce.scm
  (include "dispatch-table.scm")
  <<ex-2-97-reduce-integers>>
  (define (reduce x y) (apply-generic 'reduce x y))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-2-97-test.scm
  (use test)
  (include "poly-sparse-package")
  (include "rational-package")
  (define p1 (make-poly-sparse 'x '((1 1)(0 1))))
  (define p2 (make-poly-sparse 'x '((3 1)(0 -1))))
  (define p3 (make-poly-sparse 'x '((1 1))))
  (define p4 (make-poly-sparse 'x '((2 1)(0 -1))))

  (define rf1 (make-rational p1 p2))
  (define rf2 (make-rational p3 p4))

  (define result (make-rational (make-poly-sparse 'x '((4 1) (3 1) (2 1) (1 -2) (0 -1)))
                                (make-poly-sparse 'x '((5 1) (3 -1) (2 -1) (0 1)))))
  (test result
        (add rf1 rf2))
#+END_SRC
