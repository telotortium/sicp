#+BEGIN_SRC scheme
  (use sicp test)
#+END_SRC

* Chapter 2

** 2.4: Multiple Representations for Abstract Data

#+BEGIN_SRC scheme
  ;; Operation, type -> procedure dispatch table.
  (define *op-table* (make-hash-table equal?))
  (define (put op type proc)
    (hash-table-set! *op-table* (list op type) proc))
  (define (get op type)
    (hash-table-ref *op-table* (list op type)))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))
  (define (type-tag datum)
    (if (pair? datum)
        (car datum)
        (error "Bad tagged datum -- TYPE-TAG" datum)))
  (define (contents datum)
    (if (pair? datum)
        (cdr datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (error
             "No method for these types -- APPLY-GENERIC"
             (list op type-tags))))))
#+END_SRC

*** 2.4.1: Representations for Complex Numbers

No exercises.

*** 2.4.2: Tagged data

No exercises.

*** 2.4.3: Data-Directed Programming and Additivity

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.73][Exercise 2.73.]]

a. We dispatch to an implementation of differentiation based on the operator of
   an expression, which indicates whether it's a sum, product, etc. Since
   numbers and variables are not operators, we cannot dispatch into the table
   based on them and must handle them specially.

b. Code:

   #+BEGIN_SRC scheme
     (define (install-deriv-package)
       ;; internal procedures
       (define (make-sum a1 a2) (list '+ a1 a2))
       (define (addend s) (car s))
       (define (augend s) (cadr s))

       (define (make-product m1 m2) (list '* m1 m2))
       (define (multiplier p) (car p))
       (define (multiplicand p) (cadr p))

       (define (deriv-sum exp var)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))

       (define (deriv-product exp var)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand  exp) var))
           (make-product (deriv (multiplier  exp) var)
                         (multiplicand exp))))

       ;; interface to the rest of the system
       (put 'deriv '+ deriv-sum)
       (put 'deriv '* deriv-product))
     (install-deriv-package)

   #+END_SRC

c. Here is an implementation for exponentiation:

   #+BEGIN_SRC scheme
     (define (make-exponentiation base power)
       (list '** base power))
     (define (base s) (car s))
     (define (exponent s) (cadr s))

     (define (deriv-exponentiation operands var)
       (make-product
         (make-product
           (exponent exp)
           (make-exponentiation
             (base exp)
             (- (exponent exp) 1)))
         (deriv (base exp) var)))
     (put 'deriv '** deriv-exponentiation)

   #+END_SRC

d. It is only necessary to change the places where the ~get~ or ~put~
   procedures are actually invoked. In my implementation above, since the only
   place these procedures are invoked besides in the definition of ~deriv~ is
   when registering the operator-specific commands, the order of the arguments
   to the ~put~ calls is the only thing to change.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.74][Exercise 2.74.]]

a. Assume that a procedure ~file-type~ can extract the type of a file without
   knowing the detailed structure of the file. For example, the first element
   of the file data structure always holds the type.

   The ~find-in-set~ procedure takes the set first and the key second.

   #+BEGIN_SRC scheme
     (define (get-record file employee-name)
       ((get (file-type file) 'find-in-set) file employee-name))
   #+END_SRC

b. Again, assume that the type of the record can be extracted without
   a detailed knowledge of the structure.

   Note that file and employee record types are in the same namespace so that
   the ~find-in-set~ procedure can easily be used for either.

   #+BEGIN_SRC scheme
     (define (get-salary record)
       ((get (record-type record) 'find-in-set) record 'salary))
   #+END_SRC

c. Note that this is abstracted away from the representation of the files and
   records -- everything is implemented in terms of the lower-level procedures
   given above.

   #+BEGIN_SRC scheme
     (define (find-employee-record files employee-name)
       (if (null? files)
         #f
         (let ((record (get-record (car files) employee-name)))
          (if record
            record
            (find-employee-record (cdr files) employee-name)))))
   #+END_SRC

d. Each file and employee record must be modified to place the type information
   in a place where ~file-type~ and ~record-type~ can extract it, and the
   primitive type-dependent procedures must be defined and put into the
   dispatch table.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.75][Exercise 2.75.]]

#+BEGIN_SRC scheme
  (define (make-from-mag-ang mag ang)
    (define (dispatch op)
      (cond ((eq? op 'magnitude) mag)
            ((eq? op 'angle) ang)
            ((eq? op 'real-part)
             (* mag (cos ang)))
            ((eq? op 'imag-part)
             (* mag (sin ang)))
            (else
             (error "Unknown op -- MAKE-FROM-MAG-ANG" op))))
    dispatch)

  (define pi (* 2 (asin 1)))
  (define z (make-from-mag-ang 1 (/ pi 4)))
  (test 1
        (z 'magnitude))
  (test (/ pi 4)
        (z 'angle))
  (test (/ (sqrt 2) 2)
        (z 'real-part))
  (test (/ (sqrt 2) 2)
        (z 'imag-part))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.76][Exercise 2.76.]]

Steps to add types or operations:

- explicit dispatch :: Need to add an additional case in every operation when a
     new type is added, and need to explicitly dispatch on all types when a new
     operation is added.

- data-directed style :: can add new types easily by implementing all the
     operations in a package and then importing it.

- message-passing style :: can add new operations easily defined for a type, it
     can fall back to a default implementation or an error -- but adding new
     operations requires modifying every type.


** 2.5: Systems with Generic Operations

#+NAME: generic-arithmetic-procedures
#+BEGIN_SRC scheme
  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))
#+END_SRC

#+NAME: install-scheme-number-package
#+BEGIN_SRC scheme
  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
         (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
         (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
         (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
         (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
         (lambda (x) (tag x)))
    'done)
  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))
#+END_SRC

*** 2.5.1: Generic Arithmetic Operations

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.77][Exercise 2.77.]]

#+BEGIN_SRC scheme
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
#+END_SRC

The ~real-part~, etc. functions are in fact simple wrappers around the
application of the corresponding generic operations:

#+BEGIN_SRC scheme
  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))
#+END_SRC

The ~rectangular~ and ~polar~ packages define internal procedures to implement
these generic operations. The generic operations defined for ~complex~ numbers
just end up dispatching to the corresponding generic ~rectangular~ or ~polar~
operations, only after which is the underlying internal function called.

For example, calling ~(magnitude z)~, where ~z~ is a ~complex~ number, results
in the following calls:

#+BEGIN_SRC scheme
  ;; Original application to complex type.
  (magnitude z)
  ;; Expansion from generic definition of magnitude.
  (apply-generic 'magnitude z)
  ;; Definition in this problem applies magnitude to contents of z (which may be
  ;; rectangular or polar).
  (magnitude (contents z))
  ;; Again, expansion from generic definition of magnitude.
  (apply-generic 'magnitude (contents z))
  ;; Application of generic magnitude operation to numbers tagged rectangular or
  ;; polar results in calling the implementation of magnitude internal to the
  ;; package.
  (internal-magnitude (contents (contents z)))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.78][Exercise 2.78.]]

We special-case numbers to return ~scheme-number~ as their type tag and avoid
adding the type tag to numbers that would otherwise be tagged with
~scheme-number~.

#+BEGIN_SRC scheme
  (define (attach-tag type-tag contents)
    (if (and (equal? type-tag 'scheme-number)
             ;; Leave open the possibility to apply SCHEME-NUMBER to non-numbers.
             (number? contents))
        contents
        (cons type-tag contents)))
  (define (type-tag datum)
    (cond ((number? datum) 'scheme-number)
          ((pair? datum) (car datum))
          (else error "Bad tagged datum -- TYPE-TAG" datum)))
  (define (contents datum)
    (cond ((number? datum) datum)
          ((pair? datum) (cdr datum))
          (else (error "Bad tagged datum -- CONTENTS" datum))))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.79][Exercise 2.79.]]

We define the top-level generic function for convenience:

#+BEGIN_SRC scheme
  (define equ? (apply-generic 'equ? x y))
#+END_SRC

Install the following functions as implementations for ~equ?~ in the
corresponding packages:

#+BEGIN_SRC scheme
  (define (equ?-scheme-number x y)
    (= x y))
  (put 'equ? 'scheme-number equ?-scheme-number)

  (define (equ?-rat x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (put 'equ? 'rational equ?-rat)

  (define (equ?-complex x y)
    (and (= (real-part x) (real-part y)
            (imag-part x) (imag-part y))))
  (put 'equ? 'complex equ?-complex)
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.80][Exercise 2.80.]]

We define the top-level generic function for convenience:

#+BEGIN_SRC scheme
  (define =zero? (lambda (x)  (apply-generic '=zero? x)))
#+END_SRC

Install the following functions as implementations for ~=zero?~ in the
corresponding packages:

#+BEGIN_SRC scheme
  (define (=zero?-scheme-number x)
    (= x 0))
  (put '=zero? '(scheme-number) =zero?-scheme-number)

  (define (=zero?-rat x y)
    (and (= (numer x) 0)
         ;; Denominator of 0 is undefined -- choose not to make such a number
         ;; equal to 0 even if the numerator is 0.
         (/= (denom x) 0)))
  (put '=zero? '(rational) =zero?-rat)

  (define (=zero?-complex x y)
    (= (magnitude x) 0))
  (put '=zero? '(complex) =zero?-complex)
#+END_SRC

One could also imagine defining ~=zero?~ as a generic function

#+BEGIN_SRC scheme
  (define (=zero? x)
    (equ? x (zero x)))
#+END_SRC

where ~zero~ is a function that returns a zero value of the type of
~x~. Assuming ~equ?~ properly equates zero values that have the same type but
different representations (e.g., for ~rat~ and ~polar~ numbers), the above
definition will work. However, this requires another operation to be defined
anyway, and makes it harder to override the ~=zero?~ operation per-type in the
event that such an override is desirable for efficiency or correctness.


*** 2.5.2: Combining Data of Different Types

**** Auxiliary definitions

#+BEGIN_SRC scheme
  (define *coercion-table* (make-hash-table equal?))

  (define (put-coercion type-from type-to proc)
    (hash-table-set!
     *coercion-table*
     (list type-from type-to)
     proc))

  (define (get-coercion type-from type-to)
    (hash-table-ref
     *coercion-table*
     (list type-from type-to)))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.81][Exercise 2.81.]]

a. If ~exp~ is called with two ~complex~ numbers as arguments, ~apply-generic~
   will fail to find an implementation of ~exp~ for the arguments. However, it
   will then find a coercion ~complex->complex~ for ~t1->t2~ and then re-apply
   the ~exp~ operation with ~t1->t2~ applied to the first argument. Since this
   applies ~exp~ once again to two ~complex~ arguments, Louis' conversions
   will lead to an infinite loop.

b. Louis is not correct -- ~apply-generic~ works as is because it searches for
   an implementation of the generic operation for the argument types given
   before attempting coercion. If an implementation is found, coercion is
   never attempted, so there is no need to provide a coercion operation from a
   type to itself.

c. From the above, it is clear that the only time ~apply-generic~ would look
   for a conversion from a type to itself is when

   - The two arguments have the same type.
   - An implementation of the generic operation was not found.

   Therefore, the only thing to do is to raise an error for the lack of an
   implementation:

   #+BEGIN_SRC scheme
     (define (apply-generic op . args)
       (define (no-method op type-tags)
         (error "No method for these types"
                (list op type-tags)))
       (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
           (if proc
               (apply proc (map contents args))
               (if (= (length args) 2)
                   (let ((type1 (car type-tags))
                         (type2 (cadr type-tags))
                         (a1 (car args))
                         (a2 (cadr args)))
                     (if (equal? type1 type2)
                         (no-method op type-tags)
                         (let ((t1->t2 (get-coercion type1 type2))
                               (t2->t1 (get-coercion type2 type1)))
                           (cond (t1->t2
                                  (apply-generic op (t1->t2 a1) a2))
                                 (t2->t1
                                  (apply-generic op a1 (t2->t1 a2)))
                                 (else
                                  (no-method op type-tags))))))
                   (no-method op type-tags))))))
   #+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.82][Exercise 2.82.]]

Here's the steps:

- First, test if the args are the proper types already for the operation. If
  so, apply the op and return the result.
- Else, we'll want to keep the list of arguments, as well as keep an index to
  the current argument, whose type we want to coerce all the other arguments
  to.
#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (define (no-method op type-tags)
      (error "No method for these types"
             (list op type-tags)))
    (define (attempt-coercion tried to-try)
      (if (null? to-try)
          (no-method op (map type-tag tried))
          (letrec ((current-arg (car to-try))
                   (current-type (type-tag current-arg))
                   (coerce-to-current
                    (lambda (x)
                      ((get-coercion (type-tag x) current-type) x)))
                   (coerced-args
                    (append (map coerce-to-current tried)
                            (list current-arg)
                            (map coerce-to-current (cdr to-try)))))
            (if (/= (length coerced-args)
                   (length (append tried to-try)))
                (attempt-coercion (append tried (list (car to-try)))
                                  (cdr to-try))
                (apply apply-generic op coerced-args)))))
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (attempt-coercion '() args)))))
#+END_SRC

This procedure works for some simple cases. However, if

- the arguments to ~apply-generic~ are not of the appropriate type for ~op~,
- one argument ~t1~ cannot be coerced to the type of another argument ~t2~,
- a coercion for ~t1~ exists such that the argument list is valid for ~op~,

an appropriate coercion will not be found even though it exists.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.83][Exercise 2.83.]]

#+BEGIN_SRC scheme
  ;; Install these in the corresponding packages to implement the generic RAISE
  ;; operation.
  (define (raise-integer->rational x)
    (make-rat x 1))
  (define (raise-rational->real x)
    (/ (numer x) (denom x)))
  (define (raise-real->complex x)
    (make-from-real-imag x 0))

  ;; Raise over any numeric type
  (define (raise x) (apply-generic 'raise x))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.84][Exercise 2.84.]]

For simplicity, use the earlier two-argument version of ~apply-generic~.

One simple way to extend the earlier ~apply-generic~ procedure is to first
attempt coercing the arguments as before

#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (define (no-method op type-tags)
      (error "No method for these types"
             (list op type-tags)))
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (if (= (length args) 2)
                (let ((type1 (car type-tags))
                      (type2 (cadr type-tags))
                      (a1 (car args))
                      (a2 (cadr args)))
                  (if (equal? type1 type2)
                      (no-method op type-tags)
                      (let ((t1->t2 (get-coercion type1 type2))
                            (t2->t1 (get-coercion type2 type1)))
                        (cond (t1->t2
                               (apply-generic op (t1->t2 a1) a2))
                              (t2->t1
                               (apply-generic op a1 (t2->t1 a2)))
                              (else
                               (no-method op type-tags))))))
                (no-method op type-tags))))))
#+END_SRC


*** 2.5.3: Example: Symbolic Algebra

**** Auxiliary definitions

#+BEGIN_SRC scheme
  ;; <procedures same-variable? and variable? from section 2.3.2>
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (install-poly-sparse-package)
    ;; internal procedures
    ;; representation of poly
    (define (make-poly-sparse variable term-list)
      (cons variable term-list))
    (define (variable p) (car p))
    (define (term-list p) (cdr p))
    ;; <procedures same-variable? and variable? from section 2.3.2>
    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    ;; representation of terms and term lists
    ;; <procedures adjoin-term ...coeff from text below>
    (define (adjoin-term term term-list)
      (if (=zero? (coeff term))
          term-list
          (cons term term-list)))
    (define (the-empty-termlist) '())
    (define (first-term term-list) (car term-list))
    (define (rest-terms term-list) (cdr term-list))
    (define (empty-termlist? term-list) (null? term-list))
    (define (make-term order coeff) (list order coeff))
    (define (order term) (car term))
    (define (coeff term) (cadr term))

    (define (add-poly-sparse p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly-sparse (variable p1)
                            (add-terms (term-list p1) (term-list p2)))
          (error "ADD-POLY -- cannot add two polynomials with different variables")))
    ;; <procedures used by add-poly>
    (define (add-terms L1 L2)
      (cond ((empty-termlist? L1) L2)
            ((empty-termlist? L2) L1)
            (else
             (let ((t1 (first-term L1)) (t2 (first-term L2)))
               (cond ((> (order t1) (order t2))
                      (adjoin-term
                       t1 (add-terms (rest-terms L1) L2)))
                     ((< (order t1) (order t2))
                      (adjoin-term
                       t2 (add-terms L1 (rest-terms L2))))
                     (else
                      (adjoin-term
                       (make-term (order t1)
                                  (add (coeff t1) (coeff t2)))
                       (add-terms (rest-terms L1)
                                  (rest-terms L2)))))))))
    (define (mul-poly-sparse p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly-sparse (variable p1)
                            (mul-terms (term-list p1) (term-list p2)))
          (error "MUL-POLY -- cannot multiply two polynomials with different variables")))
    ;; <procedures used by mul-poly>
    (define (mul-terms L1 L2)
      (if (empty-termlist? L1)
          (the-empty-termlist)
          (add-terms (mul-term-by-all-terms (first-term L1) L2)
                     (mul-terms (rest-terms L1) L2))))
    (define (mul-term-by-all-terms t1 L)
      (if (empty-termlist? L)
          (the-empty-termlist)
          (let ((t2 (first-term L)))
            (adjoin-term
             (make-term (+ (order t1) (order t2))
                        (mul (coeff t1) (coeff t2)))
             (mul-term-by-all-terms t1 (rest-terms L))))))
    ;; interface to rest of the system
    (define (tag p) (attach-tag 'poly-sparse p))
    (put 'add '(poly-sparse poly-sparse)
         (lambda (p1 p2) (tag (add-poly-sparse p1 p2))))
    (put 'mul '(poly-sparse poly-sparse)
         (lambda (p1 p2) (tag (mul-poly-sparse p1 p2))))
    (put 'make 'poly-sparse
         (lambda (var terms) (tag (make-poly-sparse var terms))))
    'done)
  (define (make-poly-sparse var terms)
    ((get 'make 'poly-sparse) var terms))
#+END_SRC


**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.87][Exercise 2.87.]]

Install ~=zero?~ for polynomials in the generic arithmetic package. This will
allow ~adjoin-term~ to work for polynomials with coefficients that are
themselves polynomials.

#+BEGIN_SRC scheme
  (define (=zero?-poly-sparse p)
    (let =zero?-terms ((terms (term-list p)))
      (or (empty-termlist? terms)
          (and (=zero? (coeff (first-term terms)))
               (=zero?-terms (rest-terms terms))))))
  (put '=zero? 'poly-sparse =zero?-poly)
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.88][Exercise 2.88.]]

#+BEGIN_SRC scheme
  ;; Negation
  (define (neg-poly-sparse p)
    (define (neg-terms terms)
      (if (empty-termlist? terms)
          (the-empty-termlist)
          (adjoin-term (make-term (order (first-term terms))
                                  (neg (coeff (first-term terms))))
                       (rest-terms terms))))
    (make-poly-sparse (variable p)
               (neg-terms (term-list p))))
  (define (neg-complex z)
    (make-from-real-imag (- (real-part z))
                         (- (imag-part z))))
  (put 'neg 'polynomial neg-poly)
  (put 'neg 'complex neg-complex)
  (put 'neg 'scheme-number
       (lambda (x) (attach-tag 'scheme-number (- x))))
  (define (neg x) (apply-generic 'neg x))

  ;; Subtraction in terms of negation
  (define (sub-poly-sparse p1 p2)
    (add p1 (neg p2)))
  (put 'sub '(poly-sparse poly-sparse) sub-poly-sparse)
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.89][Exercise 2.89.]]

#+BEGIN_SRC scheme
  (define (install-poly-dense-package)
    ;; internal procedures
    ;; representation of poly
    (define (make-poly variable term-list)
      (cons variable term-list))
    (define (variable p) (car p))
    (define (term-list p) (cdr p))
    ;; <procedures same-variable? and variable? from section 2.3.2>
    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    ;; representation of terms and term lists
    ;; <procedures adjoin-term ...coeff from text below>
    (define (adjoin-term term term-list)
      (if (=zero? term)
          term-list
          (cons term term-list)))
    (define (the-empty-termlist) '())
    (define (first-term term-list) (car term-list))
    (define (rest-terms term-list) (cdr term-list))
    (define (empty-termlist? term-list) (null? term-list))

    (define (add-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (add-terms (term-list p1) (term-list p2))))
      (error "ADD-POLY -- cannot add two polynomials with different variables"))
    ;; <procedures used by add-poly>
    (define (add-terms L1 L2)
      (let (rec (L1 L1)
                (L2 L2)
                (o1 (length L1))
                (o2 (length L2)))
        (cond ((empty-termlist? L1) L2)
              ((empty-termlist? L2) L1)
              ((> o1 o2)
               (adjoin-term (first-term L1) (rec (rest-terms L1) L2 (- o1 1) o2)))
              ((> o2 o1)
               (adjoin-term (first-term L2) (rec L1 (rest-terms L2) o1 (- o2 1))))
              (else
               (adjoin-term (add (first-term L1)
                                 (first-term L2))
                            (rec (rest-terms L1) (rest-terms L2)
                                 (- o1 1) (- o2 1)))))))
    (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (mul-terms (term-list p1) (term-list p2))))
      (error "MUL-POLY -- cannot multiply two polynomials with different variables"))
    ;; <procedures used by mul-poly>
    (define (mul-terms L1 L2)
      (let (rec ((L1 L1)
                 (L2 L2)
                 (o1 (- (length L1) 1)))
                (if (empty-termlist? L1)
                    (the-empty-termlist)
                    (add-terms (mul-term-by-all-terms (first-term L1) o1 L2)
                               (rec (rest-terms L1) L2 (- o1 1))))))
      ;; c1, o1 -- coefficient, order of term to be multiplied by term list L
      ;; First multiply terms by c1, then append a list of (+ o1 1) zeros to the
      ;; end of L to represent the multiplication by the inderminate variable
      ;; raised to the power of o1.
      (define (mul-term-by-all-terms c1 o1 L)
        (define (rec c1 o1 L)
          (if (empty-termlist? L)
              (the-empty-termlist)
              (let ((t2 (first-term L)))
                (adjoin-term
                 (mul c1 t2)
                 (rec c1 (- o1 1) (rest-terms L))))))
        (append (rec t1 o1 L)
                (repeat 0 (+ o1 1)))
        ;; interface to rest of the system
        (define (tag p) (attach-tag 'poly-dense p))
        (put 'add '(poly-dense poly-dense)
             (lambda (p1 p2) (tag (add-poly p1 p2))))
        (put 'mul '(poly-dense poly-dense)
             (lambda (p1 p2) (tag (mul-poly p1 p2))))
        (put 'make 'poly-dense
             (lambda (var terms) (tag (make-poly var terms))))
        'done)
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.90][Exercise 2.90.]]

We first want to define some coercions. I will use the ~get-coercion~ and
~put-coercion~ interface for this.

#+BEGIN_SRC scheme
  (define (coerce-poly-sparse->poly-dense p)
    (define (coeff t) (car t))
    (define (order t) (cdr t))
    (define (tag p) (attach-tag 'poly-dense p))
    (let ((terms (cdr p))
          (var (car p)))
      (cons var
            (list
             (let (rec (terms terms)
                       (o (order (car terms))))
               (cond ((null? terms)
                      '())
                     ((> o (order (car terms)))
                      (cons (attach-tag 'scheme-number 0)
                            (rec terms (- o 1))))
                     (else
                      (cons (coeff (car terms))
                            (rec terms (- o 1))))))))))
  (define (coerce-poly-dense->poly-sparse p)
    (define (make-term coeff order) (cons coeff order))
    (define (tag p) (attach-tag 'poly-dense p))
    (let ((terms (cdr p))
          (var (car p)))
      (cons var
            (list
             (let (rec (terms terms)
                       (o (- (length terms) 1)))
               (cond ((null? terms)
                      '())
                     ((=zero? (car terms))
                      (rec (cdr terms) (- o 1)))
                     (else
                      (cons (make-term (car terms) o)
                            (rec (cdr terms) (- o 1))))))))))
  (put-coercion 'poly-sparse 'poly-dense coerce-poly-sparse->poly-dense)
  (put-coercion 'poly-dense 'poly-sparse coerce-poly-dense->poly-sparse)
#+END_SRC

The idea here is to define a type ~poly-generic~, whose contents we assume are
always another tagged value (of type ~poly-sparse~ or ~poly-dense~, or perhaps
another representation that may be added in the future). Unfortunately, this
design requires manually coercing a ~poly-generic~ value to the underlying
representation, which is a major flaw the ~complex~ example doesn't have. This
arises because, unlike ~complex~, there are no primitives provided for the
polynomial types below ~add~, ~sub~, etc. with which these procedures can be
implemented.

#+BEGIN_SRC scheme
  (define (install-poly-generic-package)
    (define (tag x) (attach-tag 'poly-generic x))
    (put 'neg '(poly-generic)
         (lambda (p)
           (tag (neg (contents p)))))
    (put 'add '(poly-generic poly-generic)
         (lambda (p1 p2)
           (tag (add (contents p1) (contents p2)))))
    (put 'sub '(poly-generic poly-generic)
         (lambda (p1 p2)
           (tag (sub (contents p1) (contents p2)))))
    (put 'mul '(poly-generic poly-generic)
         (lambda (p1 p2)
           (tag (mul (contents p1) (contents p2)))))
    (put 'make 'poly-generic
         (lambda (var terms)
           (tag ((get 'poly-sparse 'make) var terms))))
    'done)
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.91][Exercise 2.91.]]

A univariate polynomial can be divided by another one to produce a polynomial
quotient and a polynomial remainder. For example,

\begin{equation}
\frac{x^5 - 1}{x^2 - 1} = x^3 + x, \ \textrm{remainder} \ x - 1
\end{equation}

Division can be performed via long division. That is, divide the highest-order
term of the dividend by the highest-order term of the divisor. The result is
the first term of the quotient. Next, multiply the result by the divisor,
subtract that from the dividend, and produce the rest of the answer by
recursively dividing the difference by the divisor. Stop when the order of the
divisor exceeds the order of the dividend and declare the dividend to be the
remainder. Also, if the dividend ever becomes zero, return zero as both
quotient and remainder.

We can design a ~div-poly~ procedure on the model of ~add-poly~ and
~mul-poly~. The procedure checks to see if the two polys have the same
variable. If so, ~div-poly~ strips off the variable and passes the problem to
~div-terms~, which performs the division operation on term lists. ~div-poly~
finally reattaches the variable to the result supplied by ~div-terms~. It is
convenient to design ~div-terms~ to compute both the quotient and the remainder
of a division. ~div-terms~ can take two term lists as arguments and return a
list of the quotient term list and the remainder term list.

Complete the following definition of ~div-terms~ by filling in the missing
expressions. Use this to implement ~div-poly~, which takes two polys as
arguments and returns a list of the quotient and remainder polys.

***** Solution

#+NAME: ex-2-91-sparse
#+BEGIN_SRC scheme
  (define (make-poly-sparse variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  ;; <procedures same-variable? and variable? from section 2.3.2>
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  ;; representation of terms and term lists
  ;; <procedures adjoin-term ...coeff from text below>
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))
#+END_SRC

#+NAME: ex-2-91-division
#+BEGIN_SRC scheme
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       (div-terms
                        (sub-terms L1
                                   (mul-terms (list (make-term new-c new-o))
                                              L2)))))
                  (cons (adjoin-term (make-term new-c new-o)
                                     (car rest-of-result))
                        rest-of-result)))))))
  (define (div-poly-sparse p1 p2)
    (if (same-variable? (variable p1)
                        (variable p2))
        (letrec ((make-poly-sparse (get 'make 'poly-sparse))
                 (var (variable p1))
                 (result (div-terms (term-list p1)
                                    (term-list p2)))
                 (quotient (car result))
                 (remainder (cadr result)))
          (list (make-poly-sparse var quotient)
                (make-poly-sparse var remainder)))
        (error "DIV-POLY -- ")))
#+END_SRC

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.92][Exercise 2.92.]]

Skipping.

**** [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_thm_2.93][Exercise 2.93.]]

#+BEGIN_SRC scheme
  (define (install-rational-package)
    ;; internal procedures
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (cons n d))
    (define (add-rat x y)
      (make-rat (add (mul (numer x) (denom y))
                     (mul (numer y) (denom x)))
                (mul (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (sub (mul (numer x) (denom y))
                     (mul (numer y) (denom x)))
                (mul (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (mul (numer x) (numer y))
                (mul (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (mul (numer x) (denom y))
                (mul (denom x) (numer y))))
    ;; interface to rest of the system
    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
         (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
         (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
         (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
         (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
         (lambda (n d) (tag (make-rat n d))))
    'done)
  (define (make-rational n d)
    ((get 'make 'rational) n d))
#+END_SRC
