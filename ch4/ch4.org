#+TITLE: Structure and Interpretation of Computer Programs (SICP)
#+AUTHOR: Robert Irelan
#+EMAIL: rirelan@gmail.com
#+OPTIONS: author:t email:t f:t num:nil H:4
#+PROPERTY: header-args :comments noweb :noweb no-export
#+PROPERTY: header-args:scheme :shebang #!/usr/bin/env chicken-scheme
#+FILETAGS: :SICP:

* TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-25.html#%_chap_4][Chapter 4: Metalinguistic Abstraction]] [%]

** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1][4.1: The Metacircular Evaluator]] [14%]
   CLOCK: [2015-05-22 Fri 19:41]--[2015-05-22 Fri 21:17] =>  1:36
   - Note taken on [2015-02-01 Sun 19:22] \\
     We seem to have a working evaluator now.
   CLOCK: [2015-02-01 Sun 18:19]--[2015-02-01 Sun 19:22] =>  1:03
   CLOCK: [2015-02-01 Sun 18:00]--[2015-02-01 Sun 18:18] =>  0:18
   - Note taken on [2015-02-01 Sun 17:51] \\
     Will take a pass through this section to implement the entire evaluator before
     doing more of the exercises.

*** Code
    :PROPERTIES:
    :VISIBILITY: folded
    :END:

For convenience, put the entire metacircular interpreter here:

#+BEGIN_SRC scheme :tangle interp-sec-4-1.scm
  <<primitive-expressions>>
  <<derived-expressions>>
  <<evaluator-structs>>
  <<evaluator-running>>
  <<eval-sec-4-1>>
#+END_SRC

- Main body of ~eval~:

  #+NAME: eval-sec-4-1
  #+BEGIN_SRC scheme
    <<eval-sec-4-1-aux>>
    (define (eval-4-1 exp env)
      (cond ((self-evaluating? exp) exp)
            ((boolean-object? exp) (make-boolean-object exp))
            ((variable? exp) (lookup-variable-value exp env))
            ((quoted? exp) (text-of-quotation exp))
            ((assignment? exp) (eval-assignment exp env))
            ((definition? exp) (eval-definition exp env))
            ((if? exp) (eval-if exp env))
            ((lambda? exp)
             (make-procedure (lambda-parameters exp)
                             (lambda-body exp)
                             env))
            ((begin? exp)
             (eval-sequence (begin-actions exp) env))
            ((cond? exp) (eval-4-1 (cond->if exp) env))
            ((application? exp)
             (apply-4-1 (eval-4-1 (operator exp) env)
                        (list-of-values (operands exp) env)))
            (else
             (error "Unknown expression type -- EVAL" exp))))
  #+END_SRC

- Auxiliary procedures:

  #+NAME: eval-sec-4-1-aux
  #+BEGIN_SRC scheme
    (define (apply-4-1 procedure arguments)
      (cond ((primitive-procedure? procedure)
             (apply-primitive-procedure procedure arguments))
            ((compound-procedure? procedure)
             (eval-sequence
              (procedure-body procedure)
              (extend-environment
               (procedure-parameters procedure)
               arguments
               (procedure-environment procedure))))
            (else
             (error
              "Unknown procedure type -- APPLY-4-1" procedure))))

    (define (list-of-values exps env)
      (if (no-operands? exps)
          '()
          (cons (eval-4-1 (first-operand exps) env)
                (list-of-values (rest-operands exps) env))))

    (define (eval-if exp env)
      (if (true? (eval-4-1 (if-predicate exp) env))
          (eval-4-1 (if-consequent exp) env)
          (eval-4-1 (if-alternative exp) env)))

    (define (eval-sequence exps env)
      (cond ((last-exp? exps) (eval-4-1 (first-exp exps) env))
            (else (eval-4-1 (first-exp exps) env)
                  (eval-sequence (rest-exps exps) env))))

    <<ex-4-4-eval-and-or>>
    <<ex-4-5-cond-recipient>>

    (define (eval-assignment exp env)
      (set-variable-value! (assignment-variable exp)
                           (eval-4-1 (assignment-value exp) env)
                           env)
      'ok)

    (define (eval-definition exp env)
      (define-variable! (definition-variable exp)
        (eval-4-1 (definition-value exp) env)
        env)
      'ok)
  #+END_SRC

*** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.1][4.1.1: The Core of the Evaluator]] [2/2]
**** DONE Read SICP 4.1.1
     SCHEDULED: <2015-01-10 Sat>
     CLOCK: [2015-01-10 Sat 12:53]--[2015-01-10 Sat 13:04] =>  0:11
     :PROPERTIES:
     :Effort:   0:15
     :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.1][Exercise 4.1]]
     SCHEDULED: <2015-01-10 Sat>
     CLOCK: [2015-01-10 Sat 16:48]--[2015-01-10 Sat 17:23] =>  0:35

In the original version of the ~list-of-values~ procedure (shown here),

#+BEGIN_SRC scheme
(define (list-of-values exps env)
(if (no-operands? exps)
    '()
    (cons (eval-4-1 (first-operand exps) env)
          (list-of-values (rest-operands exps) env))))
#+END_SRC

whether the first or the rest of the operands of the list is evaluated
first depends on the evaluation order of the underlying
Lisp. Specifically, if the Lisp evaluates from left to right,
~first-operand~ will be called before ~rest-operands~; if the Lisp
evaluates from right to left, ~rest-operands~ is instead called first,
producing a right-to-left evaluating version of ~list-of-values~.

To guarantee the order of execution, one can take advantage of the fact
that the ~begin~ form is guaranteed to evaluate its arguments in order to
write both an explicitly left-to-right version

#+BEGIN_SRC scheme :tangle ex-4-1-ltr.scm
(define (list-of-values exps env)
(if (no-operands? exps)
    '()
    (begin
      ;; First evaluate the leftmost expression, then the rest of the
      ;; expression on the right.
      (define first-expr (eval-4-1 (first-operand exps) env))
      (define rest-expr (list-of-values (rest-operands exps) env))
      (cons first-expr rest-expr))))
#+END_SRC

and a right-to-left version:

#+BEGIN_SRC scheme :tangle ex-4-1-rtl.scm
(define (list-of-values exps env)
(if (no-operands? exps)
    '()
    (begin
      ;; First evaluate the expressions on the right, then the leftmost
      ;; expression.
      (define rest-expr (list-of-values (rest-operands exps) env))
      (define first-expr (eval-4-1 (first-operand exps) env))
      (cons first-expr rest-expr))))
#+END_SRC

Test to confirm:

#+BEGIN_SRC scheme :tangle ex-4-1-test.scm
  (include "interp-sec-4-1")
  (use test)

  ;; Override EVAL for ease of testing
  (define *test-list* '())
  (define eval-4-1
    (lambda (expr env)
      (set! *test-list* (append *test-list* (list expr)))))
  (define input-list '(0 1 2 3 4 5))

  (include "ex-4-1-ltr")
  (set! *test-list* '())
  (list-of-values input-list '())
  (test '(0 1 2 3 4 5) *test-list*)

  (include "ex-4-1-rtl")
  (set! *test-list* '())
  (list-of-values input-list '())
  (test '(5 4 3 2 1 0) *test-list*)
#+END_SRC

     :PROPERTIES:
     :Effort:   0:30
     :END:
*** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.2][4.1.2: Representing Expressions]] [7/10]
**** Code
     :PROPERTIES:
     :VISIBILITY: folded
     :END:

Here's the code for the basic constructs of the interpreter, as defined in
the text:

- Primitive expressions:

  #+NAME: primitive-expressions
  #+BEGIN_SRC scheme
    <<self-evaluating>>
    <<booleans>>
    <<variables>>
    <<quotations>>
    <<assignments>>
    <<definitions>>
    <<lambda-expressions>>
    <<conditionals>>
    <<sequences>>
    <<procedure-application>>
  #+END_SRC

- Self-evaluating items:

  #+NAME: self-evaluating
  #+BEGIN_SRC scheme
    (define (self-evaluating? exp)
      (cond ((number? exp) #t)
            ((string? exp) #t)
            ((boolean? exp) #t)
            (else #f)))
  #+END_SRC

- Boolean:

  #+NAME: booleans
  #+BEGIN_SRC scheme
    (define (boolean-object? exp)
      (or (eq? exp #t) (eq? exp #f)))
    (define (make-boolean-object exp)
      (cond ((eq? exp #t) true)
            ((eq? exp #f) false)
            (else (error "MAKE-BOOLEAN -- passed non-boolean"))))
  #+END_SRC

- Variables:

  #+NAME: variables
  #+BEGIN_SRC scheme
    (define (variable? exp) (symbol? exp))
  #+END_SRC

- Quotations:

  #+NAME: quotations
  #+BEGIN_SRC scheme
    (define (quoted? exp)
      (tagged-list? exp 'quote))

    (define (text-of-quotation exp) (cadr exp))

    (define (tagged-list? exp tag)
      (if (pair? exp)
          (eq? (car exp) tag)
          #f))
  #+END_SRC

- Assignments:

  #+NAME: assignments
  #+BEGIN_SRC scheme
    (define (assignment? exp)
      (tagged-list? exp 'set!))
    (define (assignment-variable exp) (cadr exp))
    (define (assignment-value exp) (caddr exp))
  #+END_SRC

  - Definitions:

  #+NAME: definitions
  #+BEGIN_SRC scheme
    (define (definition? exp)
      (tagged-list? exp 'define))
    (define (definition-variable exp)
      (if (symbol? (cadr exp))
          (cadr exp)
          (caadr exp)))
    (define (definition-value exp)
      (if (symbol? (cadr exp))
          (caddr exp)
          (make-lambda (cdadr exp)   ; formal parameters
                       (cddr exp)))) ; body
  #+END_SRC

  - Lambda expressions:

  #+NAME: lambda-expressions
  #+BEGIN_SRC scheme
    (define (lambda? exp) (tagged-list? exp 'lambda))
    (define (lambda-parameters exp) (cadr exp))
    (define (lambda-body exp) (cddr exp))

    (define (make-lambda parameters body)
      (cons 'lambda (cons parameters body)))

  #+END_SRC

- Conditionals:

  #+NAME: conditionals
  #+BEGIN_SRC scheme
    (define (if? exp) (tagged-list? exp 'if))
    (define (if-predicate exp) (cadr exp))
    (define (if-consequent exp) (caddr exp))
    (define (if-alternative exp)
      (if (not (null? (cdddr exp)))
          (cadddr exp)
          'false))

    (define (make-if predicate consequent alternative)
      (list 'if predicate consequent alternative))
  #+END_SRC

- Sequences:

  #+NAME: sequences
  #+BEGIN_SRC scheme
    (define (begin? exp) (tagged-list? exp 'begin))
    (define (begin-actions exp) (cdr exp))
    (define (last-exp? seq) (null? (cdr seq)))
    (define (first-exp seq) (car seq))
    (define (rest-exps seq) (cdr seq))

    (define (sequence->exp seq)
      (cond ((null? seq) seq)
            ((last-exp? seq) (first-exp seq))
            (else (make-begin seq))))
    (define (make-begin seq) (cons 'begin seq))
  #+END_SRC

- Procedure application:

  #+NAME: procedure-application
  #+BEGIN_SRC scheme
    (define (application? exp) (pair? exp))
    (define (operator exp) (car exp))
    (define (operands exp) (cdr exp))
    (define (no-operands? ops) (null? ops))
    (define (first-operand ops) (car ops))
    (define (rest-operands ops) (cdr ops))
  #+END_SRC

  - Derived expressions:

  #+NAME: derived-expressions
  #+BEGIN_SRC scheme
    <<derived-expressions-cond>>
    <<derived-expressions-let>>
    <<derived-expressions-while>>
  #+END_SRC

    - ~cond~:

    #+NAME: derived-expressions-cond
    #+BEGIN_SRC scheme
      (define (cond? exp) (tagged-list? exp 'cond))
      (define (cond-clauses exp) (cdr exp))
      (define (cond-else-clause? clause)
        (eq? (cond-predicate clause) 'else))
      (define (cond-predicate clause) (car clause))
      (define (cond-actions clause) (cdr clause))
      (define (cond->if exp)
        (expand-clauses (cond-clauses exp)))

      (define (expand-clauses clauses)
        (if (null? clauses)
            'false                          ; no else clause
            (let ((first (car clauses))
                  (rest (cdr clauses)))
              (if (cond-else-clause? first)
                  (if (null? rest)
                      (sequence->exp (cond-actions first))
                      (error "ELSE clause isn't last -- COND->IF"
                             clauses))
                  (make-if (cond-predicate first)
                           (sequence->exp (cond-actions first))
                           (expand-clauses rest))))))
    #+END_SRC

    - ~let~:

    #+NAME: derived-expressions-let
    #+BEGIN_SRC scheme
      <<ex-4-7-let-star>>
      <<ex-4-8-let-named>>
    #+END_SRC

    - ~while~:

    #+NAME: derived-expressions-while
    #+BEGIN_SRC scheme
      <<ex-4-9-while>>
    #+END_SRC

**** DONE Read SICP 4.1.2
    SCHEDULED: <2015-01-10 Sat>
    CLOCK: [2015-01-10 Sat 17:54]--[2015-01-10 Sat 18:09] =>  0:15

    :PROPERTIES:
    :Effort:   0:15
    :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.2][Exercise 4.2]]
     SCHEDULED: <2015-01-10 Sat>
     CLOCK: [2015-01-10 Sat 18:13]--[2015-01-10 Sat 18:26] =>  0:13

- Louis' modification to the interpreter will fail if the operator is a
special form rather than a function that can be applied, since the
arguments to special forms might need to be evaluated in a different
manner from those to normal procedures. For example, if Louis' ~eval~ is
called on ~(define x 3)~, it will evaluate ~x~ to its value, rather than
treating ~x~ as the assignment target.

- In order to make Louis' plan work, we need to eliminate the ambiguity
between special forms and ordinary procedures in the syntax. One simple
way to do this is to denote procedure application by the special form
~call~. This can be accomplished by the following modification to the
interpreter:

  #+BEGIN_SRC scheme
    (define (application? exp)
      (and (pair? exp)
           (tagged-list? exp 'call)))
    (define (operator exp) (cadr exp))
    (define (operands exp) (cddr exp))
  #+END_SRC

  :PROPERTIES:
     :Effort:   0:15
     :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.3][Exercise 4.3]]
     SCHEDULED: <2015-02-16 Mon>
     CLOCK: [2015-02-01 Sun 16:45]--[2015-02-01 Sun 17:12] =>  0:27
     CLOCK: [2015-01-10 Sat 18:41]--[2015-01-10 Sat 19:18] =>  0:37

     #+BEGIN_SRC scheme :tangle symbol-table.scm
       (use srfi-69)                           ; Import hash table procs
       (define (put table op type proc)
         (hash-table-set! table (cons op type) proc))
       (define (get table op type)
         (hash-table-ref/default table (cons op type) '()))
     #+END_SRC

     #+BEGIN_SRC scheme :tangle ex-4-3.scm
       <<primitive-expressions>>
       <<derived-expressions>>
       <<evaluator-structs>>
       <<evaluator-running>>
       <<eval-sec-4-1-aux>>

       (include "symbol-table")
       (define *eval-4-1-op-table* (make-parameter (make-hash-table equal?)))
       (define (eval-4-1-get type)
         (get (*eval-4-1-op-table*) 'eval type))
       (define (eval-4-1-put type proc)
         (put (*eval-4-1-op-table*) 'eval type proc))

       (define (eval-4-1 exp env)
         (cond ((self-evaluating? exp) exp)
               ((variable? exp) (lookup-variable-value exp env))
               (else (let ((method (eval-4-1-get (car exp))))
                       (cond ((not (null? method))
                              (method exp env))
                             ((application? exp)
                              (apply-4-1 (eval-4-1 (operator exp) env)
                                         (list-of-values (operands exp) env)))
                             (else
                              (error "Unknown expression type: EVAL" exp)))))))

       (eval-4-1-put 'quote
                     (lambda (exp env)
                       (text-of-quotation exp)))
       (eval-4-1-put 'set!
                     (lambda (exp env)
                       (eval-assignment exp env)))
       (eval-4-1-put 'define
                     (lambda (exp env)
                       (eval-definition exp env)))
       (eval-4-1-put 'if
                     (lambda (exp env)
                       (eval-if exp env)))
       (eval-4-1-put 'lambda
                     (lambda (exp env)
                       (make-procedure (lambda-parameters exp)
                                       (lambda-body exp)
                                       env)))
       (eval-4-1-put 'begin
                     (lambda (exp env)
                       (eval-sequence (begin-actions exp) env)))
       (eval-4-1-put 'cond
                     (lambda (exp env)
                       (eval-4-1 (cond->if exp) env)))

       <<ex-4-4-eval-and-or-dispatch>>
       <<ex-4-5-cond-recipient-dispatch>>
       <<ex-4-7-let-star-dispatch>>
       <<ex-4-8-let-named-dispatch>>
       <<ex-4-9-while-dispatch>>
       <<ex-4-13-make-unbound-dispatch>>
     #+END_SRC

     :PROPERTIES:
     :Effort:   0:30
     :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.4][Exercise 4.4]]
     SCHEDULED: <2015-02-16 Mon>
     CLOCK: [2015-02-16 Mon 13:49]--[2015-02-16 Mon 14:02] =>  0:13

We implement these short-circuiting special forms by iterating down the list:

#+NAME: ex-4-4-eval-and-or
#+BEGIN_SRC scheme
  (define (eval-and exps env)
    (if (null? exps)
        true
        (let ((first (first-exp exps)))
             (cond ((last-exp? exps) (eval-4-1 first env))
                   ((not (true? first)) false)
                   (else (eval-and (rest-exps exps) env))))))

  (define (eval-or exps env)
    (if (null? exps)
        false
        (let ((first (first-exp exps)))
             (cond ((true? first) first)
                   (else (eval-or (rest-exps exps) env))))))
#+END_SRC

Just add them to the data-dispatch interpreter like so:

#+NAME: ex-4-4-eval-and-or-dispatch
#+BEGIN_SRC scheme
  (eval-4-1-put 'and
                (lambda (exp env)
                  (eval-and exp env)))
  (eval-4-1-put 'or
                (lambda (exp env)
                  (eval-or exp env)))
#+END_SRC

Here's a short test to ensure that they work:

#+BEGIN_SRC scheme :tangle ex-4-4-test.scm
  (include "ex-4-3")
  (use test)

  (test #t (eval-4-1 '(and) '()))
#+END_SRC

     :PROPERTIES:
     :Effort:   0:15
     :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.5][Exercise 4.5]]
     CLOCK: [2015-02-16 Mon 14:02]--[2015-02-16 Mon 14:19] =>  0:17

Let's desugar ~cond~ expressions. The ordinary ~cond~ can be desugared to a
chain of if-elses:

#+BEGIN_SRC scheme
  (cond (a b) (c d) (else e)
        ;; Equivalent to (if a b (if c d e))
        )
#+END_SRC

The ~cond~ with recipient is a little more complex. The result of evaluating
the test needs to be referred to twice, once to determine which branch to take
and once to pass to the procedure evaluated if the "true" branch is
taken. In order to make sure no variables in the test, the recipient, or the
alternate shadow each other, use \alpha-conversion to convert an if-statement of
expressions into a lambda taking these expressions as arguments. Since Scheme
is lexically scoped, the bindings in the lambda will not shadow any bindings
inside the arguments:

#+BEGIN_SRC scheme
  (cond (a => proc) (else b)
        ;; Equivalent to (if a (proc a) b)
        ;; Equivalent to ((lambda (x y p) (if x (p x) y)) a b proc)
        )
#+END_SRC

With this realization, it's possible to transform this extended form of ~cond~
into a chain of ~if~ statements without using the environment.

#+NAME: ex-4-5-cond-recipient
#+BEGIN_SRC scheme
  (define (cond? exp) (tagged-list? exp 'cond))
  (define (cond-clauses exp) (cdr exp))
  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))
  (define (cond-recipient-clause? clause)
    (eq? (cadr clause) '=>))
  (define (cond-predicate clause) (car clause))
  (define (cond-actions clause) (cdr clause))
  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false                          ; no else clause
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (cond ((cond-else-clause? first)
                 (if (null? rest)
                     (sequence->exp (cond-actions first))
                     (error "ELSE clause isn't last -- COND->IF"
                            clauses)))
                ((cond-recipient-clause? first)
                 `(,(make-lambda
                     '(test recipient alternate)
                     `(,(make-if 'test '(recipient test) 'alternate)))
                   ,(car first) ,(caddr first) ,(expand-clauses rest)))
                (else (make-if (cond-predicate first)
                               (sequence->exp (cond-actions first))
                               (expand-clauses rest)))))))
#+END_SRC

#+NAME: ex-4-5-cond-recipient-dispatch
#+BEGIN_SRC scheme
  (eval-4-1-put 'cond
                (lambda (exp env)
                  (cond->if exp)))
#+END_SRC

     :PROPERTIES:
     :Effort:   0:30
     :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.6][Exercise 4.6]]
     CLOCK: [2015-02-16 Mon 14:19]--[2015-02-16 Mon 14:22] =>  0:03

#+NAME: ex-4-6-let
#+BEGIN_SRC scheme
  (use srfi-1)

  (define (let->combination exp)
    (let* ((clauses (cdr exp))
           (bindings (car clauses))
           (body (cdr clauses)))
      (let* (
             ;; Partition list of bindings ((a 1) (b 2) ...) into a pair of a
             ;; parameter list and an argument list ((a b ...) . (1 2 ...)).
             (res (fold-right
                   (lambda (e ls)
                     (cons
                      (cons (car e) (car ls))
                      (cons (cadr e) (cdr ls))))
                   '(() . ())
                   bindings))
             (params (car res))
             (args (cdr res)))
        `(,(make-lambda params body)
          ,@args))))
#+END_SRC

#+NAME: ex-4-6-let-dispatch
#+BEGIN_SRC scheme
  (eval-4-1-put 'let
                (lambda (exp env)
                  (eval-4-1 (let->combination exp) env)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-4-6-test.scm
  (include "ex-4-3")
  (use test)

  (test-group "test-4-6"
              (test 5
                    (eval-4-1 '(let ((x 2)) (+ x 3)) (setup-environment))))
#+END_SRC

     :PROPERTIES:
     :Effort:   0:30
     :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.7][Exercise 4.7]]
     CLOCK: [2015-05-23 Sat 16:27]--[2015-05-23 Sat 16:47] =>  0:20

#+NAME: ex-4-7-let-star
#+BEGIN_SRC scheme
  (use srfi-1)

  (define (let*->nested-lets exp)
    (let* ((clauses (cdr exp))
           (bindings (car clauses))
           (body (cdr clauses)))
      ;; The let expressions must be wrapped in parentheses, while the body must
      ;; be spliced into the innermost let clause. However, the recursion below
      ;; doesn't allow the body to be spliced in, since that would require
      ;; looking ahead past the current binding. So we wrap the generated let
      ;; expressions in an extra pair of parentheses and splice in all results of
      ;; ITER, making BODY spliced in but the LET expressions still wrapped in
      ;; parentheses at the end. Finally, we need to remove the outermost layer
      ;; of parentheses with the CAR.
      (car
       (let iter ((bindings bindings))
         (if (null? bindings)
             body
             `((let ((,(caar bindings) ,(cadar bindings)))
                 ,@(iter (cdr bindings)))))))))
#+END_SRC

#+NAME: ex-4-7-let-star-dispatch
#+BEGIN_SRC scheme
  (eval-4-1-put 'let*
                (lambda (exp env)
                  (eval-4-1 (let*->nested-lets exp) env)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-4-7-test.scm
  (include "ex-4-3")
  (use test)

  (test-group "test-4-7"
              (test 9
                    (eval-4-1 '(let* ((x 2)
                                      (y (+ x 3)))
                                 (+ y 4))
                              (setup-environment))))
#+END_SRC
     :PROPERTIES:
     :Effort:   0:15
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.8][Exercise 4.8]]

Let's try an example transformation:

#+BEGIN_SRC scheme
  (let f ((a b) (c d)) e
       ;; Equivalent to (lambda () (define (f a c) e) (f b d))
       )
#+END_SRC

However, that uses ~define~, which has to manipulate the symbol table. It would
be easier to a purely syntactic transformation, which requires a fixed-point
combinator to accomplish recursion without referring explicitly to the name of
the recursing function. First we do an implementation for a function of one
argument:

#+BEGIN_SRC scheme
  (use test)

  ;;; With names to illustrate what's going on.
  (define (fix f)
    (lambda (x)
      (f (fix f) x)))
  (define (factabs fact x)
    (if (= x 0)
        1
        (* x (fact (- x 1)))))
  (test 120 ((fix factabs) 5))

  ;;; Now purely with lambdas
  ;; Y-combinator
  (lambda (f)
    ((lambda (x)
       (f (x x)))
     (lambda (x)
       (f (x x)))))

  (test
   120
   (
    ;; FIX
    (lambda (f)
      (lambda (x)
        (f ())))
    5))
#+END_SRC

#+NAME: ex-4-8-let-named
#+BEGIN_SRC scheme
  (use srfi-1)

  (define (let->combination exp)
    (let* ((proc (if (symbol? (cadr exp))
                     (cadr exp)
                     #f))
           (clauses (if (symbol? (cadr exp))
                        (cddr exp)
                        (cdr exp)))
           (bindings (car clauses))
           (body (cdr clauses)))
      (let* (
             ;; Partition list of bindings ((a 1) (b 2) ...) into a pair of a
             ;; parameter list and an argument list ((a b ...) . (1 2 ...)).
             (res (fold-right
                   (lambda (e ls)
                     (cons
                      (cons (car e) (car ls))
                      (cons (cadr e) (cdr ls))))
                   '(() . ())
                   bindings))
             (params (car res))
             (args (cdr res)))
        (if proc
            `((lambda ()
                (define (,proc ,@params) ,@body)
                (,proc ,@args)))
            `((lambda ,params ,@body)
              ,@args)))))
#+END_SRC

#+NAME: ex-4-8-let-named-dispatch
#+BEGIN_SRC scheme
  (eval-4-1-put 'let
                (lambda (exp env)
                  (eval-4-1 (let->combination exp) env)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-4-8-test.scm
  (include "ex-4-3")
  (use test)

  (test-group "test-4-8"
              (test 5
                    (eval-4-1 '(let ((x 2)) (+ x 3)) (setup-environment)))
              (test 21
                    (eval-4-1
                     '(let fib-iter ((a 1)
                                     (b 0)
                                     (count 8))
                        (if (= count 0)
                            b
                            (fib-iter (+ a b) a (- count 1))))
                     (setup-environment)))
              (test 21
                    (eval-4-1
                     '(let ((n 8))
                        (let fib-iter ((a 1)
                                       (b 0)
                                       (count n))
                          (if (= count 0)
                              b
                              (fib-iter (+ a b) a (- count 1)))))
                     (setup-environment))))
#+END_SRC

     CLOCK: [2015-05-23 Sat 16:47]--[2015-05-23 Sat 18:05] =>  1:18
     :PROPERTIES:
     :Effort:   0:30
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.9][Exercise 4.9]]
     - Note taken on [2015-05-23 Sat 18:46] \\
       Test is failing because, inside a procedure, setting the value of a variable
       defined in the enclosing scope doesn't seem to stick after the lambda
       returns. Since Section 4.1.3 deals with the environment lookup, I'll come back
       to this after I fix the environment.
     CLOCK: [2015-05-23 Sat 18:11]--[2015-05-23 Sat 18:48] =>  0:37
     CLOCK: [2015-05-23 Sat 18:05]--[2015-05-23 Sat 18:11] =>  0:06

#+BEGIN_SRC scheme
  (while p b
         ;; Equivalent to (let foo ((p (lambda () p)) (b (lambda () b)) (if (not
         ;; (p)) #f (b) (foo p b)))
         )
#+END_SRC

#+NAME: ex-4-9-while
#+BEGIN_SRC scheme
  (define (expand-while exp)
    (let* ((pred (cadr exp))
           (body (cddr exp)))
      `(let iter ((pred (lambda () ,pred))
                  (body (lambda () ,@body)))
         (if (not (pred))
             #f
             (begin
               (body)
               (iter pred body))))))
#+END_SRC

#+NAME: ex-4-9-while-dispatch
#+BEGIN_SRC scheme
  (eval-4-1-put 'while
                (lambda (exp env)
                  (eval-4-1 (expand-while exp) env)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-4-9-test.scm
  (include "ex-4-3")
  (use test)

  (test-group "ex-4-9"
              (test 1
                    (eval-4-1
                     '(begin
                        (define x 0)
                        (while (= x 0)
                          (set! x 1))
                        x)
                     (setup-environment))))
#+END_SRC
     :PROPERTIES:
     :Effort:   0:30
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.10][Exercise 4.10]]
     CLOCK: [2015-02-20 Fri 17:14]--[2015-02-20 Fri 19:01] =>  1:47
     - Note taken on [2015-02-17 Tue 17:24] \\
       I've got the lexer done. Onto the parser.
     CLOCK: [2015-02-17 Tue 16:32]--[2015-02-17 Tue 17:25] =>  0:53
     CLOCK: [2015-02-17 Tue 00:42]--[2015-02-17 Tue 00:59] =>  0:17
     CLOCK: [2015-02-17 Tue 00:05]--[2015-02-17 Tue 00:39] =>  0:34
     CLOCK: [2015-02-16 Mon 17:32]--[2015-02-16 Mon 17:46] =>  0:14
     CLOCK: [2015-02-16 Mon 14:22]--[2015-02-16 Mon 16:05] =>  1:43

I'm going to try to do this with M-expressions.

#+BEGIN_EXAMPLE
  S ::= ...

  SEXPR ::= ATOM
            | '\'' SEXPR
            | '`' SEXPR
            | ',' SEXPR
            | ',@' SEXPR
            | '(' SEXPR_END
  SEXPR_BODY ::= ')'
                | SEXPR SEXPR_END
  SEXPR_END ::= '.' SEXPR ')'
                | SEXPRS_REST
  SEXPRS_REST ::= ')'
                  | SEXPR SEXPRS_REST
  ATOM ::= NUM | BOOL | SYMBOL
  NUM ::= /[0-9]+(\.[0-9]*)?|\.[0-9]+/
  BOOL ::= "#t" | "#f"
  SYMBOL ::= /[-+*/_a-zA-Z][-+*/_a-zA-Z0-9]*/

#+END_EXAMPLE

#+BEGIN_SRC scheme :tangle ex-4-10.scm
  <<mexpr-lexer>>
  <<mexpr-parser>>
#+END_SRC

#+NAME: mexpr-lexer
#+BEGIN_SRC scheme
  (use srfi-1)

  (define (scan-terminal port start? continue? string->result)
    (let ((in (peek-char port)))
      (if (or (eof-object? in) (not (start? in)))
          #f
          (let iter ((chars (list (read-char port))))
            (let ((in (peek-char port)))
              (if (or (eof-object? in) (not (continue? in)))
                  (string->result
                   ((compose list->string reverse) chars))
                  (iter (cons (read-char port) chars))))))))

  (define (atomize atom) `(atom . ,atom))
  (define (atom-token? token) (and (pair? token) (eq? (car token) 'atom)))
  (define (atom-value token) (cdr token))
  (define (scan-symbol port)
    (define (symbol-start? c)
      (or (char-alphabetic? c)
          (char-numeric? c)
          (find (lambda (x) (char=? c x)) '(#\+ #\- #\* #\/ #\= #\< #\> #\? #\_))))
    (define (symbol-continue? c)
      (or (symbol-start? c) (char-numeric? c)))
    (scan-terminal port symbol-start? symbol-continue? (compose atomize string->symbol)))

  (define (scan-num port)
    (scan-terminal port char-numeric? char-numeric? (compose atomize string->number)))

  (define true #t)
  (define false #f)
  (define (scan-bool port)
    (scan-terminal port
                   (lambda (c) (char=? c #\#))
                   (lambda (c) (or (char-ci=? c #\t) (char-ci=? c #\f)))
                   (lambda (s) (cond ((string-ci=? s "#t") (atomize true))
                                     (else (atomize false))))))

  (define (consume-whitespace port)
    (scan-terminal port char-whitespace? char-whitespace? (constant 'whitespace)))
  (define (consume-line-comment port)
    (scan-terminal port
                   (lambda (c) (char=? #\; c))
                   (lambda (c) (not (char=? #\newline c)))
                   (constant 'line-comment)))
  (define (consume-space port)
    (if (not (and (consume-whitespace port)
                  (consume-line-comment port)))
        #f
        (consume-space port)))

  ;; Single-character tokens
  (define (constant value) (lambda (x) value))
  (define (make-scan-literal-char c)
    (lambda (port)
      (scan-terminal port
                     (lambda (inc) (char=? c inc))
                     (lambda (inc) #f)
                     (constant c))))

  (define lparen #\()
  (define scan-lparen (make-scan-literal-char lparen))
  (define rparen #\))
  (define scan-rparen (make-scan-literal-char rparen))

  (define lbracket #\()
  (define scan-lbracket (make-scan-literal-char lbracket))
  (define rbracket #\))
  (define scan-rbracket (make-scan-literal-char rbracket))

  (define dot #\.)
  (define scan-dot (make-scan-literal-char dot))

  (define semicolon #\;)
  (define scan-semicolon (make-scan-literal-char semicolon))

  (define quote-sym #\')
  (define scan-quote-sym (make-scan-literal-char quote-sym))
  (define quasiquote-sym #\`)
  (define scan-quasiquote-sym (make-scan-literal-char quasiquote-sym))

  ;;; Parse both unquote operators here, since we need the lookahead to
  ;;; distinguish between unquote (",") and unquote-splicing (",@").
  (define unquote-sym #\,)
  (define unquote-splicing-sym '(#\, #\@))
  (define (scan-unquotes port)
    (let ((in (peek-char port)))
      (if (or (eof-object? in)
              (not (char=? in #\,)))
          #f
          (begin
            (read-char port)
            (let ((in (peek-char port)))
              (if (or (eof-object? in)
                      (not (char=? in #\@)))
                  unquote-sym
                  (begin
                    (read-char port)
                    unquote-splicing-sym)))))))

  (define (identity x) x)
  (define (nonnull? x) (not (null? x)))
  (define (atom? x)
    (or (number? x) (symbol? x) (boolean? x)))
  (define (scan-next-token port)
    (consume-space port)
    (cond ((scan-lparen port) => identity)
          ((scan-rparen port) => identity)
          ((scan-lbracket port) => identity)
          ((scan-rbracket port) => identity)
          ((scan-dot port) => identity)

          ((scan-unquotes port) => identity)
          ((scan-quasiquote-sym port) => identity)
          ((scan-quote-sym port) => identity)

          ((scan-symbol port) => identity)
          ((scan-num port) => identity)
          ((scan-bool port) => identity)

          ((eof-object? (peek-char port)) (peek-char port))
          (else (error "SCAN-NEXT-TOKEN: Next token not found")))
    )
#+END_SRC

#+NAME: mexpr-parser
#+BEGIN_SRC scheme
  (define (make-next-token port)
    (define lookahead '())
    (define (get)
      (if (nonnull? lookahead)
          (let ((token lookahead))
            (set! lookahead '())
            token)
          (scan-next-token port)))
    (define (unget token)
      (set! lookahead token))
    (define (dispatch msg)
      (cond ((eq? msg 'get) get)
            ((eq? msg 'unget) unget)
            (else (error "NEXT-TOKEN -- unrecognized message"))))
    dispatch)

  (define (read-sexpr next-token)
    (let ((token ((next-token 'get))))
                                          ; (display token) (newline)
      (cond
       ;; TODO: Why doesn't `(quasiquote ,expr) work?
       ((eq? token quote-sym)
        (list 'quote (read-sexpr next-token)))
       ((eq? token quasiquote-sym)
        (list 'quasiquote (read-sexpr next-token)))
       ((eq? token unquote-sym)
        (list 'unquote (read-sexpr next-token)))
       ((eq? token unquote-splicing-sym)
        (list 'unquote-splicing (read-sexpr next-token)))

       ((atom-token? token)
        (atom-value token))
       ((eq? token lparen)
        (read-sexpr-body next-token))
       (else "READ-SEXPR: No parse"))))

  (define (read-sexpr-body next-token)
    (let ((token ((next-token 'get))))
      (cond ((eq? token rparen) '())
            (else
             ((next-token 'unget) token)
             (let* ((sexpr (read-sexpr next-token))
                    (sexpr-end (read-sexpr-end next-token)))
               (cons sexpr sexpr-end))))))

  (define (read-sexpr-end next-token)
    (let ((token ((next-token 'get))))
      (cond ((eq? token dot)
             (let* ((sexpr (read-sexpr next-token))
                    (end ((next-token 'get))))
               (if (eq? end rparen)
                   sexpr
                   (error "READ-SEXPR-END: Failed parse of dotted pair"))))
            (else
             ((next-token 'unget) token)
             (read-sexprs-rest next-token)))))

  (define (read-sexprs-rest next-token)
    (let ((token ((next-token 'get))))
      (cond ((eq? token rparen) '())
            (else
             ((next-token 'unget) token)
             (let* ((sexpr (read-sexpr next-token))
                    (sexprs-rest (read-sexprs-rest next-token)))
               (cons sexpr sexprs-rest))))))
#+END_SRC

     :PROPERTIES:
     :Effort:   3:00
     :END:
*** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.3][4.1.3: Evaluator Data Structures]] [3/4]
**** Code

#+NAME: evaluator-structs
#+BEGIN_SRC scheme
  <<evaluator-structs-predicates>>
  <<evaluator-structs-procedures>>
  <<ex-4-12-environments>>
#+END_SRC

#+NAME: evaluator-structs-predicates
#+BEGIN_SRC scheme
  ;;; Define true and false inside the interpreter, to show that it's not
  ;;; necessary to conflate the representation of booleans in the interpreter
  ;;; with the implementing language's representation.
  (define true 'sec-4-1-true)
  (define false 'sec-4-1-false)
  (define (true? x)
    (not (eq? x false)))
  (define (false? x)
    (eq? x false))
#+END_SRC

#+NAME: evaluator-structs-procedures
#+BEGIN_SRC scheme
  (define (make-procedure parameters body env)
    (list 'procedure parameters body env))
  (define (compound-procedure? p)
    (tagged-list? p 'procedure))
  (define (procedure-parameters p) (cadr p))
  (define (procedure-body p) (caddr p))
  (define (procedure-environment p) (cadddr p))
#+END_SRC

#+NAME: evaluator-structs-environments
#+BEGIN_SRC scheme
  (define (enclosing-environment env) (cdr env))
  (define (first-frame env) (car env))
  (define the-empty-environment '())

  (define (make-frame variables values)
    (cons variables values))
  (define (frame-variables frame) (car frame))
  (define (frame-values frame) (cdr frame))
  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))

  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (if (< (length vars) (length vals))
            (error "Too many arguments supplied" vars vals)
            (error "Too few arguments supplied" vars vals))))

  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (car vals))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Unbound variable" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Unbound variable -- SET!" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (define-variable! var val env)
    (let ((frame (first-frame env)))
      (define (scan vars vals)
        (cond ((null? vars)
               (add-binding-to-frame! var val frame))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (scan (frame-variables frame)
            (frame-values frame))))
#+END_SRC

**** DONE Read SICP 4.1.3
     :PROPERTIES:
     :Effort:   0:15
     :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.11][Exercise 4.11]]
     CLOCK: [2015-05-23 Sat 20:57]--[2015-05-23 Sat 21:05] =>  0:08
     :PROPERTIES:
     :Effort:   0:15
     :END:

Redundant with Exercise 4.12.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.12][Exercise 4.12]]
     CLOCK: [2015-05-23 Sat 21:43]--[2015-05-23 Sat 22:30] =>  0:47

Implement environment bindings as a list of name-value pairs (implemented as a
list of two elements to allow for deleting a binding from an environment, see
Exercise 4.13) instead of as a pair of lists:

#+NAME: ex-4-12-environments
#+BEGIN_SRC scheme
  (define (enclosing-environment env) (cdr env))
  (define (first-frame env) (car env))
  (define the-empty-environment '())

  (define (get-bindings frame) (car frame))
  (define (make-binding var val) (list var val))

  (define (make-frame variables values)
    (let iter ((variables variables)
               (values values)
               (bindings '()))
      (if (null? variables)
          `(,bindings)
          (iter (cdr variables)
                (cdr values)
                (cons (make-binding (car variables) (car values))
                      bindings)))))

  (define (add-binding-to-frame! var val frame)
    (let ((bindings (get-bindings frame)))
      (set-car! frame (cons (make-binding var val) bindings))))

  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (if (< (length vars) (length vals))
            (error "Too many arguments supplied" vars vals)
            (error "Too few arguments supplied" vars vals))))

  (define (lookup-variable-value var env)
    ;; Wrap returned value in list in order to terminate lookup, which requires
    ;; that we unwrap it at the top.
    (let ((res
           (scan-env
            var #f env
            (lambda (var -unused- env frame)
              (scan-bindings
               var #f env frame
               (lambda (var -unused- env frame bindings)
                 (list (cadar bindings)))
               (lambda (var -unused- env frame bindings) #f)))
            (lambda (var -unused- env)
              (error "Unbound variable" var)))))
      (if (pair? res)
          (car res)
          res)))

  (define (set-value-in-bindings! bindings val)
    (set-car! (cdar bindings) val))

  (define (set-variable-value! var val env)
    (scan-env
     var val env
     (lambda (var val env frame)
       (scan-bindings
        var val env frame
        (lambda (var val env frame bindings)
          (set-value-in-bindings! bindings val)
          'ok)
        (lambda (var val env frame bindings) #f)))
     (lambda (var val env)
       (error "Unbound variable -- SET!" var))))

  (define (define-variable! var val env)
    (scan-env
     var val env
     (lambda (var val env frame)
       (scan-bindings
        var val env frame
        (lambda (var val env frame bindings)
          (set-value-in-bindings! bindings val)
          'ok)
        (lambda (var val env frame bindings)
          (add-binding-to-frame! var val frame)
          'ok)))
     (lambda (var val env)
       (error "Should never get here -- DEFINE!"))))

  (define (scan-env var val env on-frame on-not-found-in-env)
    (let env-loop ((env env))
      (if (eq? env the-empty-environment)
          (on-not-found-in-env var val env)
          (let ((frame (first-frame env)))
            (cond ((on-frame var val env frame) => identity)
                  (else (env-loop (enclosing-environment env))))))))

  (define (scan-bindings var val env frame on-found-in-frame on-not-found-in-frame)
    (let frame-loop ((bindings (get-bindings frame)))
      (cond ((null? bindings)
             (on-not-found-in-frame var val env frame bindings))
            ((eq? var (caar bindings))
             (on-found-in-frame var val env frame bindings))
            (else (frame-loop (cdr bindings))))))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-4-12-test.scm
  (include "ex-4-3")
  <<ex-4-12-environments>>
  (use test)

  (test-group "ex-4-12-test"
              (define env (extend-environment '(x y) '(1 2) the-empty-environment))
              (test-assert (equal? env '((((y 2) (x 1))))))
              (define-variable! 'z "zeta" env)
              (test "zeta"
                    (lookup-variable-value 'z env))
              (set-variable-value! 'z "zee" env)
              (test "zee"
                    (lookup-variable-value 'z env))
              (define-variable! 'x 3 env)
              (test 3
                    (lookup-variable-value 'x env))
              (test 2
                    (lookup-variable-value 'y env)))
#+END_SRC
     CLOCK: [2015-05-23 Sat 21:10]--[2015-05-23 Sat 21:41] =>  0:31
     :PROPERTIES:
     :Effort:   0:30
     :END:

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.13][Exercise 4.13]]
     - Note taken on [2015-05-23 Sat 23:51] \\
       Test 7 continues to fail for some reason.

There are three obvious approaches to allow unbinding a variable from the
environment:

1. Unbind the variable in the first frame where it is visible (starting from the
   current frame).
2. Unbind the variable in all frames.
3. Hide the variable from the current frame, but don't affect the bindings in
   higher frames.

Of these approaches, number 3 is the most consistent with the reference
semantics of lexical scoping implied by the way new bindings shadow bindings in
higher frames. When a binding to a variable is added in the current frame, the
value assigned to it shadows the previous value until the current frame is
popped by returning from the procedure, after which the variable continues to
have its previous value. Thus, deleting a binding to a variable should have the
same behavior -- the deletion affects only the current and lower frames and is
voided upon popping the current frame.

It may be argued that approach 1 or 2 is more reasonable, since mutation
affects the value of the variable in the first frame where it's visible even
after the current procedure returns. However, adding a binding to a frame
creates a reference to a value valid until the current frame is popped, so
deleting a binding should also unbind that reference for the lifetime of the
current frame. Mutations, on the other hand, don't affect references, but
rather the value behind the reference.

In Exercise 4.12, I've used the data structure ~`(,var (,val))~ for each
binding rather than the simpler ~`(,var ,val)~ to enable deletions to shadow
earlier bindings by adding a binding of the form
~`(,var the-unbound-sentinel)~ without causing ambiguity if ~val~ happens to be
~the-unbound-sentinel~.

#+NAME: ex-4-13-environments
#+BEGIN_SRC scheme
  <<ex-4-12-environments>>

  (define (unbound-binding? binding)
    (eq? (cdr binding) 'the-unbound-sentinel))

  (define (scan-bindings var val env frame on-found-in-frame on-not-found-in-frame)
    (let frame-loop ((bindings (get-bindings frame)))
      (cond ((or (null? bindings)
                 (unbound-binding? (car bindings)))
             (on-not-found-in-frame var val env frame bindings))
            ((eq? var (caar bindings))
             (on-found-in-frame var val env frame bindings))
            (else (frame-loop (cdr bindings))))))

  (define (lookup-variable-value var env)
    ;; Wrap returned value in list in order to terminate lookup, which requires
    ;; that we unwrap it at the top.
    (let ((res
           (scan-env
            var #f env
            (lambda (var -unused- env frame)
              (scan-bindings
               var #f env frame
               (lambda (var -unused- env frame bindings)
                 (list (cadar bindings)))
               (lambda (var -unused- env frame bindings)
                 (if (and (not (null? bindings))
                          (unbound-binding? (car bindings)))
                     (error "Unbound variable (deleted)" var)
                     #f))))
            (lambda (var -unused- env)
              (error "Unbound variable" var)))))
      (if (pair? res)
          (car res)
          res)))


  (define (make-unbound-variable! var env)
    (scan-env
     var #f env
     (lambda (var -unused- env frame)
       (scan-bindings
        var #f env frame
        (lambda (var -unused- env frame bindings)
          (set-cdr! (car bindings) 'the-unbound-sentinel)
          'ok)
        (lambda (var -unused- env frame bindings)
          (add-binding-to-frame! var -unused- frame)
          'ok)))
     (lambda (var -unused- env)
       (error "Should never get here -- DEFINE!" var))))

  (define (get-make-unbound-variable exp) (cadr exp))
  (define (eval-make-unbound exp env)
    (make-unbound-variable! (get-make-unbound-variable exp)
                            env))
#+END_SRC

#+NAME: ex-4-13-make-unbound-dispatch
#+BEGIN_SRC scheme
  (eval-4-1-put 'make-unbound!
                (lambda (exp env)
                  (eval-make-unbound exp env)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-4-13-test.scm
  (include "ex-4-3")
  <<ex-4-13-environments>>
  (use test)

  (test-group "ex-4-13-test"
              (define env (extend-environment '(x y) '(1 2) the-empty-environment))
              (test-assert (equal? env '((((y 2) (x 1))))))
              (define-variable! 'z "zeta" env)
              (test "zeta"
                    (lookup-variable-value 'z env))
              (set-variable-value! 'z "zee" env)
              (test "zee"
                    (lookup-variable-value 'z env))
              (define-variable! 'x 3 env)
              (test 3
                    (lookup-variable-value 'x env))
              (test 2
                    (lookup-variable-value 'y env))
              ;;; Assert that the effects of make-unbound! disappear once its
              ;;; frame has been popped.
              (test 3
                    (eval-4-1
                     '(begin
                        ((lambda ()
                           (make-unbound! x)))
                        x)
                     env))
              ;;; Assert that make-unbound! actually unbinds the variable.
              (test-assert
               (condition-case
                   (begin
                     (eval-4-1
                      '(begin
                         ((lambda ()
                            (make-unbound! x)
                            x)))
                      env)
                     #f)
                 ((exn) #t))))
#+END_SRC


     CLOCK: [2015-05-23 Sat 22:30]--[2015-05-23 Sat 23:51] =>  1:21
     :PROPERTIES:
     :Effort:   0:45
     :END:
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.4][4.1.4: Running the Evaluator as a Program]] [/]
**** Code

#+NAME: evaluator-running
#+BEGIN_SRC scheme
  <<evaluator-running-primitives>>
  <<evaluator-running-setup>>
  <<evaluator-running-driver>>
#+END_SRC

- Set up the environment:

  #+NAME: evaluator-running-setup
  #+BEGIN_SRC scheme
    (define (setup-environment)
      (let ((initial-env
             (extend-environment (primitive-procedure-names)
                                 (primitive-procedure-objects)
                                 the-empty-environment)))
        (define-variable! 'true true initial-env)
        (define-variable! 'false false initial-env)
        initial-env))
    (define the-global-environment (setup-environment))
  #+END_SRC

- Implement primitive procedures:

  #+NAME: evaluator-running-primitives
  #+BEGIN_SRC scheme
    (define (primitive-procedure? proc)
      (tagged-list? proc 'primitive))

    (define (primitive-implementation proc) (cadr proc))

    (define primitive-procedures
      (list (list 'car car)
            (list 'cdr cdr)
            (list 'cons cons)
            (list 'null? null?)
            (list 'not not)
            (list '+ +)
            (list '- -)
            (list '* *)
            (list '/ /)
            (list '= =)
            ;; <more primitives>
            ))
    (define (primitive-procedure-names)
      (map car
           primitive-procedures))

    (define (primitive-procedure-objects)
      (map (lambda (proc) (list 'primitive (cadr proc)))
           primitive-procedures))

    ;;; Save the APPLY procedure from the underlying Scheme. This separates out the
    ;;; APPLY procedure in the interpreter from that of the underlying Scheme. (I
    ;;; have renamed the interpreter's version APPLY-4-1 as well, instead of just
    ;;; APPLY, as used in the original text.)
    (define apply-in-underlying-scheme apply)
    (define (apply-primitive-procedure proc args)
      (apply-in-underlying-scheme
       (primitive-implementation proc) args))
  #+END_SRC

- Driver loop:

  #+NAME: evaluator-running-driver
  #+BEGIN_SRC scheme
    (use posix)
    (define input-prompt ";;; M-Eval input:")
    (define output-prompt ";;; M-Eval value:")
    (define (driver-loop)
      ;;; Define a temporary port duplicated from standard input in order to allow
      ;;; exiting the driver loop on EOF without exiting the interpreter as well.
      (with-input-from-port (open-input-file* (duplicate-fileno fileno/stdin))
          (lambda ()
            (let iter ()
              (prompt-for-input input-prompt)
              (let ((input (read)))
                (when (not (eof-object? input))
                      (let ((output (eval-4-1 input the-global-environment)))
                        (announce-output output-prompt)
                        (user-print output))
                      (iter)))))))
    (define (prompt-for-input string)
      (newline) (newline) (display string) (newline))

    (define (announce-output string)
      (newline) (display string) (newline))

    (define (user-print object)
      (if (compound-procedure? object)
          (display (list 'compound-procedure
                         (procedure-parameters object)
                         (procedure-body object)
                         '<procedure-env>))
          (display object)))
  #+END_SRC

**** TODO Read SICP 4.1.4
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.14][Exercise 4.14]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.5][4.1.5: Data as Programs]] [/]
**** TODO Read SICP 4.1.5
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.15][Exercise 4.15]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.6][4.1.6: Internal Definitions]] [/]
**** TODO Read SICP 4.1.6
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.16][Exercise 4.16]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.17][Exercise 4.17]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.18][Exercise 4.18]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.19][Exercise 4.19]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.20][Exercise 4.20]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.21][Exercise 4.21]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.7][4.1.7: Separating Syntactic Analysis from Execution]] [0/4]
**** NEXT Read SICP 4.1.7
     CLOCK: [2015-04-26 Sun 15:56]--[2015-04-26 Sun 16:07] =>  0:11
     :PROPERTIES:
     :Effort:   0:15
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.22][Exercise 4.22]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.23][Exercise 4.23]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.24][Exercise 4.24]]

danenberg@'s analytic evaluator was slower than the original evaluator, and one
of the symptoms was garbage collection overheads. Perhaps he was actually
re-analyzing all the time, or throwing away a lot of results.

** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.2][4.2: Variations on a Scheme -- Lazy Evaluation]] [%]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.2.1][4.2.1: Normal Order and Applicative Order]] [/]
**** TODO Read SICP 4.2.1
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.25][Exercise 4.25]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.26][Exercise 4.26]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.2.2][4.2.2: An Interpreter with Lazy Evaluation]] [/]
**** TODO Read SICP 4.2.2
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.29][Exercise 4.29]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.28][Exercise 4.28]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.29][Exercise 4.29]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.30][Exercise 4.30]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.31][Exercise 4.31]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.2.3][4.2.3: Streams as Lazy Lists]] [/]
**** TODO Read SICP 4.2.3
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.32][Exercise 4.32]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.33][Exercise 4.33]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.34][Exercise 4.34]]

** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3][4.3: Variations on a Scheme -- Nondeterministic Computing]] [%]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3.1][4.3.1: Amb and Search]] [3/4]
**** DONE Read SICP 4.3.1
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.35][Exercise 4.35]]

For

#+BEGIN_SRC scheme
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
#+END_SRC

define ~an-integer-between~ as follows:

#+BEGIN_SRC scheme
(define (an-integer-between low high)
  (require (<= low high))
  (amb low (an-integer-between (+ low 1) high)))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.36][Exercise 4.36]]
     - Note taken on [2015-05-04 Mon 17:51] \\
       Need to actually do Exercise 3.69.

In ~a-pythagorean-triple-between~, one cannot simply replace
~an-integer-between~ with ~an-integer-starting-from~, a procedure that
nondeterministically generates any integer starting from a lower bound, because
~amb~ performs a depth-first search, meaning that the call of
~an-integer-starting-from~ to generate one of the numbers (probably ~k~) will
search through an infinite stream of integers, meaning the possibilities for
the other numbers will never been explored.

In order to generate an infinite number of Pythagorean triples, one must use a
similar technique as Exercise 3.69.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.37][Exercise 4.37]]

Yes, this version is more efficient. With the version in 4.35, you must
generate all triples of integers \( [l, h] \times [l, h] \times [l, h] \), where \(l\)
and \(h\) are the ~low~ and ~high~ respectively passed to
~a-pythagorean-triple-between~. This version, on the other hand, only requires
generating pairs \( [l, h] \times [l, h] \), giving an asymptotic \(O(N^2)\) running
time rather than \(O(N^3)\).

*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3.2][4.3.2: Examples of Nondeterministic Programs]] [4/13]
**** DONE Read SICP 4.3.2
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.38][Exercise 4.38]]

To remove the requirement that Smith and Fletcher do not live on adjacent
floors, simply remove the line

#+BEGIN_SRC scheme
(require (not (= (abs (- smith fletcher)) 1)))
#+END_SRC

which produces the following procedure:

#+BEGIN_SRC scheme
(define (multiple-dwelling)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)
          (list 'cooper cooper)
          (list 'fletcher fletcher)
          (list 'miller miller)
          (list 'smith smith))))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.39][Exercise 4.39]]

The order of the restrictions does not affect the answer, since all of the
restrictions must be satisfied in order for the answer to be reached. However,
their order can affect the time it takes to obtain the answer. The simplest way
to see this is to note that moving the distinctness requirement to the end will
increase the number of sets of assignments that need to be evaluated by the
other clauses to \(5^5\) from \(5^{\underline{5}}\).

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.40][Exercise 4.40]]

We can make the program substantially more efficient by imposing all
restrictions that involve one variable before those that involve two and so on
until those involving all five:

#+BEGIN_SRC scheme
(define (multiple-dwelling)
  (let ((baker (amb 1 2 3 4 5)))
    (require (not (= baker 5)))
    (let ((cooper (amb 1 2 3 4 5)))
      (require (not (= cooper 1)))
      (let ((fletcher (amb 1 2 3 4 5)))
        (require (not (= fletcher 5)))
        (require (not (= fletcher 1)))
        (require (not (= (abs (- fletcher cooper)) 1)))
        (let ((miller (amb 1 2 3 4 5)))
          (require (> miller cooper))
          (let (((smith (amb 1 2 3 4 5))))
            (require
             (distinct? (list baker cooper fletcher miller smith)))
            (require (not (= (abs (- smith fletcher)) 1)))
            (list (list 'baker baker)
                  (list 'cooper cooper)
                  (list 'fletcher fletcher)
                  (list 'miller miller)
                  (list 'smith smith))))))))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.41][Exercise 4.41]]

Seems substantially easier to recast in terms of an ordinary recursive Scheme
procedure after looking at the non-deterministic version -- we'll just perform
the tree search ourselves:

#+BEGIN_SRC scheme
(define (multiple-dwelling)
  (filter-mapper
   (lambda (baker)
     (if (not (= baker 5))
         (filter-mapper
          (lambda (cooper)
            (if (not (= cooper 1))
                (filter-mapper
                 (lambda (fletcher)
                   (if (and (not (= fletcher 5))
                            (not (= fletcher 1))
                            (not (= (abs (- fletcher cooper)) 1)))
                       (filter-mapper
                        (lambda (miller)
                          (if (> miller cooper)
                              (filter-mapper
                               (lambda (smith)
                                 (if (and (distinct? (list baker cooper fletcher miller smith))
                                          (not (= (abs (- smith fletcher)) 1)))
                                     (list (list 'baker baker)
                                           (list 'cooper cooper)
                                           (list 'fletcher fletcher)
                                           (list 'miller miller)
                                           (list 'smith smith))
                                     '())))
                              '())))
                       '())
                   ))
                '())))
         '()))))

(define (filter-mapper f)
  (filter (lambda (xs) (not (null? xs)))
          (map f '(1 2 3 4 5))))
(define (distinct? items)
  (cond ((null? items) #t)
        ((null? (cdr items)) #t)
        ((member (car items) (cdr items)) #f)
        (else (distinct? (cdr items)))))
#+END_SRC


**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.42][Exercise 4.42]]

Here's the ~amb~ evaluator-based solution:

#+BEGIN_SRC scheme
(define (solve-liars)
  (let ((betty (amb 1 2 3 4 5))
        (kitty (amb 1 2 3 4 5)))
    (require (xor (= kitty 2)
                  (= betty 3)))
    (let ((mary (amb 1 2 3 4 5)))
      (require (xor (= kitty 2)
                    (= mary 4)))
      (require (xor (= mary 4)
                    (= betty 1)))
      (let ((ethel (amb 1 2 3 4 5))
            (joan (amb 1 2 3 4 5)))
        (require (xor (= ethel 1)
                      (= joan 2)))
        (require (xor (= joan 3)
                      (= ethel 5)))
        (require (distinct? (list betty ethel joan kitty mary)))
        `((betty ,betty)
          (ethel ,ethel)
          (joan ,joan)
          (kitty ,kitty)
          (mary ,mary))))))

(define (xor a b) (not (eq? a b)))
#+END_SRC

However, it's fairly simple to solve this puzzle by hand. Let's perform the
following assignments:

- \(a\): Kitty was second
- \(b\): Betty was third
- \(c\): Mary was fourth
- \(d\): Betty was first
- \(e\): Ethel was first
- \(f\): Joan was second
- \(g\): Joan was third
- \(h\): Ethel was fifth

We want to find all solutions to the equation below where the rank assigned to
each girl is distinct:

\[(a + b) \wedge (a + c) \wedge (c + d) \wedge (e + f) \wedge (g + h)\]

Using the distinctness of ranks, we can add additional constraints:

\[(a + b) \wedge (a + c) \wedge (b + d) \wedge (c + d) \wedge (e + f) \wedge (g + h) \wedge (e + h) \wedge (f + g)\]

Since \(\wedge\) is distributive over \(+\), we first simplify the equation down to

\[(a + (b \wedge c)) \wedge ((b \wedge c) + d) \wedge (e + f) \wedge (g + h) \wedge (e + h) \wedge (f + g)\]

This gives the result

#+BEGIN_SRC scheme
'((betty 3) (ethel 5) (joan 2) (kitty 1) (mary 4))
#+END_SRC

**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.43][Exercise 4.43]]
     - Note taken on [2015-05-17 Sun 19:14] \\
       Still need to determine the number of solutions when Mary Ann's last name is
       not given.

- Mr. Moore
- Colonel Downing
- Mr. Hall
- Sir Barnacle Hood
- Dr. Parker

- Mary Ann Moore
- Gabrielle
- Lorna
- Rosalind
- Melissa

#+BEGIN_SRC scheme
(define (yacht-solver)
  (let ((d-moore (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
        (d-downing (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
        (d-hall (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
        (d-barnacle (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
        (d-parker (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
        (y-moore (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
        (y-downing (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
        (y-hall (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
        (y-barnacle (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
        (y-parker (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa)))
    (require (eq? d-moore 'maryann))
    (require (eq? y-barnacle 'gabrielle))
    (require (eq? y-moore 'lorna))
    (require (eq? y-hall 'rosalind))
    (require (eq? d-barnacle 'melissa))
    (require (eq? y-downing 'melissa))

    (require (not (eq? d-moore y-moore)))
    (require (not (eq? d-downing y-downing)))
    (require (not (eq? d-hall y-hall)))
    (require (not (eq? d-barnacle y-barnacle)))
    (require (not (eq? d-parker y-parker)))

    ;; How to encode "Gabrielle's father owns the yacht that is named after
    ;; Dr. Parker's daughter"?

    ;; More conditions
    (let ((daughters (list d-moore d-downing d-hall d-barnacle d-parker)))
      (list-index (lambda (x) (eq? x 'lorna)) daughters))))
#+END_SRC

The solution is:

- Daughters:
  - Mr. Moore: Mary Ann
  - Colonel Downing: Lorna
  - Mr. Hall: Gabrielle
  - Sir Barnacle Hood: Melissa
  - Dr. Parker: Rosalind

- Yachts:
  - Mr. Moore: Lorna
  - Colonel Downing: Melissa
  - Mr. Hall: Rosalind
  - Sir Barnacle Hood: Gabrielle
  - Dr. Parker: Mary Ann

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.44][Exercise 4.44]]
     - Note taken on [2015-05-17 Sun 19:29] \\
       TODO: Verify that you can actually apply ~amb~ like I'm doing here.

#+BEGIN_SRC scheme
(use sicp)

(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (let ((positions
               (apply amb
                      (flatmap
                       (lambda (rest-of-queens)
                         (map (lambda (new-row)
                                (adjoin-position new-row k rest-of-queens))
                              (enumerate-interval 1 board-size)))
                       (queen-cols (- k 1))))))
          (require (safe? k positions))
          positions)))
  (queen-cols board-size))

;; The representation of an empty board
(define empty-board '())
;; Add a position (new-row . k) to the list rest-of-queens containing positions
;; for queens.
(define (adjoin-position new-row k rest-of-queens)
  (cons (cons new-row k) rest-of-queens))
;; Is the position of the queen in column k safe with respect to the positions
;; in the list positions?
(define (safe? k positions)
  ;; Are positions p1 and p2 safe with respect to each other?
  ;; p1 and p2 are pairs (x . y).
  (define (pos-safe? p1 p2)
    (let ((x1 (car p1))
          (y1 (cdr p1))
          (x2 (car p2))
          (y2 (cdr p2)))
      (let ((dx (- x2 x1))
            (dy (- y2 y1)))
        (or (and (= x1 x2) (= y1 y2))
            (not (or (= 0 dx)
                     (= 0 dy)
                     (= (abs dx) (abs dy))))))))
  ;; Each column has a queen in only one row - find the position in column k
  (let ((last-position (find (lambda (position)
                               (= k (cdr position)))
                             positions)))
    ;; Filter list to contain only unsafe positions.
    (not (find (lambda (point)
                 (not (pos-safe? point last-position)))
               positions))))

(test '(1 0 0 2 10 4 40 92)
      (map (lambda (x) (length (queens x))) (iota 8 1)))
#+END_SRC

#+BEGIN_SRC scheme
(include "ex-4-44")

(use test)

(test '(1 0 0 2 10 4 40 92)
      (map (lambda (x) (length (queens x))) (iota 8 1)))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.45][Exercise 4.45]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.46][Exercise 4.46]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.47][Exercise 4.47]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.48][Exercise 4.48]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.49][Exercise 4.49]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3.3][4.3.3: Implementing the Amb Evaluator]] [/]
**** TODO Read SICP 4.3.3
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.50][Exercise 4.50]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.51][Exercise 4.51]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.52][Exercise 4.52]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.53][Exercise 4.53]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.54][Exercise 4.54]]

** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4][4.4: Logic Programming]] [%]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.1][4.4.1: Deductive Information Retrieval]] [7/10]
    - Note taken on [2015-08-24 Mon 16:18] \\
      Trying to figure out how to use evaluator from the SICP egg.
    :LOGBOOK:
    CLOCK: [2015-08-24 Mon 16:18]--[2015-08-24 Mon 16:25] =>  0:07
    CLOCK: [2015-08-24 Mon 16:12]--[2015-08-24 Mon 16:18] =>  0:06
    :END:
**** DONE Read SICP 4.4.1
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.55][Exercise 4.55]]
     CLOCK: [2015-08-24 Mon 16:57]--[2015-08-24 Mon 17:07] =>  0:10
     CLOCK: [2015-08-17 Mon 17:34]--[2015-08-17 Mon 17:35] =>  0:01
     CLOCK: [2015-08-17 Mon 17:31]--[2015-08-17 Mon 17:34] =>  0:03

#+BEGIN_SRC scheme
  (use sicp-eval-logic test)

  (with-microshaft-database
   (lambda ()
     (test-group
      "Exercise 4.55"
      (test "a. all people supervised by Ben Bitdiddle;"
            '((supervisor (Tweakit Lem E) (Bitdiddle Ben))
              (supervisor (Fect Cy D) (Bitdiddle Ben))
              (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
            (qeval* '(supervisor ?x (Bitdiddle Ben)))))

     (test "b. the names and jobs of all people in the accounting division;"
           '((job (Cratchet Robert) (accounting scrivener))
             (job (Scrooge Eben) (accounting chief accountant)))
           (qeval* '(job ?x (accounting . ?type))))


     (test "c. the names and addresses of all people who live in Slumerville."
           '((address (Aull DeWitt) (Slumerville (Onion Square) 5))
             (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
             (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
           (qeval* '(address ?x (Slumerville . ?addr))))))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.56][Exercise 4.56]]
     :PROPERTIES:
     :ORDERED:  t
     :END:
     CLOCK: [2015-08-24 Mon 17:10]--[2015-08-24 Mon 17:20] =>  0:10
     CLOCK: [2015-08-24 Mon 17:07]--[2015-08-24 Mon 17:10] =>  0:00
     CLOCK: [2015-08-17 Mon 17:37]--[2015-08-17 Mon 17:45] =>  0:08

#+BEGIN_SRC scheme
  (use sicp-eval-logic test)

  (with-microshaft-database
   (lambda ()
     (test-group
      "Exercise 4.56"
      (test "a. the names of all people who are supervised by Ben Bitdiddle, together with their addresses;"
            '((and (supervisor (Tweakit Lem E) (Bitdiddle Ben))
                   (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
              (and (supervisor (Fect Cy D) (Bitdiddle Ben))
                   (address (Fect Cy D) (Cambridge (Ames Street) 3)))
              (and (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
                   (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))))
            (qeval* '(and (supervisor ?person (Bitdiddle Ben))
                          (address ?person ?where))))

      (test "b. all people whose salary is less than Ben Bitdiddle's, together with their salary and Ben Bitdiddle's salary;"
            '((and (salary (Bitdiddle Ben) 60000)
                   (salary (Aull DeWitt) 25000)
                   (lisp-value < 25000 60000))
              (and (salary (Bitdiddle Ben) 60000)
                   (salary (Cratchet Robert) 18000)
                   (lisp-value < 18000 60000))
              (and (salary (Bitdiddle Ben) 60000)
                   (salary (Reasoner Louis) 30000)
                   (lisp-value < 30000 60000))
              (and (salary (Bitdiddle Ben) 60000)
                   (salary (Tweakit Lem E) 25000)
                   (lisp-value < 25000 60000))
              (and (salary (Bitdiddle Ben) 60000)
                   (salary (Fect Cy D) 35000)
                   (lisp-value < 35000 60000))
              (and (salary (Bitdiddle Ben) 60000)
                   (salary (Hacker Alyssa P) 40000)
                   (lisp-value < 40000 60000)))
            (qeval* '(and (salary (Bitdiddle Ben) ?bb-amount)
                          (salary ?person ?amount)
                          (lisp-value < ?amount ?bb-amount))))

      (test "c. all people who are supervised by someone who is not in the computer division, together with the supervisor's name and job."
            '((and (supervisor (Aull DeWitt) (Warbucks Oliver))
                   (not (job (Warbucks Oliver) (computer . ?type))))
              (and (supervisor (Cratchet Robert) (Scrooge Eben))
                   (not (job (Scrooge Eben) (computer . ?type))))
              (and (supervisor (Scrooge Eben) (Warbucks Oliver))
                   (not (job (Warbucks Oliver) (computer . ?type))))
              (and (supervisor (Bitdiddle Ben) (Warbucks Oliver))
                   (not (job (Warbucks Oliver) (computer . ?type)))))
            (qeval* '(and (supervisor ?person ?sup)
                          (not (job ?sup (computer . ?type)))))))))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.57][Exercise 4.57]]
     CLOCK: [2015-08-24 Mon 17:20]--[2015-08-24 Mon 17:47] =>  0:27
     CLOCK: [2015-08-17 Mon 17:46]--[2015-08-17 Mon 17:56] =>  0:10

Define a rule that says that person 1 can replace person 2 if either person 1
does the same job as person 2 or someone who does person 1's job can also do
person 2's job, and if person 1 and person 2 are not the same person.

#+NAME: rule-same
#+BEGIN_SRC scheme
  (qeval* '(assert! (rule (same ?x ?x))))
#+END_SRC

#+NAME: rule-substitute-for
#+BEGIN_SRC scheme
  <<rule-same>>
  (qeval* '(assert! (can-do-job (computer wizard)
                                (computer programmer))))
  (qeval* '(assert! (can-do-job (computer wizard)
                                (computer technician))))
  (qeval* '(assert! (can-do-job (computer programmer)
                                (computer programmer trainee))))
  (qeval* '(assert! (can-do-job (administration secretary)
                                (administration big wheel))))
  (qeval* '(assert! (rule (substitute-for ?person-1 ?person-2)
                          (and (job ?person-1 ?job-1)
                               (job ?person-2 ?job-2)
                               (or (same ?job-1 ?job-2)
                                   (can-do-job ?job-1 ?job-2))
                               (not (same ?person-1 ?person-2))))))
#+END_SRC

Queries:

#+BEGIN_SRC scheme :tangle ex-4-57-test.scm
  (use sicp-eval-logic test)

  (with-microshaft-database
   (lambda ()
    <<rule-substitute-for>>

     (test-group
      "Exercise 4.57"
      (test "a. all people who can replace Cy D. Fect;"
            '((substitute-for (Bitdiddle Ben) (Fect Cy D))
              (substitute-for (Hacker Alyssa P) (Fect Cy D))
              (substitute-for (Hacker Alyssa P) (Fect Cy D)))
            (qeval* '(substitute-for ?person (Fect Cy D))))

      (test "b. all people who can replace someone who is being paid more than they are, together with the two salaries."
            '((and (salary (Aull DeWitt) 25000)
                   (salary (Warbucks Oliver) 150000)
                   (lisp-value < 25000 150000)
                   (substitute-for (Aull DeWitt) (Warbucks Oliver)))
              (and (salary (Fect Cy D) 35000)
                   (salary (Hacker Alyssa P) 40000)
                   (lisp-value < 35000 40000)
                   (substitute-for (Fect Cy D) (Hacker Alyssa P)))
              (and (salary (Fect Cy D) 35000)
                   (salary (Hacker Alyssa P) 40000)
                   (lisp-value < 35000 40000)
                   (substitute-for (Fect Cy D) (Hacker Alyssa P))))
            (qeval* '(and (salary ?person-1 ?amount-1)
                          (salary ?person-2 ?amount-2)
                          (lisp-value < ?amount-1 ?amount-2)
                          (substitute-for ?person-1 ?person-2)))))))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.58][Exercise 4.58]]
     CLOCK: [2015-08-24 Mon 19:00]--[2015-08-24 Mon 19:11] =>  0:11
     CLOCK: [2015-08-17 Mon 18:25]--[2015-08-17 Mon 18:28] =>  0:03

#+BEGIN_SRC scheme
  (use sicp-eval-logic test)

  (with-microshaft-database
   (lambda ()
     (qeval* '(assert!
               (rule (big-shot ?shot)
                     (and (job ?shot (?shot-division . ?shot-type))
                          (or (not (supervisor ?shot ?sup))
                              (and (supervisor ?shot ?sup)
                                   (not (job ?sup (?shot-division . ?sup-type)))))))))
     (test "Foo"
           '((big-shot (Warbucks Oliver))
             (big-shot (Scrooge Eben))
             (big-shot (Bitdiddle Ben)))
           (qeval* '(big-shot ?person)))))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.59][Exercise 4.59]]
     CLOCK: [2015-08-17 Mon 18:46]--[2015-08-17 Mon 18:53] =>  0:07

- a. All meetings on Friday:

     #+BEGIN_SRC scheme
     (meeting ?division (Friday . $time))
     #+END_SRC

- b. Alyssa's rule:

     #+BEGIN_SRC scheme
     (rule (meeting-time ?person ?day-and-time)
           (or (meeting whole-company ?day-and-time)
               (and (job ?person (?division . ?type))
                    (meeting ?division ?day-and-time))))
     #+END_SRC

- c. Alyssa's meetings on Wednesday:

     #+BEGIN_SRC scheme
     (meeting-time (Hacker Alyssa P) (Wednesday . ?time))
     #+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.60][Exercise 4.60]]
     CLOCK: [2015-08-17 Mon 18:56]--[2015-08-17 Mon 19:00] =>  0:04

#+BEGIN_SRC scheme
(and (lives-near ?person-1 ?person-2)
     (not (lives-near ?person-2 ?person-1)))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.61][Exercise 4.61]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.62][Exercise 4.62]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.63][Exercise 4.63]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.2][4.4.2: How the Query System Works]] [/]

No exercises.

**** TODO Read SICP 4.4.2
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.3][4.4.3: Is Logic Programming Mathematical Logic?]] [/]
**** TODO Read SICP 4.4.3
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.64][Exercise 4.64]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.65][Exercise 4.65]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.66][Exercise 4.66]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.67][Exercise 4.67]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.68][Exercise 4.68]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.69][Exercise 4.69]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.4][4.4.4: Implementing the Query System]] [/]
**** TODO Read SICP 4.4.4
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.70][Exercise 4.70]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.71][Exercise 4.71]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.72][Exercise 4.72]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.73][Exercise 4.73]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.74][Exercise 4.74]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.75][Exercise 4.75]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.76][Exercise 4.76]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.77][Exercise 4.77]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.78][Exercise 4.78]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.79][Exercise 4.79]]
