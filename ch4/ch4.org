#+TITLE: Structure and Interpretation of Computer Programs (SICP)
#+AUTHOR: Robert Irelan
#+EMAIL: rirelan@gmail.com
#+OPTIONS: author:t email:t f:t num:nil H:4
#+PROPERTY: header-args :comments noweb :noweb no-export
#+PROPERTY: header-args:scheme :shebang #!/usr/bin/env chicken-scheme
#+FILETAGS: :SICP:

* TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-25.html#%_chap_4][Chapter 4: Metalinguistic Abstraction]] [%]

** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1][4.1: The Metacircular Evaluator]] [14%]
   - Note taken on [2015-02-01 Sun 19:22] \\
     We seem to have a working evaluator now.
   CLOCK: [2015-02-01 Sun 18:19]--[2015-02-01 Sun 19:22] =>  1:03
   CLOCK: [2015-02-01 Sun 18:00]--[2015-02-01 Sun 18:18] =>  0:18
   - Note taken on [2015-02-01 Sun 17:51] \\
     Will take a pass through this section to implement the entire evaluator before
     doing more of the exercises.

*** Code
    :PROPERTIES:
    :VISIBILITY: folded
    :END:

For convenience, put the entire metacircular interpreter here:

#+BEGIN_SRC scheme :tangle interp-sec-4-1.scm
  <<primitive-expressions>>
  <<derived-expressions>>
  <<evaluator-structs>>
  <<evaluator-running>>
  <<eval-sec-4-1>>
#+END_SRC

- Main body of ~eval~:

  #+NAME: eval-sec-4-1
  #+BEGIN_SRC scheme
    <<eval-sec-4-1-aux>>
    (define (eval-4-1 exp env)
      (cond ((self-evaluating? exp) exp)
            ((boolean? exp) (make-boolean exp))
            ((variable? exp) (lookup-variable-value exp env))
            ((quoted? exp) (text-of-quotation exp))
            ((assignment? exp) (eval-assignment exp env))
            ((definition? exp) (eval-definition exp env))
            ((if? exp) (eval-if exp env))
            ((lambda? exp)
             (make-procedure (lambda-parameters exp)
                             (lambda-body exp)
                             env))
            ((begin? exp)
             (eval-sequence (begin-actions exp) env))
            ((cond? exp) (eval-4-1 (cond->if exp) env))
            ((application? exp)
             (apply-4-1 (eval-4-1 (operator exp) env)
                        (list-of-values (operands exp) env)))
            (else
             (error "Unknown expression type -- EVAL" exp))))
  #+END_SRC

- Auxiliary procedures:

  #+NAME: eval-sec-4-1-aux
  #+BEGIN_SRC scheme
    (define (apply-4-1 procedure arguments)
      (cond ((primitive-procedure? procedure)
             (apply-primitive-procedure procedure arguments))
            ((compound-procedure? procedure)
             (eval-sequence
              (procedure-body procedure)
              (extend-environment
               (procedure-parameters procedure)
               arguments
               (procedure-environment procedure))))
            (else
             (error
              "Unknown procedure type -- APPLY-4-1" procedure))))

    (define (list-of-values exps env)
      (if (no-operands? exps)
          '()
          (cons (eval-4-1 (first-operand exps) env)
                (list-of-values (rest-operands exps) env))))

    (define (eval-if exp env)
      (if (true? (eval-4-1 (if-predicate exp) env))
          (eval-4-1 (if-consequent exp) env)
          (eval-4-1 (if-alternative exp) env)))

    (define (eval-sequence exps env)
      (cond ((last-exp? exps) (eval-4-1 (first-exp exps) env))
            (else (eval-4-1 (first-exp exps) env)
                  (eval-sequence (rest-exps exps) env))))

    <<ex-4-4-eval-and-or>>

    (define (eval-assignment exp env)
      (set-variable-value! (assignment-variable exp)
                           (eval-4-1 (assignment-value exp) env)
                           env)
      'ok)

    (define (eval-definition exp env)
      (define-variable! (definition-variable exp)
        (eval-4-1 (definition-value exp) env)
        env)
      'ok)
  #+END_SRC

*** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.1][4.1.1: The Core of the Evaluator]] [2/2]
**** DONE Read SICP 4.1.1
     SCHEDULED: <2015-01-10 Sat>
     CLOCK: [2015-01-10 Sat 12:53]--[2015-01-10 Sat 13:04] =>  0:11
     :PROPERTIES:
     :Effort:   0:15
     :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.1][Exercise 4.1]]
     SCHEDULED: <2015-01-10 Sat>
     CLOCK: [2015-01-10 Sat 16:48]--[2015-01-10 Sat 17:23] =>  0:35

In the original version of the ~list-of-values~ procedure (shown here),

#+BEGIN_SRC scheme
(define (list-of-values exps env)
(if (no-operands? exps)
    '()
    (cons (eval-4-1 (first-operand exps) env)
          (list-of-values (rest-operands exps) env))))
#+END_SRC

whether the first or the rest of the operands of the list is evaluated
first depends on the evaluation order of the underlying
Lisp. Specifically, if the Lisp evaluates from left to right,
~first-operand~ will be called before ~rest-operands~; if the Lisp
evaluates from right to left, ~rest-operands~ is instead called first,
producing a right-to-left evaluating version of ~list-of-values~.

To guarantee the order of execution, one can take advantage of the fact
that the ~begin~ form is guaranteed to evaluate its arguments in order to
write both an explicitly left-to-right version

#+BEGIN_SRC scheme :tangle ex-4-1-ltr.scm
(define (list-of-values exps env)
(if (no-operands? exps)
    '()
    (begin
      ;; First evaluate the leftmost expression, then the rest of the
      ;; expression on the right.
      (define first (eval-4-1 (first-operand exps) env))
      (define rest (list-of-values (rest-operands exps) env))
      (cons first rest))))
#+END_SRC

and a right-to-left version:

#+BEGIN_SRC scheme :tangle ex-4-1-rtl.scm
(define (list-of-values exps env)
(if (no-operands? exps)
    '()
    (begin
      ;; First evaluate the expressions on the right, then the leftmost
      ;; expression.
      (define rest (list-of-values (rest-operands exps) env))
      (define first (eval-4-1 (first-operand exps) env))
      (cons first rest))))
#+END_SRC

Test to confirm:

#+BEGIN_SRC scheme :tangle ex-4-1-test.scm
  (include "interp-sec-4-1")

  ;; Override EVAL for ease of testing
  (define *test-list* '())
  (define eval-4-1
    (lambda (expr env)
      (set! *test-list* (append *test-list* (list expr)))
      (newline)))
  (define input-list '(0 1 2 3 4 5))

  (include "ex-4-1-ltr")
  (set! *test-list* '())
  (list-of-values input-list '())
  (display *test-list*)
  ; (0 1 2 3 4 5)

  (include "ex-4-1-rtl")
  (set! *test-list* '())
  (list-of-values input-list '())
  (display *test-list*)
  ; (5 4 3 2 1 0)

#+END_SRC

     :PROPERTIES:
     :Effort:   0:30
     :END:
*** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.2][4.1.2: Representing Expressions]] [4/10]
**** Code
     :PROPERTIES:
     :VISIBILITY: folded
     :END:

Here's the code for the basic constructs of the interpreter, as defined in
the text:

- Primitive expressions:

  #+NAME: primitive-expressions
  #+BEGIN_SRC scheme
    <<self-evaluating>>
    <<booleans>>
    <<variables>>
    <<quotations>>
    <<assignments>>
    <<definitions>>
    <<lambda-expressions>>
    <<conditionals>>
    <<sequences>>
    <<procedure-application>>
  #+END_SRC

- Self-evaluating items:

  #+NAME: self-evaluating
  #+BEGIN_SRC scheme
    (define (self-evaluating? exp)
      (cond ((number? exp) #t)
            ((string? exp) #t)
            (else #f)))
  #+END_SRC

- Boolean:

  #+NAME: booleans
  #+BEGIN_SRC scheme
    (define (boolean? exp)
      (or (eq? exp #t) (eq? exp #f)))
    (define (make-boolean exp)
      (cond ((eq? exp #t) true)
            ((eq? exp #f) false)
            (else (error "MAKE-BOOLEAN -- passed non-boolean"))))
  #+END_SRC

- Variables:

  #+NAME: variables
  #+BEGIN_SRC scheme
    (define (variable? exp) (symbol? exp))
  #+END_SRC

- Quotations:

  #+NAME: quotations
  #+BEGIN_SRC scheme
    (define (quoted? exp)
      (tagged-list? exp 'quote))

    (define (text-of-quotation exp) (cadr exp))

    (define (tagged-list? exp tag)
      (if (pair? exp)
          (eq? (car exp) tag)
          #f))
  #+END_SRC

- Assignments:

  #+NAME: assignments
  #+BEGIN_SRC scheme
    (define (assignment? exp)
      (tagged-list? exp 'set!))
    (define (assignment-variable exp) (cadr exp))
    (define (assignment-value exp) (caddr exp))
  #+END_SRC

  - Definitions:

  #+NAME: definitions
  #+BEGIN_SRC scheme
    (define (definition? exp)
      (tagged-list? exp 'define))
    (define (definition-variable exp)
      (if (symbol? (cadr exp))
          (cadr exp)
          (caadr exp)))
    (define (definition-value exp)
      (if (symbol? (cadr exp))
          (caddr exp)
          (make-lambda (cdadr exp)   ; formal parameters
                       (cddr exp)))) ; body
  #+END_SRC

  - Lambda expressions:

  #+NAME: lambda-expressions
  #+BEGIN_SRC scheme
    (define (lambda? exp) (tagged-list? exp 'lambda))
    (define (lambda-parameters exp) (cadr exp))
    (define (lambda-body exp) (cddr exp))

    (define (make-lambda parameters body)
      (cons 'lambda (cons parameters body)))

  #+END_SRC

- Conditionals:

  #+NAME: conditionals
  #+BEGIN_SRC scheme
    (define (if? exp) (tagged-list? exp 'if))
    (define (if-predicate exp) (cadr exp))
    (define (if-consequent exp) (caddr exp))
    (define (if-alternative exp)
      (if (not (null? (cdddr exp)))
          (cadddr exp)
          'false))

    (define (make-if predicate consequent alternative)
      (list 'if predicate consequent alternative))
  #+END_SRC

- Sequences:

  #+NAME: sequences
  #+BEGIN_SRC scheme
    (define (begin? exp) (tagged-list? exp 'begin))
    (define (begin-actions exp) (cdr exp))
    (define (last-exp? seq) (null? (cdr seq)))
    (define (first-exp seq) (car seq))
    (define (rest-exps seq) (cdr seq))

    (define (sequence->exp seq)
      (cond ((null? seq) seq)
            ((last-exp? seq) (first-exp seq))
            (else (make-begin seq))))
    (define (make-begin seq) (cons 'begin seq))
  #+END_SRC

- Procedure application:

  #+NAME: procedure-application
  #+BEGIN_SRC scheme
    (define (application? exp) (pair? exp))
    (define (operator exp) (car exp))
    (define (operands exp) (cdr exp))
    (define (no-operands? ops) (null? ops))
    (define (first-operand ops) (car ops))
    (define (rest-operands ops) (cdr ops))
  #+END_SRC

  - Derived expressions:

  #+NAME: derived-expressions
  #+BEGIN_SRC scheme
    <<derived-expressions-cond>>
    <<derived-expressions-let>>
  #+END_SRC

    - ~cond~:

    #+NAME: derived-expressions-cond
    #+BEGIN_SRC scheme
      (define (cond? exp) (tagged-list? exp 'cond))
      (define (cond-clauses exp) (cdr exp))
      (define (cond-else-clause? clause)
        (eq? (cond-predicate clause) 'else))
      (define (cond-predicate clause) (car clause))
      (define (cond-actions clause) (cdr clause))
      (define (cond->if exp)
        (expand-clauses (cond-clauses exp)))

      (define (expand-clauses clauses)
        (if (null? clauses)
            'false                          ; no else clause
            (let ((first (car clauses))
                  (rest (cdr clauses)))
              (if (cond-else-clause? first)
                  (if (null? rest)
                      (sequence->exp (cond-actions first))
                      (error "ELSE clause isn't last -- COND->IF"
                             clauses))
                  (make-if (cond-predicate first)
                           (sequence->exp (cond-actions first))
                           (expand-clauses rest))))))
    #+END_SRC

    - ~let~:

    #+NAME: derived-expressions-let
    #+BEGIN_SRC scheme
      <<ex-4-6>>
    #+END_SRC

**** DONE Read SICP 4.1.2
    SCHEDULED: <2015-01-10 Sat>
    CLOCK: [2015-01-10 Sat 17:54]--[2015-01-10 Sat 18:09] =>  0:15

    :PROPERTIES:
    :Effort:   0:15
    :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.2][Exercise 4.2]]
     SCHEDULED: <2015-01-10 Sat>
     CLOCK: [2015-01-10 Sat 18:13]--[2015-01-10 Sat 18:26] =>  0:13

- Louis' modification to the interpreter will fail if the operator is a
special form rather than a function that can be applied, since the
arguments to special forms might need to be evaluated in a different
manner from those to normal procedures. For example, if Louis' ~eval~ is
called on ~(define x 3)~, it will evaluate ~x~ to its value, rather than
treating ~x~ as the assignment target.

- In order to make Louis' plan work, we need to eliminate the ambiguity
between special forms and ordinary procedures in the syntax. One simple
way to do this is to denote procedure application by the special form
~call~. This can be accomplished by the following modification to the
interpreter:

  #+BEGIN_SRC scheme
    (define (application? exp)
      (and (pair? exp)
           (tagged-list? exp 'call)))
    (define (operator exp) (cadr exp))
    (define (operands exp) (cddr exp))
  #+END_SRC

  :PROPERTIES:
     :Effort:   0:15
     :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.3][Exercise 4.3]]
     SCHEDULED: <2015-02-16 Mon>
     CLOCK: [2015-02-01 Sun 16:45]--[2015-02-01 Sun 17:12] =>  0:27
     CLOCK: [2015-01-10 Sat 18:41]--[2015-01-10 Sat 19:18] =>  0:37

     #+BEGIN_SRC scheme :tangle symbol-table.scm
       (use debug)
       (define (put table op type proc)
         (hash-table-set! table (cons op type) proc))
       (define (get table op type)
         (hash-table-ref/default table (cons op type) '()))
     #+END_SRC

     #+BEGIN_SRC scheme :tangle ex-4-3.scm
       <<primitive-expressions>>
       <<derived-expressions>>
       <<eval-sec-4-1-aux>>

       (include "symbol-table")
       (define *eval-4-1-op-table* (make-parameter (make-hash-table equal?)))
       (define (eval-4-1-get type)
         (get (*eval-4-1-op-table*) 'eval type))
       (define (eval-4-1-put type proc)
         (put (*eval-4-1-op-table*) 'eval type proc))

       (define (eval-4-1 exp env)
         (cond ((self-evaluating? exp) exp)
               ((variable? exp) (lookup-variable-value exp env))
               (else (let ((method (eval-4-1-get (car exp))))
                       (cond ((not (null? method))
                              (method exp env))
                             ((application? exp)
                              (apply-4-1 (eval-4-1 (operator exp) env)
                                         (list-of-values (operands exp) env)))
                             (else
                              (error "Unknown expression type: EVAL" exp)))))))

       (eval-4-1-put 'quote
                     (lambda (exp env)
                       (text-of-quotation exp)))
       (eval-4-1-put 'set!
                     (lambda (exp env)
                       (eval-assignment exp env)))
       (eval-4-1-put 'define
                     (lambda (exp env)
                       (eval-definition exp env)))
       (eval-4-1-put 'if
                     (lambda (exp env)
                       (eval-if exp env)))
       (eval-4-1-put 'lambda
                     (lambda (exp env)
                       (make-procedure (lambda-parameters exp)
                                       (lambda-body exp)
                                       env)))
       (eval-4-1-put 'begin
                     (lambda (exp env)
                       (eval-sequence (begin-actions exp) env)))
       (eval-4-1-put 'cond
                     (lambda (exp env)
                       (eval-4-1 (cond->if exp) env)))

     #+END_SRC

     :PROPERTIES:
     :Effort:   0:30
     :END:
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.4][Exercise 4.4]]
     SCHEDULED: <2015-02-16 Mon>
     CLOCK: [2015-02-16 Mon 13:49]--[2015-02-16 Mon 14:02] =>  0:13

#+NAME: ex-4-4-eval-and-or
#+BEGIN_SRC scheme ex-4-4.scm
  (define (eval-and exps env)
    (if (null? exps)
        true
        (let ((first (first-exp exps)))
             (cond ((last-exp? exps) (eval-4-1 first env))
                   ((not (true? first)) false)
                   (else (eval-and (rest-exps exps) env))))))

  (define (eval-or exps env)
    (if (null? exps)
        false
        (let ((first (first-exp exps)))
             (cond ((true? first) first)
                   (else (eval-or (rest-exps exps) env))))))
#+END_SRC

     :PROPERTIES:
     :Effort:   0:15
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.5][Exercise 4.5]]
     CLOCK: [2015-02-16 Mon 14:02]--[2015-02-16 Mon 14:19] =>  0:17

#+NAME: ex-4-5-cond-recipient
#+BEGIN_SRC scheme
  (define (cond? exp) (tagged-list? exp 'cond))
  (define (cond-clauses exp) (cdr exp))
  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))
  (define (cond-recipient-clause? clause)
    (eq? (cadr clause) '=>))
  (define (cond-predicate clause) (car clause))
  (define (cond-actions clause) (cdr clause))
  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false                          ; no else clause
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (cond ((cond-else-clause? first)
                 (if (null? rest)
                     (sequence->exp (cond-actions first))
                     (error "ELSE clause isn't last -- COND->IF"
                            clauses)))
                ((cond-recipient-clause? first)
                 (make-if ()))
                (else (make-if (cond-predicate first)
                               (sequence->exp (cond-actions first))
                               (expand-clauses rest)))))))

  (cond ((pred1) => foobar)
        ((pred2) quux)
        (else baz))

  (let (res1 (pred1))
    (if res1
        (foobar res1)
        (if (pred2)
            quux
            baz)))

  ((lambda (res1)
     (if res1
         (foobar res1)
         (if (pred2)
             quux
             baz)))
   (pred1))
#+END_SRC

     :PROPERTIES:
     :Effort:   0:30
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.6][Exercise 4.6]]
     CLOCK: [2015-02-16 Mon 14:19]--[2015-02-16 Mon 14:22] =>  0:03

#+NAME: ex-4-6
#+BEGIN_SRC scheme

#+END_SRC

     :PROPERTIES:
     :Effort:   0:30
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.7][Exercise 4.7]]
     :PROPERTIES:
     :Effort:   0:15
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.8][Exercise 4.8]]
     :PROPERTIES:
     :Effort:   0:15
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.9][Exercise 4.9]]
     :PROPERTIES:
     :Effort:   0:30
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.10][Exercise 4.10]]
     CLOCK: [2015-02-20 Fri 17:14]--[2015-02-20 Fri 19:01] =>  1:47
     - Note taken on [2015-02-17 Tue 17:24] \\
       I've got the lexer done. Onto the parser.
     CLOCK: [2015-02-17 Tue 16:32]--[2015-02-17 Tue 17:25] =>  0:53
     CLOCK: [2015-02-17 Tue 00:42]--[2015-02-17 Tue 00:59] =>  0:17
     CLOCK: [2015-02-17 Tue 00:05]--[2015-02-17 Tue 00:39] =>  0:34
     CLOCK: [2015-02-16 Mon 17:32]--[2015-02-16 Mon 17:46] =>  0:14
     CLOCK: [2015-02-16 Mon 14:22]--[2015-02-16 Mon 16:05] =>  1:43

I'm going to try to do this with M-expressions.

#+BEGIN_EXAMPLE
  S ::= ...

  SEXPR ::= ATOM
            | '\'' SEXPR
            | '`' SEXPR
            | ',' SEXPR
            | ',@' SEXPR
            | '(' SEXPR_END
  SEXPR_BODY ::= ')'
                | SEXPR SEXPR_END
  SEXPR_END ::= '.' SEXPR ')'
                | SEXPRS_REST
  SEXPRS_REST ::= ')'
                  | SEXPR SEXPRS_REST
  ATOM ::= NUM | BOOL | SYMBOL
  NUM ::= /[0-9]+(\.[0-9]*)?|\.[0-9]+/
  BOOL ::= "#t" | "#f"
  SYMBOL ::= /[-+*/_a-zA-Z][-+*/_a-zA-Z0-9]*/

#+END_EXAMPLE

#+BEGIN_SRC scheme :tangle ex-4-10.scm
  <<mexpr-lexer>>
  <<mexpr-parser>>
#+END_SRC

#+NAME: mexpr-lexer
#+BEGIN_SRC scheme
  (use srfi-1)

  (define (scan-terminal port start? continue? string->result)
    (let ((in (peek-char port)))
      (if (or (eof-object? in) (not (start? in)))
          #f
          (let iter ((chars (list (read-char port))))
            (let ((in (peek-char port)))
              (if (or (eof-object? in) (not (continue? in)))
                  (string->result
                   ((compose list->string reverse) chars))
                  (iter (cons (read-char port) chars))))))))

  (define (atomize atom) `(atom . ,atom))
  (define (atom-token? token) (and (pair? token) (eq? (car token) 'atom)))
  (define (atom-value token) (cdr token))
  (define (scan-symbol port)
    (define (symbol-start? c)
      (or (char-alphabetic? c)
          (char-numeric? c)
          (find (lambda (x) (char=? c x)) '(#\+ #\- #\* #\/ #\= #\< #\> #\? #\_))))
    (define (symbol-continue? c)
      (or (symbol-start? c) (char-numeric? c)))
    (scan-terminal port symbol-start? symbol-continue? (compose atomize string->symbol)))

  (define (scan-num port)
    (scan-terminal port char-numeric? char-numeric? (compose atomize string->number)))

  (define true #t)
  (define false #f)
  (define (scan-bool port)
    (scan-terminal port
                   (lambda (c) (char=? c #\#))
                   (lambda (c) (or (char-ci=? c #\t) (char-ci=? c #\f)))
                   (lambda (s) (cond ((string-ci=? s "#t") (atomize true))
                                     (else (atomize false))))))

  (define (consume-whitespace port)
    (scan-terminal port char-whitespace? char-whitespace? (constant 'whitespace)))
  (define (consume-line-comment port)
    (scan-terminal port
                   (lambda (c) (char=? #\; c))
                   (lambda (c) (not (char=? #\newline c)))
                   (constant 'line-comment)))
  (define (consume-space port)
    (if (not (and (consume-whitespace port)
                  (consume-line-comment port)))
        #f
        (consume-space port)))

  ;; Single-character tokens
  (define (constant value) (lambda (x) value))
  (define (make-scan-literal-char c)
    (lambda (port)
      (scan-terminal port
                     (lambda (inc) (char=? c inc))
                     (lambda (inc) #f)
                     (constant c))))

  (define lparen #\()
  (define scan-lparen (make-scan-literal-char lparen))
  (define rparen #\))
  (define scan-rparen (make-scan-literal-char rparen))

  (define lbracket #\()
  (define scan-lbracket (make-scan-literal-char lbracket))
  (define rbracket #\))
  (define scan-rbracket (make-scan-literal-char rbracket))

  (define dot #\.)
  (define scan-dot (make-scan-literal-char dot))

  (define semicolon #\;)
  (define scan-semicolon (make-scan-literal-char semicolon))

  (define quote #\')
  (define scan-quote (make-scan-literal-char quote))
  (define quasiquote #\`)
  (define scan-quasiquote (make-scan-literal-char quasiquote))

  ;;; Parse both unquote operators here, since we need the lookahead to
  ;;; distinguish between unquote (",") and unquote-splicing (",@").
  (define unquote #\,)
  (define unquote-splicing '(#\, #\@))
  (define (scan-unquotes port)
    (let ((in (peek-char port)))
      (if (or (eof-object? in)
              (not (char=? in #\,)))
          #f
          (begin
            (read-char port)
            (let ((in (peek-char port)))
              (if (or (eof-object? in)
                      (not (char=? in #\@)))
                  unquote
                  (begin
                    (read-char port)
                    unquote-splicing)))))))

  (define (identity x) x)
  (define (nonnull? x) (not (null? x)))
  (define (atom? x)
    (or (number? x) (symbol? x) (boolean? x)))
  (define (scan-next-token port)
    (consume-space port)
    (cond ((scan-lparen port) => identity)
          ((scan-rparen port) => identity)
          ((scan-lbracket port) => identity)
          ((scan-rbracket port) => identity)
          ((scan-dot port) => identity)

          ((scan-unquotes port) => identity)
          ((scan-quasiquote port) => identity)
          ((scan-quote port) => identity)

          ((scan-symbol port) => identity)
          ((scan-num port) => identity)
          ((scan-bool port) => identity)

          ((eof-object? (peek-char port)) (peek-char port))
          (else (error "SCAN-NEXT-TOKEN: Next token not found")))
    )
#+END_SRC

#+NAME: mexpr-parser
#+BEGIN_SRC scheme
  (define (make-next-token port)
    (define lookahead '())
    (define (get)
      (if (nonnull? lookahead)
          (let ((token lookahead))
            (set! lookahead '())
            token)
          (scan-next-token port)))
    (define (unget token)
      (set! lookahead token))
    (define (dispatch msg)
      (cond ((eq? msg 'get) get)
            ((eq? msg 'unget) unget)
            (else (error "NEXT-TOKEN -- unrecognized message"))))
    dispatch)

  (define (read-sexpr next-token)
    (let ((token ((next-token 'get))))
                                          ; (display token) (newline)
      (cond
       ;; TODO: Why doesn't `(quasiquote ,expr) work?
       ((eq? token quote)
        (list 'quote (read-sexpr next-token)))
       ((eq? token quasiquote)
        (list 'quasiquote (read-sexpr next-token)))
       ((eq? token unquote)
        (list 'unquote (read-sexpr next-token)))
       ((eq? token unquote-splicing)
        (list 'unquote-splicing (read-sexpr next-token)))

       ((atom-token? token)
        (atom-value token))
       ((eq? token lparen)
        (read-sexpr-body next-token))
       (else "READ-SEXPR: No parse"))))

  (define (read-sexpr-body next-token)
    (let ((token ((next-token 'get))))
      (cond ((eq? token rparen) '())
            (else
             ((next-token 'unget) token)
             (let* ((sexpr (read-sexpr next-token))
                    (sexpr-end (read-sexpr-end next-token)))
               (cons sexpr sexpr-end))))))

  (define (read-sexpr-end next-token)
    (let ((token ((next-token 'get))))
      (cond ((eq? token dot)
             (let* ((sexpr (read-sexpr next-token))
                    (end ((next-token 'get))))
               (if (eq? end rparen)
                   sexpr
                   (error "READ-SEXPR-END: Failed parse of dotted pair"))))
            (else
             ((next-token 'unget) token)
             (read-sexprs-rest next-token)))))

  (define (read-sexprs-rest next-token)
    (let ((token ((next-token 'get))))
      (cond ((eq? token rparen) '())
            (else
             ((next-token 'unget) token)
             (let* ((sexpr (read-sexpr next-token))
                    (sexprs-rest (read-sexprs-rest next-token)))
               (cons sexpr sexprs-rest))))))
#+END_SRC

     :PROPERTIES:
     :Effort:   3:00
     :END:
*** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.3][4.1.3: Evaluator Data Structures]] [0/4]
**** Code

#+NAME: evaluator-structs
#+BEGIN_SRC scheme
  <<evaluator-structs-predicates>>
  <<evaluator-structs-procedures>>
  <<evaluator-structs-environments>>
#+END_SRC

#+NAME: evaluator-structs-predicates
#+BEGIN_SRC scheme
  ;;; Define true and false inside the interpreter, to show that it's not
  ;;; necessary to conflate the representation of booleans in the interpreter
  ;;; with the implementing language's representation.
  (define true 'sec-4-1-true)
  (define false 'sec-4-1-false)
  (define (true? x)
    (not (eq? x false)))
  (define (false? x)
    (eq? x false))
#+END_SRC

#+NAME: evaluator-structs-procedures
#+BEGIN_SRC scheme
  (define (make-procedure parameters body env)
    (list 'procedure parameters body env))
  (define (compound-procedure? p)
    (tagged-list? p 'procedure))
  (define (procedure-parameters p) (cadr p))
  (define (procedure-body p) (caddr p))
  (define (procedure-environment p) (cadddr p))
#+END_SRC

#+NAME: evaluator-structs-environments
#+BEGIN_SRC scheme
  (define (enclosing-environment env) (cdr env))
  (define (first-frame env) (car env))
  (define the-empty-environment '())

  (define (make-frame variables values)
    (cons variables values))
  (define (frame-variables frame) (car frame))
  (define (frame-values frame) (cdr frame))
  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))

  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (if (< (length vars) (length vals))
            (error "Too many arguments supplied" vars vals)
            (error "Too few arguments supplied" vars vals))))

  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (car vals))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Unbound variable" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Unbound variable -- SET!" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (define-variable! var val env)
    (let ((frame (first-frame env)))
      (define (scan vars vals)
        (cond ((null? vars)
               (add-binding-to-frame! var val frame))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (scan (frame-variables frame)
            (frame-values frame))))
#+END_SRC

**** TODO Read SICP 4.1.3
     :PROPERTIES:
     :Effort:   0:15
     :END:
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.11][Exercise 4.11]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.12][Exercise 4.12]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.13][Exercise 4.13]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.4][4.1.4: Running the Evaluator as a Program]] [/]
**** Code

#+NAME: evaluator-running
#+BEGIN_SRC scheme
  <<evaluator-running-primitives>>
  <<evaluator-running-setup>>
  <<evaluator-running-driver>>
#+END_SRC

- Set up the environment:

  #+NAME: evaluator-running-setup
  #+BEGIN_SRC scheme
    (define (setup-environment)
      (let ((initial-env
             (extend-environment (primitive-procedure-names)
                                 (primitive-procedure-objects)
                                 the-empty-environment)))
        (define-variable! 'true true initial-env)
        (define-variable! 'false false initial-env)
        initial-env))
    (define the-global-environment (setup-environment))
  #+END_SRC

- Implement primitive procedures:

  #+NAME: evaluator-running-primitives
  #+BEGIN_SRC scheme
    (define (primitive-procedure? proc)
      (tagged-list? proc 'primitive))

    (define (primitive-implementation proc) (cadr proc))

    (define primitive-procedures
      (list (list 'car car)
            (list 'cdr cdr)
            (list 'cons cons)
            (list 'null? null?)
            (list '+ +)
            (list '- -)
            ;; <more primitives>
            ))
    (define (primitive-procedure-names)
      (map car
           primitive-procedures))

    (define (primitive-procedure-objects)
      (map (lambda (proc) (list 'primitive (cadr proc)))
           primitive-procedures))

    ;;; Save the APPLY procedure from the underlying Scheme. This separates out the
    ;;; APPLY procedure in the interpreter from that of the underlying Scheme. (I
    ;;; have renamed the interpreter's version APPLY-4-1 as well, instead of just
    ;;; APPLY, as used in the original text.)
    (define apply-in-underlying-scheme apply)
    (define (apply-primitive-procedure proc args)
      (apply-in-underlying-scheme
       (primitive-implementation proc) args))
  #+END_SRC

- Driver loop:

  #+NAME: evaluator-running-driver
  #+BEGIN_SRC scheme
    (use posix)
    (define input-prompt ";;; M-Eval input:")
    (define output-prompt ";;; M-Eval value:")
    (define (driver-loop)
      ;;; Define a temporary port duplicated from standard input in order to allow
      ;;; exiting the driver loop on EOF without exiting the interpreter as well.
      (with-input-from-port (open-input-file* (duplicate-fileno fileno/stdin))
          (lambda ()
            (let iter ()
              (prompt-for-input input-prompt)
              (let ((input (read)))
                (when (not (eof-object? input))
                      (let ((output (eval-4-1 input the-global-environment)))
                        (announce-output output-prompt)
                        (user-print output))
                      (iter)))))))
    (define (prompt-for-input string)
      (newline) (newline) (display string) (newline))

    (define (announce-output string)
      (newline) (display string) (newline))

    (define (user-print object)
      (if (compound-procedure? object)
          (display (list 'compound-procedure
                         (procedure-parameters object)
                         (procedure-body object)
                         '<procedure-env>))
          (display object)))
  #+END_SRC

**** TODO Read SICP 4.1.4
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.14][Exercise 4.14]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.5][4.1.5: Data as Programs]] [/]
**** TODO Read SICP 4.1.5
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.15][Exercise 4.15]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.6][4.1.6: Internal Definitions]] [/]
**** TODO Read SICP 4.1.6
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.16][Exercise 4.16]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.17][Exercise 4.17]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.18][Exercise 4.18]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.19][Exercise 4.19]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.20][Exercise 4.20]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.21][Exercise 4.21]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.7][4.1.7: Separating Syntactic Analysis from Execution]] [0/4]
**** NEXT Read SICP 4.1.7
     CLOCK: [2015-04-26 Sun 15:56]--[2015-04-26 Sun 16:07] =>  0:11
     :PROPERTIES:
     :Effort:   0:15
     :END:
**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.22][Exercise 4.22]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.23][Exercise 4.23]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.24][Exercise 4.24]]

danenberg@'s analytic evaluator was slower than the original evaluator, and one
of the symptoms was garbage collection overheads. Perhaps he was actually
re-analyzing all the time, or throwing away a lot of results.

** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.2][4.2: Variations on a Scheme -- Lazy Evaluation]] [%]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.2.1][4.2.1: Normal Order and Applicative Order]] [/]
**** TODO Read SICP 4.2.1
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.25][Exercise 4.25]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.26][Exercise 4.26]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.2.2][4.2.2: An Interpreter with Lazy Evaluation]] [/]
**** TODO Read SICP 4.2.2
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.29][Exercise 4.29]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.28][Exercise 4.28]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.29][Exercise 4.29]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.30][Exercise 4.30]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.31][Exercise 4.31]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.2.3][4.2.3: Streams as Lazy Lists]] [/]
**** TODO Read SICP 4.2.3
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.32][Exercise 4.32]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.33][Exercise 4.33]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.34][Exercise 4.34]]

** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3][4.3: Variations on a Scheme -- Nondeterministic Computing]] [%]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3.1][4.3.1: Amb and Search]] [3/4]
**** DONE Read SICP 4.3.1
**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.35][Exercise 4.35]]

For

#+BEGIN_SRC scheme
  (define (a-pythagorean-triple-between low high)
    (let ((i (an-integer-between low high)))
      (let ((j (an-integer-between i high)))
        (let ((k (an-integer-between j high)))
          (require (= (+ (* i i) (* j j)) (* k k)))
          (list i j k)))))
#+END_SRC

define ~an-integer-between~ as follows:

#+BEGIN_SRC scheme
  (define (an-integer-between low high)
    (require (<= low high))
    (amb low (an-integer-between (+ low 1) high)))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.36][Exercise 4.36]]
     - Note taken on [2015-05-04 Mon 17:51] \\
       Need to actually do Exercise 3.69.

In ~a-pythagorean-triple-between~, one cannot simply replace
~an-integer-between~ with ~an-integer-starting-from~, a procedure that
nondeterministically generates any integer starting from a lower bound, because
~amb~ performs a depth-first search, meaning that the call of
~an-integer-starting-from~ to generate one of the numbers (probably ~k~) will
search through an infinite stream of integers, meaning the possibilities for
the other numbers will never been explored.

In order to generate an infinite number of Pythagorean triples, one must use a
similar technique as Exercise 3.69.

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.37][Exercise 4.37]]

Yes, this version is more efficient. With the version in 4.35, you must
generate all triples of integers \( [l, h] \times [l, h] \times [l, h] \), where \(l\)
and \(h\) are the ~low~ and ~high~ respectively passed to
~a-pythagorean-triple-between~. This version, on the other hand, only requires
generating pairs \( [l, h] \times [l, h] \), giving an asymptotic \(O(N^2)\) running
time rather than \(O(N^3)\).

*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3.2][4.3.2: Examples of Nondeterministic Programs]] [4/13]
**** DONE Read SICP 4.3.2
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.38][Exercise 4.38]]

To remove the requirement that Smith and Fletcher do not live on adjacent
floors, simply remove the line

#+BEGIN_SRC scheme
      (require (not (= (abs (- smith fletcher)) 1)))
#+END_SRC

which produces the following procedure:

#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5))
          (cooper (amb 1 2 3 4 5))
          (fletcher (amb 1 2 3 4 5))
          (miller (amb 1 2 3 4 5))
          (smith (amb 1 2 3 4 5)))
      (require
       (distinct? (list baker cooper fletcher miller smith)))
      (require (not (= baker 5)))
      (require (not (= cooper 1)))
      (require (not (= fletcher 5)))
      (require (not (= fletcher 1)))
      (require (> miller cooper))
      (require (not (= (abs (- fletcher cooper)) 1)))
      (list (list 'baker baker)
            (list 'cooper cooper)
            (list 'fletcher fletcher)
            (list 'miller miller)
            (list 'smith smith))))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.39][Exercise 4.39]]

The order of the restrictions does not affect the answer, since all of the
restrictions must be satisfied in order for the answer to be reached. However,
their order can affect the time it takes to obtain the answer. The simplest way
to see this is to note that moving the distinctness requirement to the end will
increase the number of sets of assignments that need to be evaluated by the
other clauses to \(5^5\) from \(5^{\underline{5}}\).

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.40][Exercise 4.40]]

We can make the program substantially more efficient by imposing all
restrictions that involve one variable before those that involve two and so on
until those involving all five:

#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5)))
      (require (not (= baker 5)))
      (let ((cooper (amb 1 2 3 4 5)))
        (require (not (= cooper 1)))
        (let ((fletcher (amb 1 2 3 4 5)))
          (require (not (= fletcher 5)))
          (require (not (= fletcher 1)))
          (require (not (= (abs (- fletcher cooper)) 1)))
          (let ((miller (amb 1 2 3 4 5)))
            (require (> miller cooper))
            (let (((smith (amb 1 2 3 4 5))))
              (require
               (distinct? (list baker cooper fletcher miller smith)))
              (require (not (= (abs (- smith fletcher)) 1)))
              (list (list 'baker baker)
                    (list 'cooper cooper)
                    (list 'fletcher fletcher)
                    (list 'miller miller)
                    (list 'smith smith))))))))
#+END_SRC

**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.41][Exercise 4.41]]

Seems substantially easier to recast in terms of an ordinary recursive Scheme
procedure after looking at the non-deterministic version -- we'll just perform
the tree search ourselves:

#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    (filter-mapper
     (lambda (baker)
       (if (not (= baker 5))
           (filter-mapper
            (lambda (cooper)
              (if (not (= cooper 1))
                  (filter-mapper
                   (lambda (fletcher)
                     (if (and (not (= fletcher 5))
                              (not (= fletcher 1))
                              (not (= (abs (- fletcher cooper)) 1)))
                         (filter-mapper
                          (lambda (miller)
                            (if (> miller cooper)
                                (filter-mapper
                                 (lambda (smith)
                                   (if (and (distinct? (list baker cooper fletcher miller smith))
                                            (not (= (abs (- smith fletcher)) 1)))
                                       (list (list 'baker baker)
                                             (list 'cooper cooper)
                                             (list 'fletcher fletcher)
                                             (list 'miller miller)
                                             (list 'smith smith))
                                       '())))
                                '())))
                         '())
                     ))
                  '())))
           '()))))

  (define (filter-mapper f)
    (filter (lambda (xs) (not (null? xs)))
            (map f '(1 2 3 4 5))))
  (define (distinct? items)
    (cond ((null? items) #t)
          ((null? (cdr items)) #t)
          ((member (car items) (cdr items)) #f)
          (else (distinct? (cdr items)))))
#+END_SRC


**** DONE [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.42][Exercise 4.42]]

Here's the ~amb~ evaluator-based solution:

#+BEGIN_SRC scheme
  (define (solve-liars)
    (let ((betty (amb 1 2 3 4 5))
          (kitty (amb 1 2 3 4 5)))
      (require (xor (= kitty 2)
                    (= betty 3)))
      (let ((mary (amb 1 2 3 4 5)))
        (require (xor (= kitty 2)
                      (= mary 4)))
        (require (xor (= mary 4)
                      (= betty 1)))
        (let ((ethel (amb 1 2 3 4 5))
              (joan (amb 1 2 3 4 5)))
          (require (xor (= ethel 1)
                        (= joan 2)))
          (require (xor (= joan 3)
                        (= ethel 5)))
          (require (distinct? (list betty ethel joan kitty mary)))
          `((betty ,betty)
            (ethel ,ethel)
            (joan ,joan)
            (kitty ,kitty)
            (mary ,mary))))))

  (define (xor a b) (not (eq? a b)))
#+END_SRC

However, it's fairly simple to solve this puzzle by hand. Let's perform the
following assignments:

- \(a\): Kitty was second
- \(b\): Betty was third
- \(c\): Mary was fourth
- \(d\): Betty was first
- \(e\): Ethel was first
- \(f\): Joan was second
- \(g\): Joan was third
- \(h\): Ethel was fifth

We want to find all solutions to the equation below where the rank assigned to
each girl is distinct:

\[(a + b) \wedge (a + c) \wedge (c + d) \wedge (e + f) \wedge (g + h)\]

Using the distinctness of ranks, we can add additional constraints:

\[(a + b) \wedge (a + c) \wedge (b + d) \wedge (c + d) \wedge (e + f) \wedge (g + h) \wedge (e + h) \wedge (f + g)\]

Since \(\wedge\) is distributive over \(+\), we first simplify the equation down to

\[(a + (b \wedge c)) \wedge ((b \wedge c) + d) \wedge (e + f) \wedge (g + h) \wedge (e + h) \wedge (f + g)\]

This gives the result

#+BEGIN_SRC scheme
  '((betty 3) (ethel 5) (joan 2) (kitty 1) (mary 4))
#+END_SRC

**** NEXT [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.43][Exercise 4.43]]
     - Note taken on [2015-05-17 Sun 19:14] \\
       Still need to determine the number of solutions when Mary Ann's last name is
       not given.

- Mr. Moore
- Colonel Downing
- Mr. Hall
- Sir Barnacle Hood
- Dr. Parker

- Mary Ann Moore
- Gabrielle
- Lorna
- Rosalind
- Melissa

#+BEGIN_SRC scheme
  (define (yacht-solver)
    (let ((d-moore (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
          (d-downing (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
          (d-hall (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
          (d-barnacle (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
          (d-parker (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
          (y-moore (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
          (y-downing (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
          (y-hall (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
          (y-barnacle (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))
          (y-parker (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa)))
      (require (eq? d-moore 'maryann))
      (require (eq? y-barnacle 'gabrielle))
      (require (eq? y-moore 'lorna))
      (require (eq? y-hall 'rosalind))
      (require (eq? d-barnacle 'melissa))
      (require (eq? y-downing 'melissa))

      (require (not (eq? d-moore y-moore)))
      (require (not (eq? d-downing y-downing)))
      (require (not (eq? d-hall y-hall)))
      (require (not (eq? d-barnacle y-barnacle)))
      (require (not (eq? d-parker y-parker)))

      ;; How to encode "Gabrielle's father owns the yacht that is named after
      ;; Dr. Parker's daughter"?

      ;; More conditions
      (let ((daughters (list d-moore d-downing d-hall d-barnacle d-parker)))
        (list-index (lambda (x) (eq? x 'lorna)) daughters))))
#+END_SRC

The solution is:

- Daughters:
  - Mr. Moore: Mary Ann
  - Colonel Downing: Lorna
  - Mr. Hall: Gabrielle
  - Sir Barnacle Hood: Melissa
  - Dr. Parker: Rosalind

- Yachts:
  - Mr. Moore: Lorna
  - Colonel Downing: Melissa
  - Mr. Hall: Rosalind
  - Sir Barnacle Hood: Gabrielle
  - Dr. Parker: Mary Ann

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.44][Exercise 4.44]]
     - Note taken on [2015-05-17 Sun 19:29] \\
       TODO: Verify that you can actually apply ~amb~ like I'm doing here.

#+BEGIN_SRC scheme :tangle ex-4-44.scm
  (use sicp)

  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (let ((positions
                 (apply amb
                        (flatmap
                         (lambda (rest-of-queens)
                           (map (lambda (new-row)
                                  (adjoin-position new-row k rest-of-queens))
                                (enumerate-interval 1 board-size)))
                         (queen-cols (- k 1))))))
            (require (safe? k positions))
            positions)))
    (queen-cols board-size))

  ;; The representation of an empty board
  (define empty-board '())
  ;; Add a position (new-row . k) to the list rest-of-queens containing positions
  ;; for queens.
  (define (adjoin-position new-row k rest-of-queens)
    (cons (cons new-row k) rest-of-queens))
  ;; Is the position of the queen in column k safe with respect to the positions
  ;; in the list positions?
  (define (safe? k positions)
    ;; Are positions p1 and p2 safe with respect to each other?
    ;; p1 and p2 are pairs (x . y).
    (define (pos-safe? p1 p2)
      (let ((x1 (car p1))
            (y1 (cdr p1))
            (x2 (car p2))
            (y2 (cdr p2)))
        (let ((dx (- x2 x1))
              (dy (- y2 y1)))
          (or (and (= x1 x2) (= y1 y2))
              (not (or (= 0 dx)
                       (= 0 dy)
                       (= (abs dx) (abs dy))))))))
    ;; Each column has a queen in only one row - find the position in column k
    (let ((last-position (find (lambda (position)
                                 (= k (cdr position)))
                               positions)))
      ;; Filter list to contain only unsafe positions.
      (not (find (lambda (point)
                   (not (pos-safe? point last-position)))
                 positions))))

  (test '(1 0 0 2 10 4 40 92)
        (map (lambda (x) (length (queens x))) (iota 8 1)))
#+END_SRC

#+BEGIN_SRC scheme :tangle ex-4-44-test.scm
  (include "ex-4-44")

  (use test)

  (test '(1 0 0 2 10 4 40 92)
        (map (lambda (x) (length (queens x))) (iota 8 1)))
#+END_SRC

**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.45][Exercise 4.45]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.46][Exercise 4.46]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.47][Exercise 4.47]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.48][Exercise 4.48]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.49][Exercise 4.49]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3.3][4.3.3: Implementing the Amb Evaluator]] [/]
**** TODO Read SICP 4.3.3
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.50][Exercise 4.50]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.51][Exercise 4.51]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.52][Exercise 4.52]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.53][Exercise 4.53]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_thm_4.54][Exercise 4.54]]

** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4][4.4: Logic Programming]] [%]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.1][4.4.4: Deductive Information Retrieval]] [/]
**** TODO Read SICP 4.4.1
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.55][Exercise 4.55]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.56][Exercise 4.56]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.57][Exercise 4.57]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.58][Exercise 4.58]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.59][Exercise 4.59]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.60][Exercise 4.60]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.61][Exercise 4.61]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.62][Exercise 4.62]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.63][Exercise 4.63]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.2][4.4.2: How the Query System Works]] [/]

No exercises.

**** TODO Read SICP 4.4.2
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.3][4.4.3: Is Logic Programming Mathematical Logic?]] [/]
**** TODO Read SICP 4.4.3
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.64][Exercise 4.64]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.65][Exercise 4.65]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.66][Exercise 4.66]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.67][Exercise 4.67]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.68][Exercise 4.68]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.69][Exercise 4.69]]
*** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.4][4.4.4: Implementing the Query System]] [/]
**** TODO Read SICP 4.4.4
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.70][Exercise 4.70]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.71][Exercise 4.71]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.72][Exercise 4.72]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.73][Exercise 4.73]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.74][Exercise 4.74]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.75][Exercise 4.75]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.76][Exercise 4.76]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.77][Exercise 4.77]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.78][Exercise 4.78]]
**** TODO [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_thm_4.79][Exercise 4.79]]
